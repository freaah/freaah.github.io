'use strict';

var host = require('@plasmicapp/host');
var utils = require('@react-aria/utils');
var React = require('react');
var reactAriaComponents = require('react-aria-components');
var common = require('./common-b3b54c72.cjs.js');
var contexts = require('./contexts-6d0cb2b1.cjs.js');
var utils$1 = require('./utils-7d000fa4.cjs.js');
var variantUtils = require('./variant-utils-0ad70db8.cjs.js');
require('@plasmicapp/host/registerComponent');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var React__default = /*#__PURE__*/_interopDefault(React);

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const POPOVER_VARIANTS = [
  "placementTop",
  "placementBottom",
  "placementLeft",
  "placementRight"
];
const { variants, withObservedValues } = variantUtils.pickAriaComponentVariants(POPOVER_VARIANTS);
function BasePopover(props) {
  const _a = props, {
    resetClassName,
    plasmicUpdateVariant,
    setControlContextData,
    matchTriggerWidth
  } = _a, restProps = __objRest(_a, [
    "resetClassName",
    "plasmicUpdateVariant",
    "setControlContextData",
    "matchTriggerWidth"
  ]);
  const isStandalone = !React__default.default.useContext(reactAriaComponents.PopoverContext);
  const hasTrigger = !!React__default.default.useContext(contexts.PlasmicPopoverTriggerContext);
  const triggerRef = React__default.default.useRef(null);
  const canvasContext = host.usePlasmicCanvasContext();
  const matchTriggerWidthProp = hasTrigger && matchTriggerWidth;
  const _b = utils.mergeProps(
    {
      // isNonModal: Whether the popover is non-modal, i.e. elements outside the popover may be interacted with by assistive technologies.
      // Setting isNonModal to true in edit mode (canvas) means that the popover will not prevent the user from interacting with the canvas while the popover is open.
      isNonModal: canvasContext && !canvasContext.interactive
    },
    restProps,
    { className: `${resetClassName}` },
    // Override some props if the popover is standalone
    isStandalone ? {
      triggerRef,
      isNonModal: true,
      // Always true, because we assume that popover is always going to be controlled by a parent like Select, Combobox, DialogTrigger, etc, and its only really standalone in component view
      // In component view, we never want to start with an empty artboard, so isOpen has to be true
      isOpen: true
    } : null
  ), { children } = _b, mergedProps = __objRest(_b, ["children"]);
  React.useEffect(() => {
    setControlContextData == null ? void 0 : setControlContextData({
      canMatchTriggerWidth: hasTrigger
    });
  }, [hasTrigger, setControlContextData]);
  return /* @__PURE__ */ React__default.default.createElement(React__default.default.Fragment, null, isStandalone && /* @__PURE__ */ React__default.default.createElement("div", { ref: triggerRef }), /* @__PURE__ */ React__default.default.createElement(
    reactAriaComponents.Popover,
    __spreadValues({
      style: __spreadValues(__spreadValues({}, matchTriggerWidthProp ? { width: `var(--trigger-width)` } : {}), common.COMMON_STYLES)
    }, mergedProps),
    ({ placement }) => withObservedValues(
      children,
      {
        placementTop: placement === "top",
        placementBottom: placement === "bottom",
        placementLeft: placement === "left",
        placementRight: placement === "right"
      },
      plasmicUpdateVariant
    )
  ));
}
const POPOVER_COMPONENT_NAME = utils$1.makeComponentName("popover");
function registerPopover(loader, overrides) {
  utils$1.registerComponentHelper(
    loader,
    BasePopover,
    {
      name: POPOVER_COMPONENT_NAME,
      displayName: "Aria Popover",
      importPath: "@plasmicpkgs/react-aria/skinny/registerPopover",
      importName: "BasePopover",
      variants,
      defaultStyles: {
        borderWidth: "1px",
        borderStyle: "solid",
        borderColor: "black",
        width: "300px",
        backgroundColor: "#FDE3C3"
      },
      props: __spreadValues({
        children: {
          type: "slot",
          mergeWithParent: true,
          defaultValue: [
            {
              type: "vbox",
              styles: {
                width: "stretch",
                padding: "20px",
                rowGap: "10px"
              },
              children: [
                {
                  type: "text",
                  value: "This is a Popover!"
                },
                {
                  type: "text",
                  value: "You can put anything you can imagine here!",
                  styles: {
                    fontWeight: 500
                  }
                },
                {
                  type: "text",
                  value: "Use it in a `Aria Dialog Trigger` component to trigger it on a button click!"
                }
              ]
            }
          ]
        },
        shouldFlip: {
          type: "boolean",
          description: "Whether the element should flip its orientation (e.g. top to bottom or left to right) when there is insufficient room for it to render completely.",
          defaultValueHint: true
        },
        resetClassName: {
          type: "themeResetClass"
        },
        matchTriggerWidth: {
          type: "boolean",
          defaultValue: true,
          hidden: (_props, ctx) => !(ctx == null ? void 0 : ctx.canMatchTriggerWidth)
        }
      }, common.getCommonOverlayProps("popover", {
        placement: { defaultValueHint: "bottom" },
        offset: { defaultValueHint: 8 },
        containerPadding: { defaultValueHint: 12 },
        crossOffset: { defaultValueHint: 0 }
      })),
      // No isOpen state for popover, because we assume that its open state is always going to be controlled by a parent like Select, Combobox, DialogTrigger, etc.
      styleSections: true,
      trapsFocus: true
    },
    overrides
  );
}

exports.BasePopover = BasePopover;
exports.POPOVER_COMPONENT_NAME = POPOVER_COMPONENT_NAME;
exports.registerPopover = registerPopover;
//# sourceMappingURL=registerPopover.cjs.js.map

'use strict';

var host = require('@plasmicapp/host');
var React = require('react');
var reactAria = require('react-aria');
var reactAriaComponents = require('react-aria-components');
var registerComponent = require('@plasmicapp/host/registerComponent');
var utils = require('@react-aria/utils');
var flattenChildren = require('react-keyed-flatten-children');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var React__default = /*#__PURE__*/_interopDefault(React);
var registerComponent__default = /*#__PURE__*/_interopDefault(registerComponent);
var flattenChildren__default = /*#__PURE__*/_interopDefault(flattenChildren);

var __defProp$s = Object.defineProperty;
var __defProps$n = Object.defineProperties;
var __getOwnPropDescs$n = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$s = Object.getOwnPropertySymbols;
var __hasOwnProp$s = Object.prototype.hasOwnProperty;
var __propIsEnum$s = Object.prototype.propertyIsEnumerable;
var __defNormalProp$s = (obj, key, value) => key in obj ? __defProp$s(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$s = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$s.call(b, prop))
      __defNormalProp$s(a, prop, b[prop]);
  if (__getOwnPropSymbols$s)
    for (var prop of __getOwnPropSymbols$s(b)) {
      if (__propIsEnum$s.call(b, prop))
        __defNormalProp$s(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$n = (a, b) => __defProps$n(a, __getOwnPropDescs$n(b));
function useAutoOpen({
  props,
  open,
  close
}) {
  var _a, _b, _c;
  const inPlasmicCanvas = !!host.usePlasmicCanvasContext();
  const isSelected = (_c = (_b = (_a = host.usePlasmicCanvasComponentInfo) == null ? void 0 : _a(props)) == null ? void 0 : _b.isSelected) != null ? _c : false;
  React.useEffect(() => {
    if (!inPlasmicCanvas) {
      return;
    }
    if (isSelected) {
      open == null ? void 0 : open();
    } else {
      close == null ? void 0 : close();
    }
  }, [isSelected, inPlasmicCanvas]);
}
function registerComponentHelper(loader, component, meta, overrides) {
  if (overrides) {
    meta = __spreadProps$n(__spreadValues$s(__spreadValues$s({}, meta), overrides), {
      props: __spreadValues$s(__spreadValues$s({}, meta.props), overrides.props)
    });
    if (overrides.parentComponentName) {
      meta.name = makeChildComponentName(
        overrides.parentComponentName,
        meta.name
      );
    }
  }
  if (loader) {
    loader.registerComponent(component, meta);
  } else {
    registerComponent__default.default(component, meta);
  }
  return meta;
}
function makeComponentName(name) {
  return `plasmic-react-aria-${name}`;
}
function makeChildComponentName(fullParentName, fullChildName) {
  if (!fullParentName) {
    return fullChildName;
  }
  return `${fullParentName}-${fullChildName.replace(
    "plasmic-react-aria-",
    ""
  )}`;
}
function extractPlasmicDataProps(props) {
  return Object.fromEntries(
    Object.entries(props).filter(([key]) => key.startsWith("data-plasmic-"))
  );
}
function isDefined(thing) {
  return thing !== void 0 && thing !== null;
}

var __defProp$r = Object.defineProperty;
var __getOwnPropSymbols$r = Object.getOwnPropertySymbols;
var __hasOwnProp$r = Object.prototype.hasOwnProperty;
var __propIsEnum$r = Object.prototype.propertyIsEnumerable;
var __defNormalProp$r = (obj, key, value) => key in obj ? __defProp$r(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$r = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$r.call(b, prop))
      __defNormalProp$r(a, prop, b[prop]);
  if (__getOwnPropSymbols$r)
    for (var prop of __getOwnPropSymbols$r(b)) {
      if (__propIsEnum$r.call(b, prop))
        __defNormalProp$r(a, prop, b[prop]);
    }
  return a;
};
function hasParent(_props, ctx) {
  return isDefined(ctx == null ? void 0 : ctx.parent) === true;
}
function isParentReadOnly(_props, ctx) {
  var _a;
  return ((_a = ctx == null ? void 0 : ctx.parent) == null ? void 0 : _a.isReadOnly) === true;
}
function isParentDisabled(_props, ctx) {
  var _a;
  return ((_a = ctx == null ? void 0 : ctx.parent) == null ? void 0 : _a.isDisabled) === true;
}
function resolveAutoComplete(autoCompleteProp) {
  if (typeof autoCompleteProp === "string") {
    return autoCompleteProp;
  }
  if (!autoCompleteProp || !Array.isArray(autoCompleteProp) || autoCompleteProp.includes("off")) {
    return void 0;
  }
  if (autoCompleteProp.includes("off")) {
    return "off";
  }
  if (autoCompleteProp.includes("on") && autoCompleteProp.length === 1) {
    return "on";
  }
  return autoCompleteProp.filter((x) => x !== "on").join(" ");
}
function createNameProp() {
  return {
    type: "string",
    description: "Name for this field if it is part of a form",
    displayName: "Form field key",
    // hidden: hasParent,
    hidden: () => true,
    // hiding required prop until the release of Aria Forms
    advanced: true
  };
}
function createDisabledProp(componentName) {
  return {
    displayName: "Disabled",
    type: "boolean",
    description: `Whether the ${componentName} is read-only and unfocusable`,
    defaultValueHint: false,
    hidden: isParentDisabled
  };
}
function createReadOnlyProp(componentName) {
  return {
    displayName: "Read only",
    type: "boolean",
    description: `Whether the value of this ${componentName} can be changed by the user. Unlike disabled, read-only does not prevent the user from interacting with the component (such as focus).`,
    defaultValueHint: false,
    advanced: true,
    hidden: isParentReadOnly
  };
}
function createRequiredProp(componentName) {
  return {
    displayName: "Required",
    type: "boolean",
    description: `Whether user input is required on the ${componentName} before form submission.`,
    defaultValueHint: false,
    advanced: true,
    // hidden: hasParent,
    hidden: () => true
    // hiding required prop until the release of Aria Forms
  };
}
function createAutoFocusProp(componentName) {
  return {
    type: "boolean",
    description: `Whether the ${componentName} should be focused when rendered`,
    defaultValueHint: false,
    advanced: true,
    hidden: hasParent
  };
}
function createAriaLabelProp(componentName) {
  return {
    type: "string",
    displayName: "ARIA label",
    description: `Assistive technology uses this if there is no visible label for this ${componentName}`,
    advanced: true,
    hidden: hasParent
  };
}
function createChildrenProp() {
  return {
    type: "slot",
    mergeWithParent: true
  };
}
function getCommonProps(componentName, propNames) {
  const commonProps = {
    name: createNameProp(),
    disabled: createDisabledProp(componentName),
    isDisabled: createDisabledProp(componentName),
    readOnly: createReadOnlyProp(componentName),
    isReadOnly: createReadOnlyProp(componentName),
    autoFocus: createAutoFocusProp(componentName),
    "aria-label": createAriaLabelProp(componentName),
    required: createRequiredProp(componentName),
    isRequired: createRequiredProp(componentName),
    children: createChildrenProp(),
    // NOTE: The following props are only applicable to inputs, textareas, and text fields
    value: {
      type: "string",
      editOnly: true,
      displayName: "Initial value",
      uncontrolledProp: "defaultValue",
      description: `The default value of the ${componentName}`,
      hidden: hasParent
    },
    maxLength: {
      type: "number",
      description: "The maximum number of characters supported by the input",
      advanced: true,
      hidden: hasParent
    },
    minLength: {
      type: "number",
      description: "The minimum number of characters supported by the input",
      advanced: true,
      hidden: hasParent
    },
    pattern: {
      type: "string",
      description: "Regex pattern that the value of the input must match to be valid",
      helpText: "For more information about writing Regular Expressions (regex), visit [Regexr](https://regexr.com/)",
      validator: (value) => {
        try {
          new RegExp(value);
          return true;
        } catch (error) {
          return "Invalid Regex";
        }
      },
      advanced: true,
      hidden: hasParent
    },
    type: {
      type: "choice",
      defaultValueHint: "text",
      options: ["text", "search", "url", "tel", "email", "password"],
      description: "The type of data that an input field is expected to handle. It influences the input's behavior, validation, and the kind of interface provided to the user.",
      advanced: true,
      hidden: hasParent
    },
    inputMode: {
      type: "choice",
      description: "hint to browsers as to the type of virtual keyboard configuration to use when editing this element or its contents.",
      options: [
        "none",
        "text",
        "tel",
        "url",
        "email",
        "numeric",
        "decimal",
        "search"
      ],
      hidden: hasParent
    },
    autoComplete: {
      type: "choice",
      advanced: true,
      multiSelect: true,
      hidden: hasParent,
      description: "Guidance as to the type of data expected in the field",
      helpText: "Learn more about the available options on the [MDN guide](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete#values)",
      options: [
        "on",
        "off",
        "name",
        "honorific-prefix",
        "given-name",
        "additional-name",
        "family-name",
        "honorific-suffix",
        "nickname",
        "email",
        "username",
        "new-password",
        "current-password",
        "one-time-code",
        "organization-title",
        "organization",
        "street-address",
        "shipping",
        "billing",
        "address-line1",
        "address-line2",
        "address-line3",
        "address-level4",
        "address-level3",
        "address-level2",
        "address-level1",
        "country",
        "country-name",
        "postal-code",
        "cc-name",
        "cc-given-name",
        "cc-additional-name",
        "cc-family-name",
        "cc-number",
        "cc-exp",
        "cc-exp-month",
        "cc-exp-year",
        "cc-csc",
        "cc-type",
        "transaction-currency",
        "transaction-amount",
        "language",
        "bday",
        "bday-day",
        "bday-month",
        "bday-year",
        "sex",
        "tel",
        "tel-country-code",
        "tel-national",
        "tel-area-code",
        "tel-local",
        "tel-local-suffix",
        "tel-local-prefix",
        "tel-extension",
        "impp",
        "url",
        "photo",
        "webauthn"
      ]
    },
    validationBehavior: {
      type: "choice",
      options: ["native", "aria"],
      description: "Whether to use native HTML form validation to prevent form submission when the value is missing or invalid, or mark the field as required or invalid via ARIA.",
      defaultValueHint: "native",
      advanced: true,
      hidden: hasParent
    },
    onChange: {
      type: "eventHandler",
      argTypes: [{ name: "value", type: "string" }],
      hidden: hasParent
    },
    onFocus: {
      type: "eventHandler",
      argTypes: [{ name: "focusEvent", type: "object" }],
      advanced: true,
      hidden: hasParent
    },
    onBlur: {
      type: "eventHandler",
      argTypes: [{ name: "focusEvent", type: "object" }],
      advanced: true,
      hidden: hasParent
    },
    onFocusChange: {
      type: "eventHandler",
      argTypes: [{ name: "isFocused", type: "boolean" }],
      advanced: true,
      hidden: hasParent
    },
    onKeyDown: {
      type: "eventHandler",
      argTypes: [{ name: "keyboardEvent", type: "object" }],
      advanced: true,
      hidden: hasParent
    },
    onKeyUp: {
      type: "eventHandler",
      argTypes: [{ name: "keyboardEvent", type: "object" }],
      advanced: true,
      hidden: hasParent
    },
    onCopy: {
      type: "eventHandler",
      argTypes: [{ name: "clipbordEvent", type: "object" }],
      advanced: true,
      hidden: hasParent
    },
    onCut: {
      type: "eventHandler",
      argTypes: [{ name: "clipbordEvent", type: "object" }],
      advanced: true,
      hidden: hasParent
    },
    onPaste: {
      type: "eventHandler",
      argTypes: [{ name: "clipbordEvent", type: "object" }],
      advanced: true,
      hidden: hasParent
    },
    onCompositionStart: {
      type: "eventHandler",
      argTypes: [{ name: "compositionEvent", type: "object" }],
      advanced: true,
      hidden: hasParent
    },
    onCompositionEnd: {
      type: "eventHandler",
      argTypes: [{ name: "compositionEvent", type: "object" }],
      advanced: true,
      hidden: hasParent
    },
    onCompositionUpdate: {
      type: "eventHandler",
      argTypes: [{ name: "compositionEvent", type: "object" }],
      advanced: true,
      hidden: hasParent
    },
    onSelect: {
      type: "eventHandler",
      argTypes: [{ name: "selectionEvent", type: "object" }],
      advanced: true,
      hidden: hasParent
    },
    onBeforeInput: {
      type: "eventHandler",
      argTypes: [{ name: "inputEvent", type: "object" }],
      advanced: true,
      hidden: hasParent
    },
    onInput: {
      type: "eventHandler",
      argTypes: [{ name: "inputEvent", type: "object" }],
      advanced: true,
      hidden: hasParent
    },
    placeholder: {
      type: "string"
    }
  };
  const filteredProps = {};
  propNames.forEach((propName) => {
    if (Object.prototype.hasOwnProperty.call(commonProps, propName)) {
      filteredProps[propName] = commonProps[propName];
    }
  });
  return filteredProps;
}
function createPlacementProp(componentName, overrides) {
  return __spreadValues$r({
    type: "choice",
    description: `Default placement of the ${componentName} relative to the trigger, if there is enough space`,
    options: [
      "bottom",
      "bottom left",
      "bottom right",
      "bottom start",
      "bottom end",
      "top",
      "top left",
      "top right",
      "top start",
      "top end",
      "left",
      "left top",
      "left bottom",
      "start",
      "start top",
      "start bottom",
      "right",
      "right top",
      "right bottom",
      "end",
      "end top",
      "end bottom"
    ]
  }, overrides != null ? overrides : {});
}
function createOffsetProp(componentName, overrides) {
  return __spreadValues$r({
    type: "number",
    displayName: "Offset",
    description: `Additional offset applied along the main axis between the ${componentName} and its trigger`,
    advanced: true
  }, overrides != null ? overrides : {});
}
function createContainerPaddingProp(componentName, overrides) {
  return __spreadValues$r({
    type: "number",
    description: `The padding that should be applied between the ${componentName} and its surrounding container. This affects the positioning breakpoints that determine when it will attempt to flip.`,
    advanced: true
  }, overrides != null ? overrides : {});
}
function createCrossOffsetProp(componentName, overrides) {
  return __spreadValues$r({
    type: "number",
    description: `The additional offset applied along the cross axis between the ${componentName} and its anchor element.`,
    advanced: true
  }, overrides != null ? overrides : {});
}
function getCommonOverlayProps(componentName, overrides) {
  const commonProps = {
    placement: createPlacementProp(componentName, overrides["placement"]),
    offset: createOffsetProp(componentName, overrides["offset"]),
    containerPadding: createContainerPaddingProp(
      componentName,
      overrides["containerPadding"]
    ),
    crossOffset: createCrossOffsetProp(
      componentName,
      overrides["crossOffset"]
    )
  };
  return commonProps;
}
const arrowDown = {
  type: "hbox",
  children: [],
  styles: {
    width: 0,
    height: 0,
    padding: 0,
    borderLeftWidth: "5px",
    borderRightWidth: "5px",
    borderTopWidth: "5px",
    borderLeftStyle: "solid",
    borderRightStyle: "solid",
    borderTopStyle: "solid",
    borderLeftColor: "transparent",
    borderRightColor: "transparent",
    borderTopColor: "black"
  }
};
const COMMON_STYLES = { boxSizing: "border-box" };

const ARIA_COMPONENTS_VARIANTS = {
  hovered: {
    cssSelector: "[data-hovered]",
    displayName: "Hovered"
  },
  pressed: {
    cssSelector: "[data-pressed]",
    displayName: "Pressed"
  },
  focused: {
    cssSelector: "[data-focused]",
    displayName: "Focused"
  },
  focusVisible: {
    cssSelector: "[data-focus-visible]",
    displayName: "Focus Visible"
  },
  dragging: {
    cssSelector: "[data-dragging]",
    displayName: "Dragging"
  },
  selected: {
    cssSelector: "[data-selected]",
    displayName: "Selected"
  },
  readonly: {
    cssSelector: "[data-readonly]",
    displayName: "Read Only"
  },
  disabled: {
    cssSelector: "[data-disabled]",
    displayName: "Disabled"
  },
  indeterminate: {
    cssSelector: "[data-indeterminate]",
    displayName: "Indeterminate"
  },
  /*
    NOTE: Placement should be managed as variants, not just props.
    When `shouldFlip` is true, the placement prop may not represent the final position
    (e.g., if placement is set to "bottom" but lacks space, the popover/tooltip may flip to "top").
    However, data-selectors will consistently indicate the actual placement of the popover/tooltip.
  */
  placementLeft: {
    cssSelector: "[data-placement=left]",
    displayName: "Placement (Left)"
  },
  placementRight: {
    cssSelector: "[data-placement=right]",
    displayName: "Placement (Right)"
  },
  placementTop: {
    cssSelector: "[data-placement=top]",
    displayName: "Placement (Top)"
  },
  placementBottom: {
    cssSelector: "[data-placement=bottom]",
    displayName: "Placement (Bottom)"
  }
};
function ChangesObserver({
  children,
  changes,
  updateVariant
}) {
  React__default.default.useEffect(() => {
    if (updateVariant) {
      updateVariant(changes);
    }
  }, [changes, updateVariant]);
  return children;
}
function realWithObservedValues(children, changes, updateVariant) {
  return /* @__PURE__ */ React__default.default.createElement(ChangesObserver, { changes, updateVariant }, children);
}
function pickAriaComponentVariants(keys) {
  return {
    variants: Object.fromEntries(
      keys.map((key) => [key, ARIA_COMPONENTS_VARIANTS[key]])
    ),
    withObservedValues: realWithObservedValues
  };
}

var __defProp$q = Object.defineProperty;
var __defProps$m = Object.defineProperties;
var __getOwnPropDescs$m = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$q = Object.getOwnPropertySymbols;
var __hasOwnProp$q = Object.prototype.hasOwnProperty;
var __propIsEnum$q = Object.prototype.propertyIsEnumerable;
var __defNormalProp$q = (obj, key, value) => key in obj ? __defProp$q(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$q = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$q.call(b, prop))
      __defNormalProp$q(a, prop, b[prop]);
  if (__getOwnPropSymbols$q)
    for (var prop of __getOwnPropSymbols$q(b)) {
      if (__propIsEnum$q.call(b, prop))
        __defNormalProp$q(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$m = (a, b) => __defProps$m(a, __getOwnPropDescs$m(b));
var __objRest$m = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$q.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$q)
    for (var prop of __getOwnPropSymbols$q(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$q.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const BUTTON_VARIANTS = [
  "hovered",
  "pressed",
  "focused",
  "focusVisible",
  "disabled"
];
const { variants: variants$h, withObservedValues: withObservedValues$e } = pickAriaComponentVariants(BUTTON_VARIANTS);
const BaseButton = React__default.default.forwardRef(function BaseButtonInner(props, ref) {
  const { href } = props;
  if (href) {
    return /* @__PURE__ */ React__default.default.createElement(
      LinkButton,
      {
        props,
        ref
      }
    );
  } else {
    const _a = props, { submitsForm, resetsForm, children, plasmicUpdateVariant } = _a, rest = __objRest$m(_a, ["submitsForm", "resetsForm", "children", "plasmicUpdateVariant"]);
    const type = submitsForm ? "submit" : resetsForm ? "reset" : "button";
    const buttonProps = reactAria.mergeProps(rest, {
      type,
      style: COMMON_STYLES,
      ref
    });
    return /* @__PURE__ */ React__default.default.createElement(reactAriaComponents.Button, __spreadValues$q({}, buttonProps), ({ isHovered, isPressed, isFocused, isFocusVisible, isDisabled }) => withObservedValues$e(
      children,
      {
        hovered: isHovered,
        pressed: isPressed,
        focused: isFocused,
        focusVisible: isFocusVisible,
        disabled: isDisabled
      },
      plasmicUpdateVariant
    ));
  }
});
function LinkButton({
  props,
  ref
}) {
  const _a = props, { href, children, plasmicUpdateVariant } = _a, rest = __objRest$m(_a, ["href", "children", "plasmicUpdateVariant"]);
  const PlasmicLink = host.usePlasmicLink();
  const { linkProps, isPressed } = reactAria.useLink(props, ref);
  const { hoverProps, isHovered } = reactAria.useHover(props);
  const { focusProps, isFocused, isFocusVisible } = reactAria.useFocusRing();
  const combinedLinkProps = reactAria.mergeProps(linkProps, hoverProps, focusProps, {
    href,
    className: props.className,
    style: COMMON_STYLES,
    ref
  });
  return /* @__PURE__ */ React__default.default.createElement(
    PlasmicLink,
    __spreadProps$m(__spreadValues$q({}, combinedLinkProps), {
      "data-focused": isFocused || void 0,
      "data-hovered": isHovered || void 0,
      "data-pressed": isPressed || void 0,
      "data-focus-visible": isFocusVisible || void 0,
      "data-disabled": props.isDisabled || void 0
    }),
    withObservedValues$e(
      children,
      {
        hovered: isHovered,
        pressed: isPressed,
        focused: isFocused,
        focusVisible: isFocusVisible,
        disabled: !!rest.isDisabled
      },
      plasmicUpdateVariant
    )
  );
}
const BUTTON_COMPONENT_NAME = makeComponentName("button");
function registerButton(loader, overrides) {
  registerComponentHelper(
    loader,
    BaseButton,
    {
      name: BUTTON_COMPONENT_NAME,
      displayName: "Aria Button",
      importPath: "@plasmicpkgs/react-aria/skinny/registerButton",
      importName: "BaseButton",
      variants: variants$h,
      defaultStyles: {
        // Ensure consistent design across rendered elements (button, anchor tag).
        backgroundColor: "#EFEFEF",
        borderColor: "black",
        borderStyle: "solid",
        borderWidth: "1px",
        color: "#000000",
        cursor: "pointer",
        fontFamily: "Arial",
        fontSize: "1rem",
        lineHeight: "1.2",
        padding: "2px 10px",
        textDecorationLine: "none"
      },
      props: __spreadProps$m(__spreadValues$q({}, getCommonProps("button", [
        "autoFocus",
        "isDisabled",
        "aria-label"
      ])), {
        children: {
          type: "slot",
          mergeWithParent: true,
          defaultValue: {
            type: "text",
            value: "Button"
          }
        },
        href: {
          type: "href",
          description: "The URL this button navigates to. If present, this button is an <a> element."
        },
        target: {
          type: "choice",
          options: ["_blank", "_self", "_parent", "_top"],
          description: "Same as target attribute of <a> element. Only applies when the href prop is present.",
          hidden: (props) => !props.href,
          defaultValueHint: "_self"
        },
        submitsForm: {
          type: "boolean",
          displayName: "Submits form?",
          defaultValueHint: false,
          hidden: (props) => Boolean(props.resetsForm) || Boolean(props.href),
          description: "Whether clicking this button should submit the enclosing form.",
          advanced: true
        },
        resetsForm: {
          type: "boolean",
          displayName: "Resets form?",
          defaultValueHint: false,
          hidden: (props) => Boolean(props.submitsForm) || Boolean(props.href),
          description: "Whether clicking this button should reset the enclosing form.",
          advanced: true
        },
        onPress: {
          type: "eventHandler",
          argTypes: [{ name: "event", type: "object" }]
        },
        onFocus: {
          type: "eventHandler",
          argTypes: [{ name: "event", type: "object" }]
        }
      }),
      trapsFocus: true
    },
    overrides
  );
}

const PlasmicTextFieldContext = React__default.default.createContext(void 0);
const PlasmicCheckboxGroupContext = React__default.default.createContext(void 0);
const PlasmicRadioGroupContext = React__default.default.createContext(void 0);
const PlasmicDialogTriggerContext = React__default.default.createContext(void 0);
const PlasmicSliderContext = React__default.default.createContext(void 0);
React__default.default.createContext(void 0);
const PlasmicPopoverTriggerContext = React__default.default.createContext(void 0);
const PlasmicListBoxContext = React__default.default.createContext(void 0);
React__default.default.createContext(void 0);
const PlasmicInputContext = React__default.default.createContext(void 0);

var __defProp$p = Object.defineProperty;
var __defProps$l = Object.defineProperties;
var __getOwnPropDescs$l = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$p = Object.getOwnPropertySymbols;
var __hasOwnProp$p = Object.prototype.hasOwnProperty;
var __propIsEnum$p = Object.prototype.propertyIsEnumerable;
var __defNormalProp$p = (obj, key, value) => key in obj ? __defProp$p(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$p = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$p.call(b, prop))
      __defNormalProp$p(a, prop, b[prop]);
  if (__getOwnPropSymbols$p)
    for (var prop of __getOwnPropSymbols$p(b)) {
      if (__propIsEnum$p.call(b, prop))
        __defNormalProp$p(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$l = (a, b) => __defProps$l(a, __getOwnPropDescs$l(b));
var __objRest$l = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$p.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$p)
    for (var prop of __getOwnPropSymbols$p(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$p.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const CHECKBOX_VARIANTS = [
  "hovered",
  "pressed",
  "focused",
  "focusVisible",
  "indeterminate",
  "disabled",
  "selected",
  "readonly",
  "selected"
];
const { variants: variants$g, withObservedValues: withObservedValues$d } = pickAriaComponentVariants(CHECKBOX_VARIANTS);
function BaseCheckbox(props) {
  const _a = props, {
    children,
    plasmicUpdateVariant,
    setControlContextData,
    value
  } = _a, rest = __objRest$l(_a, [
    "children",
    "plasmicUpdateVariant",
    "setControlContextData",
    "value"
  ]);
  const contextProps = React__default.default.useContext(PlasmicCheckboxGroupContext);
  const isStandalone = !contextProps;
  const [registeredId, setRegisteredId] = React.useState();
  React.useEffect(() => {
    if (!(contextProps == null ? void 0 : contextProps.idManager)) {
      return;
    }
    const localId = contextProps.idManager.register(value);
    setRegisteredId(localId);
    return () => {
      contextProps.idManager.unregister(localId);
      setRegisteredId(void 0);
    };
  }, [value, contextProps == null ? void 0 : contextProps.idManager]);
  setControlContextData == null ? void 0 : setControlContextData({
    parent: contextProps,
    idError: (() => {
      if (value === void 0) {
        return "Value must be defined";
      }
      if (typeof value !== "string") {
        return "Value must be a string";
      }
      if (!value.trim()) {
        return "Value must be defined";
      }
      if (!isStandalone && value != registeredId) {
        return "Value must be unique";
      }
      return void 0;
    })()
  });
  return /* @__PURE__ */ React__default.default.createElement(React__default.default.Fragment, null, /* @__PURE__ */ React__default.default.createElement(
    reactAriaComponents.Checkbox,
    __spreadProps$l(__spreadValues$p({}, rest), {
      value: registeredId,
      key: registeredId,
      style: COMMON_STYLES
    }),
    ({
      isHovered,
      isPressed,
      isFocused,
      isFocusVisible,
      isDisabled,
      isIndeterminate,
      isSelected,
      isReadOnly
    }) => withObservedValues$d(
      children,
      {
        hovered: isHovered,
        pressed: isPressed,
        focused: isFocused,
        focusVisible: isFocusVisible,
        disabled: isDisabled,
        indeterminate: isIndeterminate,
        selected: isSelected,
        readonly: isReadOnly
      },
      plasmicUpdateVariant
    )
  ));
}
const makeDefaultCheckboxChildren = ({
  label,
  showDocs
}) => ({
  type: "vbox",
  styles: {
    display: "flex",
    alignItems: "center",
    gap: "2px",
    padding: 0
  },
  children: [
    {
      type: "hbox",
      styles: {
        display: "flex",
        alignItems: "center",
        gap: "10px",
        padding: 0
      },
      children: [
        {
          type: "box",
          styles: {
            width: "7px",
            height: "7px",
            borderRadius: "3px",
            borderWidth: "1px",
            borderStyle: "solid",
            borderColor: "black"
          }
        },
        {
          type: "text",
          value: label
        }
      ]
    },
    ...showDocs ? [
      {
        type: "text",
        value: "Use the registered variants to see it in action..."
      }
    ] : []
  ]
});
const CHECKBOX_COMPONENT_NAME = makeComponentName("checkbox");
function registerCheckbox(loader, overrides) {
  return registerComponentHelper(
    loader,
    BaseCheckbox,
    {
      name: CHECKBOX_COMPONENT_NAME,
      displayName: "Aria Checkbox",
      importPath: "@plasmicpkgs/react-aria/skinny/registerCheckbox",
      importName: "BaseCheckbox",
      variants: variants$g,
      props: __spreadProps$l(__spreadValues$p({}, getCommonProps("checkbox", [
        "name",
        "isDisabled",
        "isReadOnly",
        "aria-label",
        "isRequired",
        "autoFocus"
      ])), {
        children: {
          type: "slot",
          mergeWithParent: true,
          defaultValue: makeDefaultCheckboxChildren({
            label: "Label",
            showDocs: true
          })
        },
        value: {
          type: "string",
          description: 'The value of the checkbox in "selected" state, used when submitting an HTML form.',
          defaultValueHint: 'Checked value (default: "on")',
          validator: (_value, _props, ctx) => {
            if (ctx == null ? void 0 : ctx.idError) {
              return ctx.idError;
            }
            return true;
          }
        },
        isSelected: {
          type: "boolean",
          displayName: "Default Selected",
          editOnly: true,
          uncontrolledProp: "defaultSelected",
          description: "Whether the checkbox should be selected by default",
          defaultValueHint: false,
          defaultValue: false,
          hidden: hasParent
        },
        isIndeterminate: {
          displayName: "Indeterminate",
          type: "boolean",
          description: "This state indicates that the checkbox is neither fully checked nor unchecked. It typically represents a partial selection when dealing with groups of options. Some but not all items in the group are selected, resulting in an indeterminate state for the checkbox.",
          defaultValueHint: false
        },
        isInvalid: {
          displayName: "Invalid",
          type: "boolean",
          description: "Whether the input value is invalid",
          defaultValueHint: false
        },
        validationBehavior: {
          type: "choice",
          options: ["native", "aria"],
          description: "Whether to use native HTML form validation to prevent form submission when the value is missing or invalid, or mark the field as required or invalid via ARIA.",
          defaultValueHint: "native"
        },
        onChange: {
          type: "eventHandler",
          argTypes: [{ name: "isSelected", type: "boolean" }]
        }
      }),
      states: {
        isSelected: {
          type: "writable",
          valueProp: "isSelected",
          onChangeProp: "onChange",
          variableType: "boolean",
          hidden: hasParent
        }
      },
      trapsFocus: true
    },
    overrides
  );
}

class OptionsItemIdManager {
  constructor() {
    this._ids = /* @__PURE__ */ new Set();
    this._observers = /* @__PURE__ */ new Set();
  }
  generateDuplicateId(id, count = 1) {
    const dupId = `${id} duplicate(${count})`;
    if (this._ids.has(dupId)) {
      return this.generateDuplicateId(id, count + 1);
    } else {
      return dupId;
    }
  }
  generateMissingId(count = 1) {
    const missingId = `missing(${count})`;
    if (this._ids.has(missingId)) {
      return this.generateMissingId(count + 1);
    } else {
      return missingId;
    }
  }
  register(id) {
    const idStr = id === void 0 ? void 0 : String(id).trim();
    let newId;
    if (!idStr) {
      newId = this.generateMissingId();
    } else if (this._ids.has(idStr)) {
      newId = this.generateDuplicateId(idStr);
    } else {
      newId = idStr;
    }
    this._ids.add(newId);
    this.notify();
    return newId;
  }
  unregister(id) {
    this._ids.delete(id);
    this.notify();
  }
  subscribe(observer) {
    this._observers.add(observer);
    observer(this.ids);
  }
  // Notify all observers about an event.
  notify() {
    this._observers.forEach((observer) => observer(this.ids));
  }
  get ids() {
    return Array.from(this._ids);
  }
}

var __defProp$o = Object.defineProperty;
var __defProps$k = Object.defineProperties;
var __getOwnPropDescs$k = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$o = Object.getOwnPropertySymbols;
var __hasOwnProp$o = Object.prototype.hasOwnProperty;
var __propIsEnum$o = Object.prototype.propertyIsEnumerable;
var __defNormalProp$o = (obj, key, value) => key in obj ? __defProp$o(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$o = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$o.call(b, prop))
      __defNormalProp$o(a, prop, b[prop]);
  if (__getOwnPropSymbols$o)
    for (var prop of __getOwnPropSymbols$o(b)) {
      if (__propIsEnum$o.call(b, prop))
        __defNormalProp$o(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$k = (a, b) => __defProps$k(a, __getOwnPropDescs$k(b));
var __objRest$k = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$o.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$o)
    for (var prop of __getOwnPropSymbols$o(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$o.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function BaseText(_a) {
  var _b = _a, { children, slot, className } = _b, rest = __objRest$k(_b, ["children", "slot", "className"]);
  return /* @__PURE__ */ React__default.default.createElement(
    reactAriaComponents.Text,
    __spreadProps$k(__spreadValues$o({}, extractPlasmicDataProps(rest)), {
      slot,
      className,
      style: COMMON_STYLES
    }),
    children
  );
}
const TEXT_COMPONENT_NAME = makeComponentName("text");
function registerText(loader, overrides) {
  return registerComponentHelper(
    loader,
    BaseText,
    {
      name: TEXT_COMPONENT_NAME,
      displayName: "Aria Text",
      importPath: "@plasmicpkgs/react-aria/skinny/registerText",
      importName: "BaseText",
      props: {
        children: {
          type: "slot",
          mergeWithParent: true,
          defaultValue: {
            type: "text",
            value: "Some text..."
          }
        },
        slot: {
          type: "choice",
          options: ["label", "description"],
          defaultValueHint: "label",
          defaultValue: "label"
        }
      },
      trapsFocus: true
    },
    overrides
  );
}

var __defProp$n = Object.defineProperty;
var __defProps$j = Object.defineProperties;
var __getOwnPropDescs$j = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$n = Object.getOwnPropertySymbols;
var __hasOwnProp$n = Object.prototype.hasOwnProperty;
var __propIsEnum$n = Object.prototype.propertyIsEnumerable;
var __defNormalProp$n = (obj, key, value) => key in obj ? __defProp$n(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$n = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$n.call(b, prop))
      __defNormalProp$n(a, prop, b[prop]);
  if (__getOwnPropSymbols$n)
    for (var prop of __getOwnPropSymbols$n(b)) {
      if (__propIsEnum$n.call(b, prop))
        __defNormalProp$n(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$j = (a, b) => __defProps$j(a, __getOwnPropDescs$j(b));
const DESCRIPTION_COMPONENT_NAME = makeComponentName("description");
function registerDescription(loader, overrides) {
  return registerText(loader, __spreadProps$j(__spreadValues$n({}, overrides), {
    name: DESCRIPTION_COMPONENT_NAME,
    displayName: "Aria Description",
    props: {
      slot: {
        type: "string",
        hidden: () => true,
        defaultValue: "description"
      }
    }
  }));
}

var __defProp$m = Object.defineProperty;
var __defProps$i = Object.defineProperties;
var __getOwnPropDescs$i = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$m = Object.getOwnPropertySymbols;
var __hasOwnProp$m = Object.prototype.hasOwnProperty;
var __propIsEnum$m = Object.prototype.propertyIsEnumerable;
var __defNormalProp$m = (obj, key, value) => key in obj ? __defProp$m(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$m = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$m.call(b, prop))
      __defNormalProp$m(a, prop, b[prop]);
  if (__getOwnPropSymbols$m)
    for (var prop of __getOwnPropSymbols$m(b)) {
      if (__propIsEnum$m.call(b, prop))
        __defNormalProp$m(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$i = (a, b) => __defProps$i(a, __getOwnPropDescs$i(b));
var __objRest$j = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$m.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$m)
    for (var prop of __getOwnPropSymbols$m(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$m.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function BaseLabel(_a) {
  var _b = _a, { children, className } = _b, rest = __objRest$j(_b, ["children", "className"]);
  return /* @__PURE__ */ React__default.default.createElement(
    reactAriaComponents.Label,
    __spreadProps$i(__spreadValues$m({}, extractPlasmicDataProps(rest)), {
      className,
      style: COMMON_STYLES
    }),
    children
  );
}
const LABEL_COMPONENT_NAME = makeComponentName("label");
function registerLabel(loader, overrides) {
  registerComponentHelper(
    loader,
    BaseLabel,
    {
      name: LABEL_COMPONENT_NAME,
      displayName: "Aria Label",
      importPath: "@plasmicpkgs/react-aria/skinny/registerLabel",
      importName: "BaseLabel",
      defaultStyles: {
        cursor: "pointer"
      },
      props: {
        children: {
          type: "slot",
          mergeWithParent: true,
          defaultValue: {
            type: "text",
            value: "Label"
          }
        }
      },
      trapsFocus: true
    },
    overrides
  );
}

var __defProp$l = Object.defineProperty;
var __defProps$h = Object.defineProperties;
var __getOwnPropDescs$h = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$l = Object.getOwnPropertySymbols;
var __hasOwnProp$l = Object.prototype.hasOwnProperty;
var __propIsEnum$l = Object.prototype.propertyIsEnumerable;
var __defNormalProp$l = (obj, key, value) => key in obj ? __defProp$l(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$l = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$l.call(b, prop))
      __defNormalProp$l(a, prop, b[prop]);
  if (__getOwnPropSymbols$l)
    for (var prop of __getOwnPropSymbols$l(b)) {
      if (__propIsEnum$l.call(b, prop))
        __defNormalProp$l(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$h = (a, b) => __defProps$h(a, __getOwnPropDescs$h(b));
var __objRest$i = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$l.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$l)
    for (var prop of __getOwnPropSymbols$l(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$l.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const CHECKBOX_GROUP_VARIANTS = ["disabled", "readonly"];
const { variants: variants$f, withObservedValues: withObservedValues$c } = pickAriaComponentVariants(
  CHECKBOX_GROUP_VARIANTS
);
function BaseCheckboxGroup(props) {
  const _a = props, { children, plasmicUpdateVariant, setControlContextData } = _a, rest = __objRest$i(_a, ["children", "plasmicUpdateVariant", "setControlContextData"]);
  const [ids, setIds] = React.useState([]);
  const idManager = React.useMemo(() => new OptionsItemIdManager(), []);
  React.useEffect(() => {
    setControlContextData == null ? void 0 : setControlContextData({
      values: ids
    });
  }, [ids, setControlContextData]);
  React.useEffect(() => {
    idManager.subscribe((_ids) => {
      setIds(_ids);
    });
  }, [idManager]);
  return /* @__PURE__ */ React__default.default.createElement(PlasmicCheckboxGroupContext.Provider, { value: __spreadProps$h(__spreadValues$l({}, rest), { idManager }) }, /* @__PURE__ */ React__default.default.createElement(reactAriaComponents.CheckboxGroup, __spreadProps$h(__spreadValues$l({}, rest), { style: COMMON_STYLES }), ({ isDisabled, isReadOnly }) => withObservedValues$c(
    children,
    {
      disabled: isDisabled,
      readonly: isReadOnly
    },
    plasmicUpdateVariant
  )));
}
const componentName = makeComponentName("checkboxGroup");
function registerCheckboxGroup(loader, overrides) {
  registerComponentHelper(
    loader,
    BaseCheckboxGroup,
    {
      name: componentName,
      displayName: "Aria Checkbox Group",
      importPath: "@plasmicpkgs/react-aria/skinny/registerCheckboxGroup",
      importName: "BaseCheckboxGroup",
      variants: variants$f,
      props: __spreadProps$h(__spreadValues$l({}, getCommonProps("checkbox group", [
        "name",
        "isDisabled",
        "isReadOnly",
        "aria-label",
        "isRequired"
      ])), {
        children: {
          type: "slot",
          defaultValue: [
            {
              type: "vbox",
              styles: {
                display: "flex",
                gap: "5px",
                padding: 0,
                alignItems: "flex-start"
              },
              children: [
                {
                  type: "component",
                  name: LABEL_COMPONENT_NAME,
                  props: {
                    children: {
                      type: "text",
                      value: "Checkbox Group"
                    }
                  }
                },
                {
                  type: "component",
                  name: CHECKBOX_COMPONENT_NAME,
                  props: {
                    children: makeDefaultCheckboxChildren({
                      label: "Checkbox 1",
                      showDocs: false
                    }),
                    value: "checkbox1"
                  }
                },
                {
                  type: "component",
                  name: CHECKBOX_COMPONENT_NAME,
                  props: {
                    children: makeDefaultCheckboxChildren({
                      label: "Checkbox 2",
                      showDocs: false
                    }),
                    value: "checkbox2"
                  }
                },
                {
                  type: "component",
                  name: CHECKBOX_COMPONENT_NAME,
                  props: {
                    children: makeDefaultCheckboxChildren({
                      label: "Checkbox 3",
                      showDocs: false
                    }),
                    value: "checkbox3"
                  }
                },
                {
                  type: "component",
                  name: DESCRIPTION_COMPONENT_NAME,
                  props: {
                    children: {
                      type: "text",
                      value: "Use the registered variants to see it in action..."
                    }
                  }
                }
              ]
            }
          ]
        },
        value: {
          type: "choice",
          editOnly: true,
          uncontrolledProp: "defaultValue",
          description: "The current value",
          options: (_props, ctx) => (ctx == null ? void 0 : ctx.values) ? Array.from(ctx.values) : [],
          multiSelect: true
        },
        isInvalid: {
          displayName: "Invalid",
          type: "boolean",
          description: "Whether the input value is invalid",
          defaultValueHint: false
        },
        validationBehavior: {
          type: "choice",
          options: ["native", "aria"],
          description: "Whether to use native HTML form validation to prevent form submission when the value is missing or invalid, or mark the field as required or invalid via ARIA.",
          defaultValueHint: "native"
        },
        onChange: {
          type: "eventHandler",
          argTypes: [{ name: "value", type: "object" }]
        }
      }),
      states: {
        value: {
          type: "writable",
          valueProp: "value",
          onChangeProp: "onChange",
          variableType: "array"
        }
      },
      trapsFocus: true
    },
    overrides
  );
}

var __defProp$k = Object.defineProperty;
var __defProps$g = Object.defineProperties;
var __getOwnPropDescs$g = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$k = Object.getOwnPropertySymbols;
var __hasOwnProp$k = Object.prototype.hasOwnProperty;
var __propIsEnum$k = Object.prototype.propertyIsEnumerable;
var __defNormalProp$k = (obj, key, value) => key in obj ? __defProp$k(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$k = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$k.call(b, prop))
      __defNormalProp$k(a, prop, b[prop]);
  if (__getOwnPropSymbols$k)
    for (var prop of __getOwnPropSymbols$k(b)) {
      if (__propIsEnum$k.call(b, prop))
        __defNormalProp$k(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$g = (a, b) => __defProps$g(a, __getOwnPropDescs$g(b));
var __objRest$h = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$k.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$k)
    for (var prop of __getOwnPropSymbols$k(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$k.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const INPUT_VARIANTS = [
  "focused",
  "focusVisible",
  "hovered",
  "disabled"
];
const { variants: variants$e } = pickAriaComponentVariants(INPUT_VARIANTS);
const inputHelpers$1 = {
  states: {
    value: {
      onChangeArgsToValue: (e) => {
        return e.target.value;
      }
    }
  }
};
function BaseInput(props) {
  const _a = props, {
    plasmicUpdateVariant,
    setControlContextData,
    autoComplete,
    value,
    className
  } = _a, rest = __objRest$h(_a, [
    "plasmicUpdateVariant",
    "setControlContextData",
    "autoComplete",
    "value",
    "className"
  ]);
  const textFieldContext = React__default.default.useContext(PlasmicTextFieldContext);
  const context = React__default.default.useContext(PlasmicInputContext);
  setControlContextData == null ? void 0 : setControlContextData({
    parent: textFieldContext
  });
  const classNameProp = React.useCallback(
    ({
      isDisabled,
      isFocusVisible,
      isFocused,
      isHovered
    }) => {
      plasmicUpdateVariant == null ? void 0 : plasmicUpdateVariant({
        disabled: isDisabled,
        focused: isFocused,
        focusVisible: isFocusVisible,
        hovered: isHovered
      });
      return className != null ? className : "";
    },
    [className, plasmicUpdateVariant]
  );
  const mergedProps = reactAria.mergeProps(rest, {
    value: (context == null ? void 0 : context.isUncontrolled) ? void 0 : value,
    autoComplete: resolveAutoComplete(autoComplete),
    className: classNameProp
  });
  return /* @__PURE__ */ React__default.default.createElement(reactAriaComponents.Input, __spreadProps$g(__spreadValues$k({}, mergedProps), { style: COMMON_STYLES }));
}
const INPUT_COMPONENT_NAME = makeComponentName("input");
function registerInput(loader, overrides) {
  registerComponentHelper(
    loader,
    BaseInput,
    {
      name: INPUT_COMPONENT_NAME,
      displayName: "Aria Input",
      importPath: "@plasmicpkgs/react-aria/skinny/registerInput",
      importName: "BaseInput",
      variants: variants$e,
      defaultStyles: {
        width: "300px",
        borderWidth: "1px",
        borderStyle: "solid",
        borderColor: "black",
        padding: "4px 10px"
      },
      props: __spreadValues$k({}, getCommonProps("Input", [
        "name",
        "disabled",
        "readOnly",
        "autoFocus",
        "aria-label",
        "required",
        "placeholder",
        "value",
        "maxLength",
        "minLength",
        "pattern",
        "type",
        "inputMode",
        "autoComplete",
        "onChange",
        "onFocus",
        "onBlur",
        "onKeyDown",
        "onKeyUp",
        "onCopy",
        "onCut",
        "onPaste",
        "onCompositionStart",
        "onCompositionEnd",
        "onCompositionUpdate",
        "onSelect",
        "onBeforeInput",
        "onInput"
      ])),
      states: {
        value: __spreadValues$k({
          type: "writable",
          valueProp: "value",
          onChangeProp: "onChange",
          variableType: "text"
        }, inputHelpers$1.states.value)
      },
      componentHelpers: {
        helpers: inputHelpers$1,
        importName: "inputHelpers",
        importPath: "@plasmicpkgs/react-aria/skinny/registerInput"
      }
    },
    overrides
  );
}

var __defProp$j = Object.defineProperty;
var __defProps$f = Object.defineProperties;
var __getOwnPropDescs$f = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$j = Object.getOwnPropertySymbols;
var __hasOwnProp$j = Object.prototype.hasOwnProperty;
var __propIsEnum$j = Object.prototype.propertyIsEnumerable;
var __defNormalProp$j = (obj, key, value) => key in obj ? __defProp$j(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$j = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$j.call(b, prop))
      __defNormalProp$j(a, prop, b[prop]);
  if (__getOwnPropSymbols$j)
    for (var prop of __getOwnPropSymbols$j(b)) {
      if (__propIsEnum$j.call(b, prop))
        __defNormalProp$j(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$f = (a, b) => __defProps$f(a, __getOwnPropDescs$f(b));
var __objRest$g = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$j.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$j)
    for (var prop of __getOwnPropSymbols$j(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$j.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const LIST_BOX_ITEM_VARIANTS = [
  "hovered",
  "pressed",
  "focused",
  "focusVisible",
  "selected",
  "disabled"
];
const { variants: variants$d, withObservedValues: withObservedValues$b } = pickAriaComponentVariants(
  LIST_BOX_ITEM_VARIANTS
);
function BaseListBoxItem(props) {
  const _a = props, { children, setControlContextData, plasmicUpdateVariant, id } = _a, rest = __objRest$g(_a, ["children", "setControlContextData", "plasmicUpdateVariant", "id"]);
  const listboxContext = React__default.default.useContext(PlasmicListBoxContext);
  const isStandalone = !listboxContext;
  const [registeredId, setRegisteredId] = React.useState();
  React.useEffect(() => {
    if (!listboxContext) {
      return;
    }
    const localId = listboxContext.idManager.register(id);
    setRegisteredId(localId);
    return () => {
      listboxContext.idManager.unregister(localId);
      setRegisteredId(void 0);
    };
  }, [id]);
  setControlContextData == null ? void 0 : setControlContextData({
    idError: (() => {
      if (id === void 0) {
        return "ID must be defined";
      }
      if (typeof id !== "string") {
        return "ID must be a string";
      }
      if (!id.trim()) {
        return "ID must be defined";
      }
      if (!isStandalone && id != registeredId) {
        return "ID must be unique";
      }
      return void 0;
    })()
  });
  const listboxItem = /* @__PURE__ */ React__default.default.createElement(
    reactAriaComponents.ListBoxItem,
    __spreadProps$f(__spreadValues$j({
      key: registeredId,
      id: registeredId
    }, rest), {
      style: COMMON_STYLES
    }),
    ({
      isHovered,
      isPressed,
      isFocused,
      isFocusVisible,
      isSelected,
      isDisabled
    }) => withObservedValues$b(
      children,
      {
        hovered: isHovered,
        pressed: isPressed,
        focused: isFocused,
        focusVisible: isFocusVisible,
        selected: isSelected,
        disabled: isDisabled
      },
      plasmicUpdateVariant
    )
  );
  if (isStandalone) {
    return /* @__PURE__ */ React__default.default.createElement(reactAriaComponents.ListBox, { selectionMode: "single" }, listboxItem);
  }
  return listboxItem;
}
const makeDefaultListBoxItemChildren = (label, description) => ({
  type: "vbox",
  styles: {
    display: "flex",
    alignItems: "flex-start",
    gap: "2px"
  },
  children: [
    {
      type: "component",
      name: TEXT_COMPONENT_NAME,
      props: {
        slot: "label",
        children: {
          type: "text",
          styles: {
            fontWeight: 500
          },
          value: label
        }
      }
    },
    {
      type: "component",
      name: DESCRIPTION_COMPONENT_NAME,
      props: {
        children: {
          type: "text",
          styles: {
            color: "#838383"
          },
          value: description != null ? description : `Some description for ${label}...`
        }
      }
    }
  ]
});
function registerListBoxItem(loader, overrides) {
  return registerComponentHelper(
    loader,
    BaseListBoxItem,
    {
      name: makeComponentName("item"),
      displayName: "Aria ListBoxItem",
      importPath: "@plasmicpkgs/react-aria/skinny/registerListBoxItem",
      importName: "BaseListBoxItem",
      variants: variants$d,
      props: {
        id: {
          type: "string",
          description: "A unique value for tracking the selected item in state",
          required: true,
          displayName: "Value",
          validator: (_value, _props, ctx) => {
            if (ctx == null ? void 0 : ctx.idError) {
              return ctx.idError;
            }
            return true;
          }
        },
        textValue: {
          type: "string",
          displayName: "Label",
          description: "A user-friendly text representation of the item's contents, used for features like typeahead."
        },
        children: {
          type: "slot",
          mergeWithParent: true,
          defaultValue: makeDefaultListBoxItemChildren("Item")
        }
      },
      trapsFocus: true
    },
    overrides
  );
}

var __defProp$i = Object.defineProperty;
var __defProps$e = Object.defineProperties;
var __getOwnPropDescs$e = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$i = Object.getOwnPropertySymbols;
var __hasOwnProp$i = Object.prototype.hasOwnProperty;
var __propIsEnum$i = Object.prototype.propertyIsEnumerable;
var __defNormalProp$i = (obj, key, value) => key in obj ? __defProp$i(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$i = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$i.call(b, prop))
      __defNormalProp$i(a, prop, b[prop]);
  if (__getOwnPropSymbols$i)
    for (var prop of __getOwnPropSymbols$i(b)) {
      if (__propIsEnum$i.call(b, prop))
        __defNormalProp$i(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$e = (a, b) => __defProps$e(a, __getOwnPropDescs$e(b));
var __objRest$f = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$i.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$i)
    for (var prop of __getOwnPropSymbols$i(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$i.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function BaseSection(props) {
  const _a = props, { header, items } = _a, rest = __objRest$f(_a, ["header", "items"]);
  const contextProps = React__default.default.useContext(PlasmicListBoxContext);
  const isStandalone = !contextProps;
  const section = /* @__PURE__ */ React__default.default.createElement(reactAriaComponents.Section, __spreadProps$e(__spreadValues$i({}, rest), { style: COMMON_STYLES }), /* @__PURE__ */ React__default.default.createElement(reactAriaComponents.Header, null, header), items);
  if (isStandalone) {
    return (
      // BaseListbox should give section a listbox context (that it can't be used without)
      // as well as the id manager (that is needed to identify and warn about duplication of ids)
      // selection mode needs to be single/multiple to be able to trigger hover state on it.
      /* @__PURE__ */ React__default.default.createElement(BaseListBox, { selectionMode: "single" }, section)
    );
  }
  return section;
}
function registerSection(loader, overrides) {
  return registerComponentHelper(
    loader,
    BaseSection,
    {
      name: makeComponentName("section"),
      displayName: "Aria Section",
      importPath: "@plasmicpkgs/react-aria/skinny/registerSection",
      importName: "BaseSection",
      defaultStyles: {
        width: "stretch",
        padding: "10px"
      },
      props: {
        header: {
          type: "slot",
          mergeWithParent: true,
          defaultValue: [
            {
              type: "text",
              value: "Section Header."
            }
          ]
        },
        items: {
          type: "slot",
          mergeWithParent: true
        }
      },
      trapsFocus: true
    },
    overrides
  );
}

var __defProp$h = Object.defineProperty;
var __getOwnPropSymbols$h = Object.getOwnPropertySymbols;
var __hasOwnProp$h = Object.prototype.hasOwnProperty;
var __propIsEnum$h = Object.prototype.propertyIsEnumerable;
var __defNormalProp$h = (obj, key, value) => key in obj ? __defProp$h(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$h = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$h.call(b, prop))
      __defNormalProp$h(a, prop, b[prop]);
  if (__getOwnPropSymbols$h)
    for (var prop of __getOwnPropSymbols$h(b)) {
      if (__propIsEnum$h.call(b, prop))
        __defNormalProp$h(a, prop, b[prop]);
    }
  return a;
};
var __objRest$e = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$h.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$h)
    for (var prop of __getOwnPropSymbols$h(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$h.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const LISTBOX_VARIANTS = ["focused", "focusVisible"];
const { variants: variants$c } = pickAriaComponentVariants(LISTBOX_VARIANTS);
const listboxHelpers = {
  states: {
    selectedValue: {
      onChangeArgsToValue: (value) => {
        return Array.from(value)[0];
      }
    }
  }
};
function normalizeSelectedKeys(selectedKeys) {
  return typeof selectedKeys === "string" && selectedKeys !== "all" ? [selectedKeys] : selectedKeys;
}
function BaseListBox(props) {
  const _a = props, {
    setControlContextData,
    children,
    className,
    selectedKeys,
    defaultSelectedKeys,
    plasmicUpdateVariant
  } = _a, rest = __objRest$e(_a, [
    "setControlContextData",
    "children",
    "className",
    "selectedKeys",
    "defaultSelectedKeys",
    "plasmicUpdateVariant"
  ]);
  const context = React__default.default.useContext(PlasmicListBoxContext);
  const isStandalone = !context;
  const [ids, setIds] = React.useState([]);
  const idManager = React.useMemo(
    () => {
      var _a2;
      return (_a2 = context == null ? void 0 : context.idManager) != null ? _a2 : new OptionsItemIdManager();
    },
    []
  );
  React.useEffect(() => {
    setControlContextData == null ? void 0 : setControlContextData({
      itemIds: ids,
      isStandalone
    });
  }, [ids, isStandalone, setControlContextData]);
  React.useEffect(() => {
    idManager.subscribe((_ids) => {
      setIds(_ids);
    });
  }, []);
  const classNameProp = React.useCallback(
    ({ isFocusVisible, isFocused }) => {
      plasmicUpdateVariant == null ? void 0 : plasmicUpdateVariant({
        focused: isFocused,
        focusVisible: isFocusVisible
      });
      return className != null ? className : "";
    },
    [className, plasmicUpdateVariant]
  );
  const listbox = /* @__PURE__ */ React__default.default.createElement(
    reactAriaComponents.ListBox,
    __spreadValues$h({
      selectedKeys: normalizeSelectedKeys(selectedKeys),
      defaultSelectedKeys: normalizeSelectedKeys(defaultSelectedKeys),
      className: classNameProp,
      style: COMMON_STYLES
    }, rest),
    children
  );
  if (isStandalone) {
    return /* @__PURE__ */ React__default.default.createElement(
      PlasmicListBoxContext.Provider,
      {
        value: {
          idManager
        }
      },
      listbox
    );
  }
  return listbox;
}
const LIST_BOX_COMPONENT_NAME = makeComponentName("listbox");
function registerListBox(loader, overrides) {
  const listBoxItemMeta = registerListBoxItem(loader, {
    parentComponentName: LIST_BOX_COMPONENT_NAME
  });
  const sectionMeta = registerSection(loader, {
    parentComponentName: LIST_BOX_COMPONENT_NAME,
    props: {
      items: {
        type: "slot",
        defaultValue: [
          {
            type: "component",
            name: listBoxItemMeta.name,
            props: {
              id: "section-1-1",
              textValue: "Section1-Item 1",
              children: [
                makeDefaultListBoxItemChildren(
                  "Item 1",
                  "Add dynamic values to make it more interesting"
                )
              ]
            }
          },
          {
            type: "component",
            name: listBoxItemMeta.name,
            props: {
              id: "section-1-2",
              textValue: "Section1-Item 2",
              children: [
                makeDefaultListBoxItemChildren(
                  "Item 2",
                  "Add dynamic values to make it more interesting"
                )
              ]
            }
          },
          {
            type: "component",
            name: listBoxItemMeta.name,
            props: {
              id: "section-1-3",
              textValue: "Section1-Item 3",
              children: [
                makeDefaultListBoxItemChildren(
                  "Item 3",
                  "Add dynamic values to make it more interesting"
                )
              ]
            }
          }
        ]
      }
    }
  });
  registerComponentHelper(
    loader,
    BaseListBox,
    {
      name: LIST_BOX_COMPONENT_NAME,
      displayName: "Aria ListBox",
      importPath: "@plasmicpkgs/react-aria/skinny/registerListBox",
      importName: "BaseListBox",
      variants: variants$c,
      defaultStyles: {
        width: "250px",
        borderWidth: "1px",
        borderStyle: "solid",
        borderColor: "black"
      },
      props: {
        children: {
          type: "slot",
          displayName: "List Items",
          allowedComponents: [listBoxItemMeta.name, sectionMeta.name],
          allowRootWrapper: true,
          defaultValue: [
            {
              type: "component",
              name: listBoxItemMeta.name,
              props: {
                id: "1",
                textValue: "Item 1",
                children: [
                  makeDefaultListBoxItemChildren(
                    "Item 1",
                    "Add dynamic values to make it more interesting"
                  )
                ]
              }
            },
            {
              type: "component",
              name: listBoxItemMeta.name,
              props: {
                id: "2",
                textValue: "Item 2",
                children: [
                  makeDefaultListBoxItemChildren(
                    "Item 2",
                    "Add dynamic values to make it more interesting"
                  )
                ]
              }
            },
            {
              type: "component",
              name: listBoxItemMeta.name,
              props: {
                id: "3",
                textValue: "Item 3",
                children: [
                  makeDefaultListBoxItemChildren(
                    "Item 3",
                    "Add dynamic values to make it more interesting"
                  )
                ]
              }
            },
            {
              type: "component",
              name: sectionMeta.name
            }
          ]
        },
        selectionMode: {
          type: "choice",
          description: "The selection mode of the listbox",
          options: ["none", "single"],
          defaultValue: "none",
          hidden: (_props, ctx) => !(ctx == null ? void 0 : ctx.isStandalone)
        },
        selectedKeys: {
          type: "choice",
          editOnly: true,
          uncontrolledProp: "defaultSelectedKeys",
          displayName: "Initial selected item",
          options: (_props, ctx) => (ctx == null ? void 0 : ctx.itemIds) ? Array.from(ctx.itemIds) : [],
          hidden: (props, ctx) => !(ctx == null ? void 0 : ctx.isStandalone) || props.selectionMode === "none",
          // We do not support multiple selections yet (Because React Aria select and combobox only support single selections).
          multiSelect: false
        },
        onSelectionChange: {
          type: "eventHandler",
          argTypes: [{ name: "selectedValues", type: "object" }]
        }
      },
      states: {
        selectedValue: __spreadValues$h({
          type: "writable",
          valueProp: "selectedKeys",
          hidden: (props, ctx) => !(ctx == null ? void 0 : ctx.isStandalone) || props.selectionMode === "none",
          onChangeProp: "onSelectionChange",
          variableType: "text"
        }, listboxHelpers.states.selectedValue)
      },
      componentHelpers: {
        helpers: listboxHelpers,
        importName: "listboxHelpers",
        importPath: "@plasmicpkgs/react-aria/skinny/registerListBox"
      },
      trapsFocus: true
    },
    overrides
  );
}

var __defProp$g = Object.defineProperty;
var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
var __hasOwnProp$g = Object.prototype.hasOwnProperty;
var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
var __defNormalProp$g = (obj, key, value) => key in obj ? __defProp$g(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$g = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$g.call(b, prop))
      __defNormalProp$g(a, prop, b[prop]);
  if (__getOwnPropSymbols$g)
    for (var prop of __getOwnPropSymbols$g(b)) {
      if (__propIsEnum$g.call(b, prop))
        __defNormalProp$g(a, prop, b[prop]);
    }
  return a;
};
var __objRest$d = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$g.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$g)
    for (var prop of __getOwnPropSymbols$g(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$g.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const POPOVER_VARIANTS = [
  "placementTop",
  "placementBottom",
  "placementLeft",
  "placementRight"
];
const { variants: variants$b, withObservedValues: withObservedValues$a } = pickAriaComponentVariants(POPOVER_VARIANTS);
function BasePopover(props) {
  const _a = props, {
    resetClassName,
    plasmicUpdateVariant,
    setControlContextData,
    matchTriggerWidth
  } = _a, restProps = __objRest$d(_a, [
    "resetClassName",
    "plasmicUpdateVariant",
    "setControlContextData",
    "matchTriggerWidth"
  ]);
  const isStandalone = !React__default.default.useContext(reactAriaComponents.PopoverContext);
  const hasTrigger = !!React__default.default.useContext(PlasmicPopoverTriggerContext);
  const triggerRef = React__default.default.useRef(null);
  const canvasContext = host.usePlasmicCanvasContext();
  const matchTriggerWidthProp = hasTrigger && matchTriggerWidth;
  const _b = utils.mergeProps(
    {
      // isNonModal: Whether the popover is non-modal, i.e. elements outside the popover may be interacted with by assistive technologies.
      // Setting isNonModal to true in edit mode (canvas) means that the popover will not prevent the user from interacting with the canvas while the popover is open.
      isNonModal: canvasContext && !canvasContext.interactive
    },
    restProps,
    { className: `${resetClassName}` },
    // Override some props if the popover is standalone
    isStandalone ? {
      triggerRef,
      isNonModal: true,
      // Always true, because we assume that popover is always going to be controlled by a parent like Select, Combobox, DialogTrigger, etc, and its only really standalone in component view
      // In component view, we never want to start with an empty artboard, so isOpen has to be true
      isOpen: true
    } : null
  ), { children } = _b, mergedProps = __objRest$d(_b, ["children"]);
  React.useEffect(() => {
    setControlContextData == null ? void 0 : setControlContextData({
      canMatchTriggerWidth: hasTrigger
    });
  }, [hasTrigger, setControlContextData]);
  return /* @__PURE__ */ React__default.default.createElement(React__default.default.Fragment, null, isStandalone && /* @__PURE__ */ React__default.default.createElement("div", { ref: triggerRef }), /* @__PURE__ */ React__default.default.createElement(
    reactAriaComponents.Popover,
    __spreadValues$g({
      style: __spreadValues$g(__spreadValues$g({}, matchTriggerWidthProp ? { width: `var(--trigger-width)` } : {}), COMMON_STYLES)
    }, mergedProps),
    ({ placement }) => withObservedValues$a(
      children,
      {
        placementTop: placement === "top",
        placementBottom: placement === "bottom",
        placementLeft: placement === "left",
        placementRight: placement === "right"
      },
      plasmicUpdateVariant
    )
  ));
}
const POPOVER_COMPONENT_NAME = makeComponentName("popover");
function registerPopover(loader, overrides) {
  registerComponentHelper(
    loader,
    BasePopover,
    {
      name: POPOVER_COMPONENT_NAME,
      displayName: "Aria Popover",
      importPath: "@plasmicpkgs/react-aria/skinny/registerPopover",
      importName: "BasePopover",
      variants: variants$b,
      defaultStyles: {
        borderWidth: "1px",
        borderStyle: "solid",
        borderColor: "black",
        width: "300px",
        backgroundColor: "#FDE3C3"
      },
      props: __spreadValues$g({
        children: {
          type: "slot",
          mergeWithParent: true,
          defaultValue: [
            {
              type: "vbox",
              styles: {
                width: "stretch",
                padding: "20px",
                rowGap: "10px"
              },
              children: [
                {
                  type: "text",
                  value: "This is a Popover!"
                },
                {
                  type: "text",
                  value: "You can put anything you can imagine here!",
                  styles: {
                    fontWeight: 500
                  }
                },
                {
                  type: "text",
                  value: "Use it in a `Aria Dialog Trigger` component to trigger it on a button click!"
                }
              ]
            }
          ]
        },
        shouldFlip: {
          type: "boolean",
          description: "Whether the element should flip its orientation (e.g. top to bottom or left to right) when there is insufficient room for it to render completely.",
          defaultValueHint: true
        },
        resetClassName: {
          type: "themeResetClass"
        },
        matchTriggerWidth: {
          type: "boolean",
          defaultValue: true,
          hidden: (_props, ctx) => !(ctx == null ? void 0 : ctx.canMatchTriggerWidth)
        }
      }, getCommonOverlayProps("popover", {
        placement: { defaultValueHint: "bottom" },
        offset: { defaultValueHint: 8 },
        containerPadding: { defaultValueHint: 12 },
        crossOffset: { defaultValueHint: 0 }
      })),
      // No isOpen state for popover, because we assume that its open state is always going to be controlled by a parent like Select, Combobox, DialogTrigger, etc.
      styleSections: true,
      trapsFocus: true
    },
    overrides
  );
}

var __defProp$f = Object.defineProperty;
var __defProps$d = Object.defineProperties;
var __getOwnPropDescs$d = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$f = Object.getOwnPropertySymbols;
var __hasOwnProp$f = Object.prototype.hasOwnProperty;
var __propIsEnum$f = Object.prototype.propertyIsEnumerable;
var __defNormalProp$f = (obj, key, value) => key in obj ? __defProp$f(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$f = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$f.call(b, prop))
      __defNormalProp$f(a, prop, b[prop]);
  if (__getOwnPropSymbols$f)
    for (var prop of __getOwnPropSymbols$f(b)) {
      if (__propIsEnum$f.call(b, prop))
        __defNormalProp$f(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$d = (a, b) => __defProps$d(a, __getOwnPropDescs$d(b));
var __objRest$c = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$f.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$f)
    for (var prop of __getOwnPropSymbols$f(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$f.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const COMBOBOX_NAME = makeComponentName("combobox");
const COMBOBOX_VARIANTS = ["disabled"];
const { variants: COMBOBOX_VARIANTS_DATA } = pickAriaComponentVariants(COMBOBOX_VARIANTS);
function ComboboxAutoOpen(props) {
  var _a;
  const { open, close } = (_a = React__default.default.useContext(reactAriaComponents.ComboBoxStateContext)) != null ? _a : {};
  useAutoOpen({ props, open, close });
  return null;
}
function BaseComboBox(props) {
  const _a = props, {
    children,
    setControlContextData,
    plasmicUpdateVariant,
    className,
    isOpen: _isOpen
  } = _a, rest = __objRest$c(_a, [
    "children",
    "setControlContextData",
    "plasmicUpdateVariant",
    "className",
    "isOpen"
  ]);
  const classNameProp = React.useCallback(
    ({ isDisabled }) => {
      plasmicUpdateVariant == null ? void 0 : plasmicUpdateVariant({
        disabled: isDisabled
      });
      return className != null ? className : "";
    },
    [className, plasmicUpdateVariant]
  );
  const idManager = React.useMemo(() => new OptionsItemIdManager(), []);
  React.useEffect(() => {
    idManager.subscribe((ids) => {
      setControlContextData == null ? void 0 : setControlContextData({
        itemIds: ids
      });
    });
  }, []);
  return /* @__PURE__ */ React__default.default.createElement(reactAriaComponents.ComboBox, __spreadProps$d(__spreadValues$f({ className: classNameProp }, rest), { style: COMMON_STYLES }), /* @__PURE__ */ React__default.default.createElement(PlasmicPopoverTriggerContext.Provider, { value: true }, /* @__PURE__ */ React__default.default.createElement(
    PlasmicListBoxContext.Provider,
    {
      value: {
        idManager
      }
    },
    /* @__PURE__ */ React__default.default.createElement(PlasmicInputContext.Provider, { value: { isUncontrolled: true } }, /* @__PURE__ */ React__default.default.createElement(ComboboxAutoOpen, __spreadValues$f({}, props)), children)
  )));
}
function registerComboBox(loader) {
  registerComponentHelper(loader, BaseComboBox, {
    name: COMBOBOX_NAME,
    displayName: "Aria ComboBox",
    importPath: "@plasmicpkgs/react-aria/skinny/registerComboBox",
    importName: "BaseComboBox",
    variants: COMBOBOX_VARIANTS_DATA,
    props: __spreadProps$d(__spreadValues$f({}, getCommonProps("ComboBox", [
      "name",
      "aria-label",
      "isDisabled"
    ])), {
      selectedKey: {
        type: "choice",
        editOnly: true,
        uncontrolledProp: "defaultSelectedKey",
        displayName: "Initial selected item",
        options: (_props, ctx) => (ctx == null ? void 0 : ctx.itemIds) ? Array.from(ctx.itemIds) : [],
        // React Aria ComboBox do not support multiple selections yet
        multiSelect: false
      },
      disabledKeys: {
        type: "choice",
        displayName: "Disabled values",
        description: "The items that are disabled. These items cannot be selected, focused, or otherwise interacted with.",
        options: (_props, ctx) => (ctx == null ? void 0 : ctx.itemIds) ? Array.from(ctx.itemIds) : [],
        multiSelect: true,
        advanced: true
      },
      isOpen: {
        type: "boolean",
        defaultValue: false,
        // It doesn't make sense to make isOpen prop editable (it's controlled by user interaction and always closed by default), so we keep this prop hidden. We have listed the prop here in the meta only so we can expose a writeable state for it.
        hidden: () => true
      },
      onSelectionChange: {
        type: "eventHandler",
        argTypes: [{ name: "selectedValue", type: "string" }]
      },
      onOpenChange: {
        type: "eventHandler",
        argTypes: [{ name: "isOpen", type: "boolean" }]
      },
      children: {
        type: "slot",
        defaultValue: [
          {
            type: "vbox",
            styles: {
              justifyContent: "flex-start",
              alignItems: "flex-start",
              width: "300px",
              padding: 0
            },
            children: [
              {
                type: "component",
                name: LABEL_COMPONENT_NAME,
                props: {
                  children: {
                    type: "text",
                    value: "Label"
                  }
                }
              },
              {
                type: "hbox",
                styles: {
                  padding: 0
                },
                children: [
                  {
                    type: "component",
                    name: INPUT_COMPONENT_NAME,
                    styles: {
                      width: "100%",
                      borderRightWidth: 0
                    }
                  },
                  {
                    type: "component",
                    name: BUTTON_COMPONENT_NAME,
                    props: {
                      children: arrowDown
                    }
                  }
                ]
              },
              {
                type: "component",
                name: POPOVER_COMPONENT_NAME,
                styles: {
                  backgroundColor: "white",
                  padding: "10px",
                  overflow: "scroll",
                  width: "unset"
                },
                props: {
                  offset: 0,
                  children: [
                    {
                      type: "component",
                      name: LIST_BOX_COMPONENT_NAME,
                      props: {
                        selectionMode: "single"
                      },
                      styles: {
                        borderWidth: 0,
                        width: "stretch"
                      }
                    }
                  ]
                }
              }
            ]
          }
        ]
      }
    }),
    states: {
      selectedValue: {
        type: "writable",
        valueProp: "selectedKey",
        onChangeProp: "onSelectionChange",
        variableType: "text"
      },
      isOpen: {
        type: "writable",
        valueProp: "isOpen",
        onChangeProp: "onOpenChange",
        variableType: "boolean"
      }
    },
    trapsFocus: true
  });
}

function BaseDialog({ children, className }) {
  const canvasContext = host.usePlasmicCanvasContext();
  if (canvasContext) {
    return /* @__PURE__ */ React__default.default.createElement("div", { className, style: COMMON_STYLES }, children);
  } else {
    return /* @__PURE__ */ React__default.default.createElement(reactAriaComponents.Dialog, { className, style: COMMON_STYLES }, children);
  }
}
const DIALOG_COMPONENT_NAME = makeComponentName("dialog");
function registerDialog(loader, overrides) {
  registerComponentHelper(
    loader,
    BaseDialog,
    {
      name: DIALOG_COMPONENT_NAME,
      displayName: "Aria Dialog",
      importPath: "@plasmicpkgs/react-aria/skinny/registerDialog",
      importName: "BaseDialog",
      props: {
        children: {
          type: "slot",
          mergeWithParent: true
        }
      },
      trapsFocus: true
    },
    overrides
  );
}

var __defProp$e = Object.defineProperty;
var __defProps$c = Object.defineProperties;
var __getOwnPropDescs$c = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$e = Object.getOwnPropertySymbols;
var __hasOwnProp$e = Object.prototype.hasOwnProperty;
var __propIsEnum$e = Object.prototype.propertyIsEnumerable;
var __defNormalProp$e = (obj, key, value) => key in obj ? __defProp$e(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$e = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$e.call(b, prop))
      __defNormalProp$e(a, prop, b[prop]);
  if (__getOwnPropSymbols$e)
    for (var prop of __getOwnPropSymbols$e(b)) {
      if (__propIsEnum$e.call(b, prop))
        __defNormalProp$e(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$c = (a, b) => __defProps$c(a, __getOwnPropDescs$c(b));
var __objRest$b = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$e.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$e)
    for (var prop of __getOwnPropSymbols$e(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$e.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const BaseModal = React.forwardRef(
  function BaseModalInner(props, ref) {
    var _b, _c, _d;
    const _a = props, {
      children,
      modalOverlayClass,
      className,
      isOpen,
      resetClassName,
      setControlContextData,
      isDismissable
    } = _a, rest = __objRest$b(_a, [
      "children",
      "modalOverlayClass",
      "className",
      "isOpen",
      "resetClassName",
      "setControlContextData",
      "isDismissable"
    ]);
    const canvasCtx = host.usePlasmicCanvasContext();
    const isEditMode = canvasCtx && canvasCtx.interactive === false;
    const isSelected = (_d = (_c = (_b = host.usePlasmicCanvasComponentInfo) == null ? void 0 : _b(props)) == null ? void 0 : _c.isSelected) != null ? _d : false;
    const contextProps = React__default.default.useContext(PlasmicDialogTriggerContext);
    const isStandalone = !contextProps;
    const mergedProps = reactAria.mergeProps(contextProps, rest, {
      isOpen: isStandalone ? isSelected || isOpen : contextProps.isOpen,
      /*
              isDismissable on canvas (non-interactive mode) causes the following two issues:
              1. Clicking anywhere inside the modal dismisses it
              2. If the modal is auto-opened due to selection in outline tab, the modal stays open despite issue #1, but the text elements inside the modal are no longer selectable, and therefore the text or headings inside the modal are not editable.
      
              To fix the above issue, we set an interim isDismissable state to false in edit mode, because it only matters in interactive mode.
            */
      isDismissable: isEditMode ? false : isDismissable
    });
    setControlContextData == null ? void 0 : setControlContextData({
      parent: isStandalone ? void 0 : {}
    });
    React.useImperativeHandle(ref, () => ({
      close: () => {
        var _a2;
        (_a2 = mergedProps.onOpenChange) == null ? void 0 : _a2.call(mergedProps, false);
      },
      open: () => {
        var _a2;
        (_a2 = mergedProps.onOpenChange) == null ? void 0 : _a2.call(mergedProps, true);
      }
    }));
    return /* @__PURE__ */ React__default.default.createElement(
      reactAriaComponents.ModalOverlay,
      __spreadProps$c(__spreadValues$e({}, mergedProps), {
        className: `${resetClassName} ${modalOverlayClass}`
      }),
      /* @__PURE__ */ React__default.default.createElement(reactAriaComponents.Modal, { className }, children)
    );
  }
);
const MODAL_COMPONENT_NAME = makeComponentName("modal");
const MODAL_DEFAULT_SLOT_CONTENT = {
  type: "vbox",
  styles: {
    width: "stretch",
    padding: 0,
    gap: "10px",
    justifyContent: "flex-start",
    alignItems: "flex-start"
  },
  children: [
    {
      type: "text",
      value: "Heading",
      tag: "h2"
    },
    {
      type: "text",
      value: "This is a Modal!"
    },
    {
      type: "text",
      value: "You can put anything you can imagine here!",
      styles: {
        fontWeight: 500
      }
    },
    {
      type: "text",
      value: "Use it in a `Aria Dialog Trigger` component to trigger it on a button click!"
    }
  ]
};
function registerModal(loader, overrides) {
  registerComponentHelper(
    loader,
    BaseModal,
    {
      name: MODAL_COMPONENT_NAME,
      displayName: "Aria Modal",
      importPath: "@plasmicpkgs/react-aria/skinny/registerModal",
      importName: "BaseModal",
      styleSections: true,
      defaultStyles: {
        // centering the modal on the page by default
        position: "fixed",
        top: "10%",
        left: "50%",
        width: "50%",
        transform: "translateX(-50%)",
        borderWidth: "1px",
        borderStyle: "solid",
        borderColor: "black",
        padding: "20px",
        maxWidth: "300px",
        backgroundColor: "#FDE3C3"
      },
      refActions: {
        open: {
          description: "Open the modal",
          argTypes: []
        },
        close: {
          description: "Close the modal",
          argTypes: []
        }
      },
      props: {
        children: {
          type: "slot",
          mergeWithParent: true,
          defaultValue: MODAL_DEFAULT_SLOT_CONTENT
        },
        modalOverlayClass: {
          type: "class",
          displayName: "Modal Overlay"
        },
        isOpen: {
          type: "boolean",
          editOnly: true,
          uncontrolledProp: "defaultOpen",
          defaultValueHint: true,
          defaultValue: true,
          hidden: hasParent
        },
        isDismissable: {
          type: "boolean",
          description: "Whether to close the modal when the user interacts outside it."
        },
        isKeyboardDismissDisabled: {
          type: "boolean",
          description: "Whether pressing the escape key to close the modal should be disabled."
        },
        onOpenChange: {
          type: "eventHandler",
          argTypes: [{ name: "isOpen", type: "boolean" }]
        },
        resetClassName: {
          type: "themeResetClass"
        }
      },
      states: {
        isOpen: {
          type: "writable",
          valueProp: "isOpen",
          onChangeProp: "onOpenChange",
          variableType: "boolean",
          hidden: hasParent
        }
      },
      trapsFocus: true
    },
    overrides
  );
}

var __defProp$d = Object.defineProperty;
var __defProps$b = Object.defineProperties;
var __getOwnPropDescs$b = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$d = Object.getOwnPropertySymbols;
var __hasOwnProp$d = Object.prototype.hasOwnProperty;
var __propIsEnum$d = Object.prototype.propertyIsEnumerable;
var __defNormalProp$d = (obj, key, value) => key in obj ? __defProp$d(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$d = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$d.call(b, prop))
      __defNormalProp$d(a, prop, b[prop]);
  if (__getOwnPropSymbols$d)
    for (var prop of __getOwnPropSymbols$d(b)) {
      if (__propIsEnum$d.call(b, prop))
        __defNormalProp$d(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$b = (a, b) => __defProps$b(a, __getOwnPropDescs$b(b));
var __objRest$a = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$d.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$d)
    for (var prop of __getOwnPropSymbols$d(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$d.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function BaseDialogTrigger(props) {
  var _b, _c, _d;
  const _a = props, { trigger, dialog, isOpen } = _a, rest = __objRest$a(_a, ["trigger", "dialog", "isOpen"]);
  const { isSelected, selectedSlotName } = (_c = (_b = host.usePlasmicCanvasComponentInfo) == null ? void 0 : _b(props)) != null ? _c : {};
  const isAutoOpen = selectedSlotName !== "trigger" && isSelected;
  const mergedProps = __spreadProps$b(__spreadValues$d({}, rest), {
    isOpen: (_d = isAutoOpen || isOpen) != null ? _d : false
  });
  return /* @__PURE__ */ React__default.default.createElement(PlasmicDialogTriggerContext.Provider, { value: mergedProps }, /* @__PURE__ */ React__default.default.createElement(reactAriaComponents.DialogTrigger, __spreadValues$d({}, mergedProps), trigger, dialog));
}
function registerDialogTrigger(loader, overrides) {
  registerComponentHelper(
    loader,
    BaseDialogTrigger,
    {
      name: makeComponentName("dialogTrigger"),
      displayName: "Aria Dialog Trigger",
      importPath: "@plasmicpkgs/react-aria/skinny/registerDialogTrigger",
      importName: "BaseDialogTrigger",
      styleSections: false,
      props: {
        trigger: {
          type: "slot",
          mergeWithParent: true,
          defaultValue: {
            type: "component",
            name: BUTTON_COMPONENT_NAME,
            props: {
              children: {
                type: "text",
                value: "Open Dialog"
              }
            }
          }
        },
        dialog: {
          type: "slot",
          mergeWithParent: true,
          defaultValue: [
            {
              type: "component",
              name: MODAL_COMPONENT_NAME,
              props: {
                children: {
                  type: "component",
                  name: DIALOG_COMPONENT_NAME,
                  props: {
                    children: MODAL_DEFAULT_SLOT_CONTENT
                  }
                }
              }
            }
          ]
        },
        isOpen: {
          type: "boolean",
          defaultValueHint: false,
          editOnly: true,
          uncontrolledProp: "defaultOpen"
        },
        onOpenChange: {
          type: "eventHandler",
          argTypes: [{ name: "isOpen", type: "boolean" }]
        }
      },
      states: {
        isOpen: {
          type: "writable",
          valueProp: "isOpen",
          onChangeProp: "onOpenChange",
          variableType: "boolean"
        }
      },
      trapsFocus: true
    },
    overrides
  );
}

var __defProp$c = Object.defineProperty;
var __defProps$a = Object.defineProperties;
var __getOwnPropDescs$a = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$c = Object.getOwnPropertySymbols;
var __hasOwnProp$c = Object.prototype.hasOwnProperty;
var __propIsEnum$c = Object.prototype.propertyIsEnumerable;
var __defNormalProp$c = (obj, key, value) => key in obj ? __defProp$c(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$c = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$c.call(b, prop))
      __defNormalProp$c(a, prop, b[prop]);
  if (__getOwnPropSymbols$c)
    for (var prop of __getOwnPropSymbols$c(b)) {
      if (__propIsEnum$c.call(b, prop))
        __defNormalProp$c(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$a = (a, b) => __defProps$a(a, __getOwnPropDescs$a(b));
var __objRest$9 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$c.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$c)
    for (var prop of __getOwnPropSymbols$c(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$c.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function BaseHeading(_a) {
  var _b = _a, { children } = _b, rest = __objRest$9(_b, ["children"]);
  return /* @__PURE__ */ React__default.default.createElement(reactAriaComponents.Heading, __spreadProps$a(__spreadValues$c({}, rest), { style: COMMON_STYLES }), children);
}
const HEADING_COMPONENT_NAME = makeComponentName("heading");
function registerHeading(loader, overrides) {
  return registerComponentHelper(
    loader,
    BaseHeading,
    {
      name: HEADING_COMPONENT_NAME,
      displayName: "Aria Heading (deprecated)",
      importPath: "@plasmicpkgs/react-aria/skinny/registerHeading",
      importName: "BaseHeading",
      defaultStyles: {
        fontSize: "20px",
        fontWeight: "bold",
        marginBottom: "10px"
      },
      props: {
        children: {
          type: "slot",
          mergeWithParent: true,
          defaultValue: {
            type: "text",
            value: "Heading"
          }
        },
        slot: {
          type: "string",
          defaultValue: "title",
          hidden: () => true
        }
      },
      trapsFocus: true
    },
    overrides
  );
}

var __defProp$b = Object.defineProperty;
var __getOwnPropSymbols$b = Object.getOwnPropertySymbols;
var __hasOwnProp$b = Object.prototype.hasOwnProperty;
var __propIsEnum$b = Object.prototype.propertyIsEnumerable;
var __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$b = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$b.call(b, prop))
      __defNormalProp$b(a, prop, b[prop]);
  if (__getOwnPropSymbols$b)
    for (var prop of __getOwnPropSymbols$b(b)) {
      if (__propIsEnum$b.call(b, prop))
        __defNormalProp$b(a, prop, b[prop]);
    }
  return a;
};
const OVERLAY_ARROW_VARIANTS = [
  // We do not offer a placementDown variant, because that's the default placement (an overlay arrow always has [data-placement=bottom] if it's not explicitly set)
  "placementTop",
  "placementLeft",
  "placementRight"
];
const { variants: variants$a, withObservedValues: withObservedValues$9 } = pickAriaComponentVariants(
  OVERLAY_ARROW_VARIANTS
);
function BaseOverlayArrow({
  children,
  plasmicUpdateVariant,
  className
}) {
  const popoverContext = React__default.default.useContext(reactAriaComponents.PopoverContext);
  const tooltipContext = React__default.default.useContext(reactAriaComponents.TooltipContext);
  const isStandalone = !popoverContext && !tooltipContext;
  const overlayArrow = /* @__PURE__ */ React__default.default.createElement(
    reactAriaComponents.OverlayArrow,
    {
      style: __spreadValues$b({ lineHeight: "0" }, COMMON_STYLES),
      className
    },
    ({ placement }) => withObservedValues$9(
      children,
      {
        placementTop: placement === "top",
        placementLeft: placement === "left",
        placementRight: placement === "right"
      },
      plasmicUpdateVariant
    )
  );
  if (isStandalone) {
    return /* @__PURE__ */ React__default.default.createElement("div", { style: { position: "relative" } }, overlayArrow);
  }
  return overlayArrow;
}
const OVERLAY_ARROW_COMPONENT_NAME = makeComponentName("overlayArrow");
function registerOverlayArrow(loader, overrides) {
  return registerComponentHelper(
    loader,
    BaseOverlayArrow,
    {
      name: OVERLAY_ARROW_COMPONENT_NAME,
      displayName: "Aria Overlay Arrow",
      importPath: "@plasmicpkgs/react-aria/skinny/registerOverlayArrow",
      importName: "BaseOverlayArrow",
      styleSections: false,
      variants: variants$a,
      props: {
        children: {
          type: "slot",
          defaultValue: arrowDown
        }
      }
    },
    overrides
  );
}

var __defProp$a = Object.defineProperty;
var __defProps$9 = Object.defineProperties;
var __getOwnPropDescs$9 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$a = Object.getOwnPropertySymbols;
var __hasOwnProp$a = Object.prototype.hasOwnProperty;
var __propIsEnum$a = Object.prototype.propertyIsEnumerable;
var __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$a = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$a.call(b, prop))
      __defNormalProp$a(a, prop, b[prop]);
  if (__getOwnPropSymbols$a)
    for (var prop of __getOwnPropSymbols$a(b)) {
      if (__propIsEnum$a.call(b, prop))
        __defNormalProp$a(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$9 = (a, b) => __defProps$9(a, __getOwnPropDescs$9(b));
var __objRest$8 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$a.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$a)
    for (var prop of __getOwnPropSymbols$a(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$a.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const RADIO_VARIANTS = [
  "selected",
  "hovered",
  "pressed",
  "focused",
  "focusVisible",
  "disabled",
  "readonly",
  "selected"
];
const { variants: variants$9, withObservedValues: withObservedValues$8 } = pickAriaComponentVariants(RADIO_VARIANTS);
function BaseRadio(props) {
  const _a = props, {
    children,
    setControlContextData,
    plasmicUpdateVariant,
    value
  } = _a, rest = __objRest$8(_a, [
    "children",
    "setControlContextData",
    "plasmicUpdateVariant",
    "value"
  ]);
  const contextProps = React__default.default.useContext(PlasmicRadioGroupContext);
  const isStandalone = !contextProps;
  const [registeredId, setRegisteredId] = React.useState("");
  React.useEffect(() => {
    if (!(contextProps == null ? void 0 : contextProps.idManager)) {
      return;
    }
    const localId = contextProps.idManager.register(value);
    setRegisteredId(localId);
    return () => {
      contextProps.idManager.unregister(localId);
      setRegisteredId("");
    };
  }, [value, contextProps == null ? void 0 : contextProps.idManager]);
  setControlContextData == null ? void 0 : setControlContextData({
    parent: contextProps,
    idError: (() => {
      if (value === void 0) {
        return "Value must be defined";
      }
      if (typeof value !== "string") {
        return "Value must be a string";
      }
      if (!value.trim()) {
        return "Value must be defined";
      }
      if (!isStandalone && value != registeredId) {
        return "Value must be unique";
      }
      return void 0;
    })()
  });
  const radio = /* @__PURE__ */ React__default.default.createElement(
    reactAriaComponents.Radio,
    __spreadProps$9(__spreadValues$a({}, rest), {
      value: registeredId,
      key: registeredId,
      style: COMMON_STYLES
    }),
    ({
      isHovered,
      isPressed,
      isFocused,
      isFocusVisible,
      isSelected,
      isDisabled,
      isReadOnly
    }) => withObservedValues$8(
      children,
      {
        hovered: isHovered,
        pressed: isPressed,
        focused: isFocused,
        focusVisible: isFocusVisible,
        selected: isSelected,
        disabled: isDisabled,
        readonly: isReadOnly
      },
      plasmicUpdateVariant
    )
  );
  if (isStandalone) {
    return /* @__PURE__ */ React__default.default.createElement(reactAriaComponents.RadioGroup, null, radio);
  }
  return radio;
}
const makeDefaultRadioChildren = (label) => ({
  type: "hbox",
  styles: {
    display: "flex",
    alignItems: "center",
    gap: "10px",
    padding: 0
  },
  children: [
    {
      type: "box",
      styles: {
        width: "7px",
        height: "7px",
        borderRadius: "100%",
        borderWidth: "1px",
        borderStyle: "solid",
        borderColor: "black"
      }
    },
    {
      type: "component",
      name: LABEL_COMPONENT_NAME,
      props: {
        children: {
          type: "text",
          value: label
        }
      }
    }
  ]
});
function registerRadio(loader, overrides) {
  return registerComponentHelper(
    loader,
    BaseRadio,
    {
      name: makeComponentName("radio"),
      displayName: "Aria Radio",
      importPath: "@plasmicpkgs/react-aria/skinny/registerRadio",
      importName: "BaseRadio",
      variants: variants$9,
      props: __spreadProps$9(__spreadValues$a({}, getCommonProps("radio", [
        "isDisabled",
        "autoFocus",
        "aria-label"
      ])), {
        children: {
          type: "slot",
          mergeWithParent: true,
          defaultValue: makeDefaultRadioChildren("Radio")
        },
        value: {
          type: "string",
          description: "The value of the input element, used when submitting an HTML form.",
          validator: (_value, _props, ctx) => {
            if (ctx == null ? void 0 : ctx.idError) {
              return ctx.idError;
            }
            return true;
          }
        }
      }),
      trapsFocus: true
    },
    overrides
  );
}

var __defProp$9 = Object.defineProperty;
var __defProps$8 = Object.defineProperties;
var __getOwnPropDescs$8 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;
var __hasOwnProp$9 = Object.prototype.hasOwnProperty;
var __propIsEnum$9 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$9 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$9.call(b, prop))
      __defNormalProp$9(a, prop, b[prop]);
  if (__getOwnPropSymbols$9)
    for (var prop of __getOwnPropSymbols$9(b)) {
      if (__propIsEnum$9.call(b, prop))
        __defNormalProp$9(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$8 = (a, b) => __defProps$8(a, __getOwnPropDescs$8(b));
var __objRest$7 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$9.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$9)
    for (var prop of __getOwnPropSymbols$9(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$9.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const RADIO_GROUP_VARIANTS = ["disabled", "readonly"];
const { variants: variants$8, withObservedValues: withObservedValues$7 } = pickAriaComponentVariants(RADIO_GROUP_VARIANTS);
function BaseRadioGroup(props) {
  const _a = props, { children, plasmicUpdateVariant, setControlContextData } = _a, rest = __objRest$7(_a, ["children", "plasmicUpdateVariant", "setControlContextData"]);
  const [ids, setIds] = React.useState([]);
  const idManager = React.useMemo(() => new OptionsItemIdManager(), []);
  React.useEffect(() => {
    setControlContextData == null ? void 0 : setControlContextData({
      values: ids
    });
  }, [ids, setControlContextData]);
  React.useEffect(() => {
    idManager.subscribe((_ids) => {
      setIds(_ids);
    });
  }, [idManager]);
  return /* @__PURE__ */ React__default.default.createElement(PlasmicRadioGroupContext.Provider, { value: __spreadProps$8(__spreadValues$9({}, props), { idManager }) }, /* @__PURE__ */ React__default.default.createElement(reactAriaComponents.RadioGroup, __spreadProps$8(__spreadValues$9({}, rest), { style: COMMON_STYLES }), ({ isDisabled, isReadOnly }) => withObservedValues$7(
    children,
    {
      disabled: isDisabled,
      readonly: isReadOnly
    },
    plasmicUpdateVariant
  )));
}
const RADIO_GROUP_COMPONENT_NAME = makeComponentName("radioGroup");
function registerRadioGroup(loader, overrides) {
  const thisName = makeChildComponentName(
    overrides == null ? void 0 : overrides.parentComponentName,
    RADIO_GROUP_COMPONENT_NAME
  );
  const radioMeta = registerRadio(loader, { parentComponentName: thisName });
  registerComponentHelper(
    loader,
    BaseRadioGroup,
    {
      name: RADIO_GROUP_COMPONENT_NAME,
      displayName: "Aria RadioGroup",
      importPath: "@plasmicpkgs/react-aria/skinny/registerRadioGroup",
      importName: "BaseRadioGroup",
      variants: variants$8,
      props: __spreadProps$8(__spreadValues$9({}, getCommonProps("radio group", [
        "name",
        "isDisabled",
        "isReadOnly",
        "aria-label",
        "isRequired"
      ])), {
        children: {
          type: "slot",
          defaultValue: [
            {
              type: "vbox",
              styles: {
                display: "flex",
                gap: "5px",
                padding: 0,
                alignItems: "flex-start"
              },
              children: [
                {
                  type: "component",
                  name: LABEL_COMPONENT_NAME,
                  props: {
                    children: {
                      type: "text",
                      value: "Radio Group"
                    }
                  }
                },
                {
                  type: "component",
                  name: radioMeta.name,
                  props: {
                    children: makeDefaultRadioChildren("Radio 1"),
                    value: "radio1"
                  }
                },
                {
                  type: "component",
                  name: radioMeta.name,
                  props: {
                    children: makeDefaultRadioChildren("Radio 2"),
                    value: "radio2"
                  }
                },
                {
                  type: "component",
                  name: radioMeta.name,
                  props: {
                    children: makeDefaultRadioChildren("Radio 3"),
                    value: "radio3"
                  }
                },
                {
                  type: "component",
                  name: DESCRIPTION_COMPONENT_NAME,
                  props: {
                    children: {
                      type: "text",
                      value: "Use the registered variants to see it in action..."
                    }
                  }
                }
              ]
            }
          ]
        },
        value: {
          type: "choice",
          editOnly: true,
          displayName: "Initial value",
          uncontrolledProp: "defaultValue",
          description: "The current value",
          options: (_props, ctx) => (ctx == null ? void 0 : ctx.values) ? Array.from(ctx.values) : [],
          multiSelect: false
        },
        isInvalid: {
          displayName: "Invalid",
          type: "boolean",
          description: "Whether the input value is invalid",
          defaultValueHint: false
        },
        validationBehavior: {
          type: "choice",
          options: ["native", "aria"],
          description: "Whether to use native HTML form validation to prevent form submission when the value is missing or invalid, or mark the field as required or invalid via ARIA.",
          defaultValueHint: "native"
        },
        onChange: {
          type: "eventHandler",
          argTypes: [{ name: "value", type: "string" }]
        }
      }),
      states: {
        value: {
          type: "writable",
          valueProp: "value",
          onChangeProp: "onChange",
          variableType: "array"
        }
      },
      trapsFocus: true
    },
    overrides
  );
}

var __defProp$8 = Object.defineProperty;
var __defProps$7 = Object.defineProperties;
var __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$8 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$8.call(b, prop))
      __defNormalProp$8(a, prop, b[prop]);
  if (__getOwnPropSymbols$8)
    for (var prop of __getOwnPropSymbols$8(b)) {
      if (__propIsEnum$8.call(b, prop))
        __defNormalProp$8(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$7 = (a, b) => __defProps$7(a, __getOwnPropDescs$7(b));
function SelectAutoOpen(props) {
  var _a;
  const { open, close } = (_a = React__default.default.useContext(reactAriaComponents.SelectStateContext)) != null ? _a : {};
  useAutoOpen({
    props,
    open: () => {
      open == null ? void 0 : open();
      setTimeout(() => {
        var _a2, _b;
        (_b = (_a2 = window.parent.document.activeElement) == null ? void 0 : _a2.blur) == null ? void 0 : _b.call(_a2);
      }, 1);
    },
    close
  });
  return null;
}
const BaseSelectValue = (props) => {
  const { children, customize, className } = props;
  const placeholder = customize ? children : "Select an item";
  return /* @__PURE__ */ React__default.default.createElement(reactAriaComponents.SelectValue, { className, style: COMMON_STYLES }, ({ isPlaceholder, selectedText }) => /* @__PURE__ */ React__default.default.createElement(React__default.default.Fragment, null, isPlaceholder ? placeholder : selectedText));
};
const SELECT_NAME = makeComponentName("select");
const SELECT_VARIANTS = [
  "focused",
  "focusVisible",
  "disabled"
];
const { variants: SELECT_VARIANTS_DATA } = pickAriaComponentVariants(SELECT_VARIANTS);
function BaseSelect(props) {
  const {
    selectedKey,
    onSelectionChange,
    onOpenChange,
    isDisabled,
    className,
    children,
    disabledKeys,
    name,
    setControlContextData,
    plasmicUpdateVariant,
    "aria-label": ariaLabel
  } = props;
  const idManager = React.useMemo(() => new OptionsItemIdManager(), []);
  React.useEffect(() => {
    idManager.subscribe((ids) => {
      setControlContextData == null ? void 0 : setControlContextData({
        itemIds: ids
      });
    });
  }, []);
  const classNameProp = React.useCallback(
    ({
      isDisabled: isDisabled2,
      isFocusVisible,
      isFocused
    }) => {
      plasmicUpdateVariant == null ? void 0 : plasmicUpdateVariant({
        disabled: isDisabled2,
        focused: isFocused,
        focusVisible: isFocusVisible
      });
      return className != null ? className : "";
    },
    [className, plasmicUpdateVariant]
  );
  return /* @__PURE__ */ React__default.default.createElement(
    reactAriaComponents.Select,
    __spreadValues$8({
      selectedKey,
      onSelectionChange,
      onOpenChange,
      isDisabled,
      className: classNameProp,
      style: COMMON_STYLES,
      name,
      disabledKeys,
      "aria-label": ariaLabel
    }, extractPlasmicDataProps(props)),
    /* @__PURE__ */ React__default.default.createElement(SelectAutoOpen, __spreadValues$8({}, props)),
    /* @__PURE__ */ React__default.default.createElement(PlasmicPopoverTriggerContext.Provider, { value: true }, /* @__PURE__ */ React__default.default.createElement(
      PlasmicListBoxContext.Provider,
      {
        value: {
          idManager
        }
      },
      children
    ))
  );
}
function registerSelect(loader) {
  const selectValueMeta = registerComponentHelper(loader, BaseSelectValue, {
    name: makeComponentName("select-value"),
    displayName: "Aria Selected Value",
    importPath: "@plasmicpkgs/react-aria/skinny/registerSelect",
    importName: "BaseSelectValue",
    parentComponentName: SELECT_NAME,
    props: {
      customize: {
        type: "boolean",
        displayName: "Customize placeholder",
        defaultValue: true,
        description: "Customize the placeholder text and styles"
      },
      children: {
        type: "slot",
        displayName: "Placeholder",
        defaultValue: [
          {
            type: "text",
            value: "Select an item"
          }
        ],
        hidden: (props) => !props.customize
      }
    },
    trapsFocus: true
  });
  registerComponentHelper(loader, BaseSelect, {
    name: SELECT_NAME,
    displayName: "Aria Select",
    importPath: "@plasmicpkgs/react-aria/skinny/registerSelect",
    importName: "BaseSelect",
    variants: SELECT_VARIANTS_DATA,
    props: __spreadProps$7(__spreadValues$8({}, getCommonProps("Select", [
      "name",
      "aria-label",
      "isDisabled",
      "autoFocus"
    ])), {
      selectedKey: {
        type: "choice",
        editOnly: true,
        uncontrolledProp: "defaultSelectedKey",
        displayName: "Initial selected item",
        options: (_props, ctx) => (ctx == null ? void 0 : ctx.itemIds) ? Array.from(ctx.itemIds) : [],
        // React Aria Select do not support multiple selections yet
        multiSelect: false
      },
      onSelectionChange: {
        type: "eventHandler",
        argTypes: [{ name: "selectedValue", type: "string" }]
      },
      disabledKeys: {
        type: "choice",
        displayName: "Disabled values",
        description: "The items that are disabled. These items cannot be selected, focused, or otherwise interacted with.",
        options: (_props, ctx) => (ctx == null ? void 0 : ctx.itemIds) ? Array.from(ctx.itemIds) : [],
        multiSelect: true,
        advanced: true
      },
      isOpen: {
        type: "boolean",
        defaultValue: false,
        // It doesn't make sense to make isOpen prop editable (it's controlled by user interaction and always closed by default), so we keep this prop hidden. We have listed the prop here in the meta only so we can expose a writeable state for it.
        hidden: () => true
      },
      onOpenChange: {
        type: "eventHandler",
        argTypes: [{ name: "isOpen", type: "boolean" }]
      },
      children: {
        type: "slot",
        mergeWithParent: true,
        defaultValue: [
          {
            type: "vbox",
            styles: {
              justifyContent: "flex-start",
              alignItems: "flex-start",
              width: "300px",
              padding: 0
            },
            children: [
              {
                type: "component",
                name: LABEL_COMPONENT_NAME,
                props: {
                  children: {
                    type: "text",
                    value: "Label"
                  }
                }
              },
              {
                type: "component",
                name: BUTTON_COMPONENT_NAME,
                styles: {
                  width: "100%",
                  padding: "4px 10px",
                  background: "white"
                },
                props: {
                  children: {
                    type: "hbox",
                    styles: {
                      width: "stretch",
                      justifyContent: "space-between",
                      alignItems: "center",
                      padding: 0
                    },
                    children: [
                      {
                        type: "component",
                        name: selectValueMeta.name
                      },
                      arrowDown
                    ]
                  }
                }
              },
              {
                type: "component",
                name: POPOVER_COMPONENT_NAME,
                styles: {
                  backgroundColor: "white",
                  padding: "10px",
                  overflow: "scroll",
                  width: "unset"
                },
                props: {
                  children: [
                    {
                      type: "component",
                      name: LIST_BOX_COMPONENT_NAME,
                      props: {
                        selectionMode: "single"
                      },
                      styles: {
                        borderWidth: 0,
                        width: "stretch"
                      }
                    }
                  ]
                }
              }
            ]
          }
        ]
      }
    }),
    states: {
      selectedValue: {
        type: "writable",
        valueProp: "selectedKey",
        onChangeProp: "onSelectionChange",
        variableType: "text"
      },
      isOpen: {
        type: "writable",
        valueProp: "isOpen",
        onChangeProp: "onOpenChange",
        variableType: "boolean"
      }
    },
    trapsFocus: true
  });
}

var __defProp$7 = Object.defineProperty;
var __defProps$6 = Object.defineProperties;
var __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;
var __hasOwnProp$7 = Object.prototype.hasOwnProperty;
var __propIsEnum$7 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$7 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$7.call(b, prop))
      __defNormalProp$7(a, prop, b[prop]);
  if (__getOwnPropSymbols$7)
    for (var prop of __getOwnPropSymbols$7(b)) {
      if (__propIsEnum$7.call(b, prop))
        __defNormalProp$7(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));
var __objRest$6 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$7.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$7)
    for (var prop of __getOwnPropSymbols$7(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$7.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const SLIDER_OUTPUT_VARIANTS = ["disabled"];
const { variants: variants$7, withObservedValues: withObservedValues$6 } = pickAriaComponentVariants(
  SLIDER_OUTPUT_VARIANTS
);
function BaseSliderOutput(props) {
  const _a = props, { plasmicUpdateVariant, children } = _a, rest = __objRest$6(_a, ["plasmicUpdateVariant", "children"]);
  return /* @__PURE__ */ React__default.default.createElement(reactAriaComponents.SliderOutput, __spreadProps$6(__spreadValues$7({}, rest), { style: COMMON_STYLES }), ({ isDisabled }) => withObservedValues$6(
    children,
    {
      disabled: isDisabled
    },
    plasmicUpdateVariant
  ));
}
const SLIDER_OUTPUT_COMPONENT_NAME = makeComponentName("sliderOutput");
function registerSliderOutput(loader, overrides) {
  return registerComponentHelper(
    loader,
    BaseSliderOutput,
    {
      name: SLIDER_OUTPUT_COMPONENT_NAME,
      displayName: "Aria Slider Output",
      importPath: "@plasmicpkgs/react-aria/skinny/registerSliderOutput",
      importName: "BaseSliderOutput",
      variants: variants$7,
      props: {
        children: {
          mergeWithParent: true,
          type: "slot"
        }
      },
      trapsFocus: true
    },
    overrides
  );
}

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }
  static getDerivedStateFromError(_) {
    return { hasError: true };
  }
  render() {
    if (this.state.hasError) {
      return this.props.fallback;
    }
    return this.props.children;
  }
}

var __defProp$6 = Object.defineProperty;
var __defProps$5 = Object.defineProperties;
var __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$6 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$6.call(b, prop))
      __defNormalProp$6(a, prop, b[prop]);
  if (__getOwnPropSymbols$6)
    for (var prop of __getOwnPropSymbols$6(b)) {
      if (__propIsEnum$6.call(b, prop))
        __defNormalProp$6(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));
var __objRest$5 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$6.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$6)
    for (var prop of __getOwnPropSymbols$6(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$6.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const SLIDER_THUMB_VARIANTS = [
  "dragging",
  "hovered",
  "focused",
  "focusVisible",
  "disabled"
];
const { variants: variants$6, withObservedValues: withObservedValues$5 } = pickAriaComponentVariants(
  SLIDER_THUMB_VARIANTS
);
function BaseSliderThumb(_a) {
  var _b = _a, {
    children,
    advanced,
    plasmicUpdateVariant
  } = _b, rest = __objRest$5(_b, [
    "children",
    "advanced",
    "plasmicUpdateVariant"
  ]);
  const thumb = /* @__PURE__ */ React__default.default.createElement(reactAriaComponents.SliderThumb, __spreadProps$5(__spreadValues$6({}, rest), { style: COMMON_STYLES }), ({ isDragging, isHovered, isFocused, isFocusVisible, isDisabled }) => withObservedValues$5(
    /* @__PURE__ */ React__default.default.createElement(React__default.default.Fragment, null, advanced ? children : void 0),
    {
      dragging: isDragging,
      hovered: isHovered,
      focused: isFocused,
      focusVisible: isFocusVisible,
      disabled: isDisabled
    },
    plasmicUpdateVariant
  ));
  return /* @__PURE__ */ React__default.default.createElement(
    ErrorBoundary,
    {
      fallback: /* @__PURE__ */ React__default.default.createElement(reactAriaComponents.Slider, { style: { height: "100%", width: "100%" } }, /* @__PURE__ */ React__default.default.createElement(reactAriaComponents.SliderTrack, null, thumb))
    },
    thumb
  );
}
const SLIDER_THUMB_COMPONENT_NAME = makeComponentName("sliderThumb");
function registerSliderThumb(loader, overrides) {
  return registerComponentHelper(
    loader,
    BaseSliderThumb,
    {
      name: SLIDER_THUMB_COMPONENT_NAME,
      displayName: "Aria Slider Thumb",
      importPath: "@plasmicpkgs/react-aria/skinny/registerSliderThumb",
      importName: "BaseSliderThumb",
      defaultStyles: {
        position: "absolute",
        top: "5px",
        width: "20px",
        height: "20px",
        backgroundColor: "#C80101",
        borderRadius: "100%",
        cursor: "pointer"
      },
      variants: variants$6,
      props: __spreadProps$5(__spreadValues$6({}, getCommonProps("slider thumb", [
        "name",
        "isDisabled",
        "autoFocus"
      ])), {
        advanced: {
          type: "boolean",
          displayName: "Advanced",
          description: "Enables the children slot for creating a more customized thumb"
        },
        children: {
          type: "slot",
          mergeWithParent: true,
          hidden: (props) => !props.advanced
        }
      }),
      trapsFocus: true
    },
    overrides
  );
}

var __defProp$5 = Object.defineProperty;
var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
var __propIsEnum$5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$5 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$5.call(b, prop))
      __defNormalProp$5(a, prop, b[prop]);
  if (__getOwnPropSymbols$5)
    for (var prop of __getOwnPropSymbols$5(b)) {
      if (__propIsEnum$5.call(b, prop))
        __defNormalProp$5(a, prop, b[prop]);
    }
  return a;
};
var __objRest$4 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$5.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$5)
    for (var prop of __getOwnPropSymbols$5(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$5.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const SLIDER_TRACK_VARIANTS = ["hovered"];
const { variants: variants$5, withObservedValues: withObservedValues$4 } = pickAriaComponentVariants(
  SLIDER_TRACK_VARIANTS
);
function isMultiValueGuard(value) {
  return Array.isArray(value) && value.length > 1;
}
function BaseSliderTrack(props) {
  const context = React__default.default.useContext(PlasmicSliderContext);
  const isStandalone = !context;
  const _a = props, { children, progressBar, plasmicUpdateVariant } = _a, rest = __objRest$4(_a, ["children", "progressBar", "plasmicUpdateVariant"]);
  const thumbsLength = context && isMultiValueGuard(context.value) ? context.value.length : 1;
  const isMultiValue = thumbsLength > 1;
  const { minIndex, maxIndex } = React.useMemo(() => {
    if (thumbsLength <= 1) {
      return { minIndex: 0, maxIndex: 0 };
    }
    return { minIndex: 0, maxIndex: thumbsLength - 1 };
  }, [thumbsLength]);
  const thumbs = React.useMemo(() => {
    const thumbNodes = flattenChildren__default.default(children);
    if (!thumbNodes || thumbNodes.length === 0 || !isDefined(context == null ? void 0 : context.value)) {
      return [];
    }
    const values = isDefined(context) ? Array.isArray(context.value) ? context.value : [context.value] : [];
    const lastThumb = thumbNodes[thumbNodes.length - 1];
    return values.map((v, i) => {
      const currentThumb = thumbNodes[i];
      if (i >= thumbNodes.length) {
        if (React__default.default.isValidElement(lastThumb)) {
          return React__default.default.cloneElement(lastThumb, {
            index: i
          });
        }
      }
      if (!React__default.default.isValidElement(currentThumb)) {
        return null;
      }
      return React__default.default.cloneElement(currentThumb, {
        index: i
      });
    });
  }, [children, context == null ? void 0 : context.value]);
  const track = /* @__PURE__ */ React__default.default.createElement(reactAriaComponents.SliderTrack, __spreadValues$5({ style: { position: "relative" } }, rest), ({ state, isHovered }) => /* @__PURE__ */ React__default.default.createElement(React__default.default.Fragment, null, withObservedValues$4(
    /* @__PURE__ */ React__default.default.createElement(React__default.default.Fragment, null, /* @__PURE__ */ React__default.default.createElement(
      "div",
      {
        style: {
          width: `${(!isMultiValue ? state.getThumbPercent(minIndex) : state.getThumbPercent(maxIndex) - state.getThumbPercent(minIndex)) * 100}%`,
          height: "100%",
          position: "absolute",
          top: 0,
          left: !isMultiValue ? 0 : state.getThumbPercent(minIndex) * 100 + "%"
        }
      },
      progressBar
    ), thumbs),
    {
      hovered: isHovered
    },
    plasmicUpdateVariant
  )));
  if (isStandalone) {
    return /* @__PURE__ */ React__default.default.createElement(reactAriaComponents.Slider, { style: __spreadValues$5({ height: "100%", width: "100%" }, COMMON_STYLES) }, track);
  }
  return track;
}
const SLIDER_TRACK_COMPONENT_NAME = makeComponentName("sliderTrack");
function registerSliderTrack(sliderThumbMeta, loader, overrides) {
  return registerComponentHelper(
    loader,
    BaseSliderTrack,
    {
      name: SLIDER_TRACK_COMPONENT_NAME,
      displayName: "Aria Slider Track",
      importPath: "@plasmicpkgs/react-aria/skinny/registerSliderTrack",
      importName: "BaseSliderTrack",
      variants: variants$5,
      defaultStyles: {
        width: "stretch",
        backgroundColor: "#aaa",
        position: "relative",
        height: "10px",
        padding: 0
      },
      props: {
        children: {
          type: "slot",
          /**
           * NOTE: We don't merge with parent here, because we want to allow the user to select the thumbs without having to first select the slider track.
           * Also, there can be more than one thumbs (e.g. in a range slider), but `mergeWithParent` only shows prop controls of the slot content if there is only one direct descendant of the slot.
           * */
          // mergeWithParent: true,
          displayName: "Thumbs",
          description: "The thumbs of the slider. For range slider, you can add more than one thumb.",
          allowedComponents: [sliderThumbMeta.name],
          allowRootWrapper: true,
          defaultValue: [
            {
              type: "component",
              name: sliderThumbMeta.name
            }
          ]
        },
        progressBar: {
          type: "slot",
          mergeWithParent: true,
          displayName: "Progress Bar",
          defaultValue: [
            {
              type: "box",
              styles: {
                height: "100%",
                width: "100%",
                backgroundColor: "#ffa6a6",
                padding: 0
              }
            }
          ]
        },
        onHoverStart: {
          type: "eventHandler",
          argTypes: [{ name: "event", type: "object" }]
        },
        onHoverEnd: {
          type: "eventHandler",
          argTypes: [{ name: "event", type: "object" }]
        },
        onHoverChange: {
          type: "eventHandler",
          argTypes: [{ name: "isHovering", type: "boolean" }]
        }
      }
    },
    overrides
  );
}

var __defProp$4 = Object.defineProperty;
var __defProps$4 = Object.defineProperties;
var __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$4 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$4.call(b, prop))
      __defNormalProp$4(a, prop, b[prop]);
  if (__getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(b)) {
      if (__propIsEnum$4.call(b, prop))
        __defNormalProp$4(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));
var __objRest$3 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$4.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$4.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const SLIDER_COMPONENT_NAME = makeComponentName("slider");
const RANGE_SLIDER_COMPONENT_NAME = makeComponentName("range-slider");
const SLIDER_VARIANTS = ["disabled"];
const { variants: variants$4, withObservedValues: withObservedValues$3 } = pickAriaComponentVariants(SLIDER_VARIANTS);
function BaseSlider(props) {
  const _a = props, { children, plasmicUpdateVariant } = _a, rest = __objRest$3(_a, ["children", "plasmicUpdateVariant"]);
  return /* @__PURE__ */ React__default.default.createElement(
    PlasmicSliderContext.Provider,
    {
      value: __spreadProps$4(__spreadValues$4({}, rest), {
        // Here's why the type casting is needed here: https://github.com/Microsoft/TypeScript/issues/3410
        onChange: rest.onChange,
        onChangeEnd: rest.onChangeEnd
      })
    },
    /* @__PURE__ */ React__default.default.createElement(reactAriaComponents.Slider, __spreadProps$4(__spreadValues$4({}, rest), { style: COMMON_STYLES }), ({ isDisabled }) => withObservedValues$3(
      children,
      {
        disabled: isDisabled
      },
      plasmicUpdateVariant
    ))
  );
}
function getCommonSliderProps() {
  return {
    orientation: {
      type: "choice",
      options: ["horizontal", "vertical"],
      defaultValueHint: "horizontal",
      defaultValue: "horizontal"
    },
    minValue: {
      type: "number",
      description: "The minimum value of the slider",
      defaultValueHint: 0
    },
    maxValue: {
      type: "number",
      description: "The maximum value of the slider",
      defaultValueHint: 100
    },
    step: {
      type: "number",
      description: "The step value of the slider",
      defaultValueHint: 1
    }
  };
}
function registerSlider(loader, overrides) {
  const sliderOutputMeta = registerSliderOutput(loader, {
    parentComponentName: SLIDER_COMPONENT_NAME
  });
  const sliderThumbMeta = registerSliderThumb(loader, {
    parentComponentName: SLIDER_COMPONENT_NAME
  });
  const sliderTrackMeta = registerSliderTrack(sliderThumbMeta, loader, {
    parentComponentName: SLIDER_COMPONENT_NAME
  });
  registerComponentHelper(
    loader,
    BaseSlider,
    {
      name: RANGE_SLIDER_COMPONENT_NAME,
      displayName: "Aria Range Slider",
      importPath: "@plasmicpkgs/react-aria/skinny/registerSlider",
      importName: "BaseSlider",
      variants: variants$4,
      defaultStyles: {
        width: "300px"
      },
      props: __spreadProps$4(__spreadValues$4(__spreadValues$4({}, getCommonProps("slider", [
        "isDisabled",
        "aria-label"
      ])), getCommonSliderProps()), {
        value: {
          type: "array",
          editOnly: true,
          displayName: "Initial value",
          uncontrolledProp: "defaultValue",
          description: "The intial value of the slider",
          defaultValue: [20, 50],
          validator: (value) => {
            if (!Array.isArray(value)) {
              return "Input must be an array.";
            }
            for (let i = 1; i < value.length; i++) {
              if (value[i] < value[i - 1]) {
                return "Array elements are not in ascending order.";
              }
            }
            return true;
          }
        },
        children: {
          type: "slot",
          defaultValue: [
            {
              type: "hbox",
              styles: {
                width: "stretch",
                justifyContent: "space-between",
                padding: "8px 0px"
              },
              children: [
                {
                  type: "component",
                  name: LABEL_COMPONENT_NAME,
                  props: {
                    children: {
                      type: "text",
                      value: "Label"
                    }
                  }
                },
                {
                  type: "component",
                  name: sliderOutputMeta.name,
                  props: {
                    children: {
                      type: "text",
                      value: "Output"
                    }
                  }
                }
              ]
            },
            {
              type: "component",
              name: sliderTrackMeta.name,
              props: {
                children: [
                  {
                    type: "component",
                    name: sliderThumbMeta.name
                  },
                  {
                    type: "component",
                    name: sliderThumbMeta.name,
                    styles: {
                      backgroundColor: "blue"
                    }
                  }
                ]
              }
            }
          ]
        },
        onChange: {
          type: "eventHandler",
          argTypes: [{ name: "value", type: "object" }]
        },
        onChangeEnd: {
          type: "eventHandler",
          argTypes: [{ name: "value", type: "object" }]
        }
      }),
      states: {
        value: {
          type: "writable",
          valueProp: "value",
          onChangeProp: "onChange",
          variableType: "array"
        }
      },
      trapsFocus: true
    },
    {
      parentComponentName: SLIDER_COMPONENT_NAME
    }
  );
  registerComponentHelper(
    loader,
    BaseSlider,
    {
      name: SLIDER_COMPONENT_NAME,
      displayName: "Aria Slider",
      importPath: "@plasmicpkgs/react-aria/skinny/registerSlider",
      importName: "BaseSlider",
      variants: variants$4,
      defaultStyles: {
        width: "300px"
      },
      props: __spreadProps$4(__spreadValues$4(__spreadValues$4({}, getCommonProps("slider", [
        "isDisabled",
        "aria-label"
      ])), getCommonSliderProps()), {
        children: {
          type: "slot",
          defaultValue: [
            {
              type: "hbox",
              styles: {
                width: "stretch",
                justifyContent: "space-between",
                padding: "8px 0px"
              },
              children: [
                {
                  type: "component",
                  name: LABEL_COMPONENT_NAME,
                  props: {
                    children: {
                      type: "text",
                      value: "Label"
                    }
                  }
                },
                {
                  type: "component",
                  name: sliderOutputMeta.name,
                  props: {
                    children: {
                      type: "text",
                      value: "Output"
                    }
                  }
                }
              ]
            },
            {
              type: "component",
              name: sliderTrackMeta.name
            }
          ]
        },
        value: {
          type: "number",
          editOnly: true,
          displayName: "Initial value",
          uncontrolledProp: "defaultValue",
          description: "The initial value of the slider",
          defaultValueHint: 0,
          defaultValue: 0
        },
        onChange: {
          type: "eventHandler",
          argTypes: [{ name: "value", type: "number" }]
        },
        onChangeEnd: {
          type: "eventHandler",
          argTypes: [{ name: "value", type: "number" }]
        }
      }),
      states: {
        value: {
          type: "writable",
          valueProp: "value",
          onChangeProp: "onChange",
          variableType: "number"
        }
      },
      trapsFocus: true
    },
    overrides
  );
}

var __defProp$3 = Object.defineProperty;
var __defProps$3 = Object.defineProperties;
var __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$3.call(b, prop))
      __defNormalProp$3(a, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b)) {
      if (__propIsEnum$3.call(b, prop))
        __defNormalProp$3(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));
var __objRest$2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$3.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$3.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const SWITCH_VARIANTS = [
  "hovered",
  "pressed",
  "focused",
  "focusVisible",
  "selected",
  "disabled",
  "readonly"
];
const { variants: variants$3, withObservedValues: withObservedValues$2 } = pickAriaComponentVariants(SWITCH_VARIANTS);
function BaseSwitch(props) {
  const _a = props, { children, plasmicUpdateVariant } = _a, rest = __objRest$2(_a, ["children", "plasmicUpdateVariant"]);
  return /* @__PURE__ */ React__default.default.createElement(reactAriaComponents.Switch, __spreadProps$3(__spreadValues$3({}, rest), { style: COMMON_STYLES }), ({
    isHovered,
    isPressed,
    isFocused,
    isFocusVisible,
    isSelected,
    isDisabled,
    isReadOnly
  }) => withObservedValues$2(
    children,
    {
      hovered: isHovered,
      pressed: isPressed,
      focused: isFocused,
      focusVisible: isFocusVisible,
      selected: isSelected,
      disabled: isDisabled,
      readonly: isReadOnly
    },
    plasmicUpdateVariant
  ));
}
function registerSwitch(loader, overrides) {
  registerComponentHelper(
    loader,
    BaseSwitch,
    {
      name: makeComponentName("switch"),
      displayName: "Aria Switch",
      importPath: "@plasmicpkgs/react-aria/skinny/registerSwitch",
      importName: "BaseSwitch",
      variants: variants$3,
      defaultStyles: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "flex-start",
        padding: 0
      },
      props: __spreadProps$3(__spreadValues$3({}, getCommonProps("switch", [
        "name",
        "isDisabled",
        "isReadOnly",
        "autoFocus",
        "aria-label"
      ])), {
        children: {
          type: "slot",
          mergeWithParent: true,
          defaultValue: [
            {
              type: "hbox",
              styles: {
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                gap: "10px",
                padding: 0
              },
              children: [
                {
                  // the track
                  type: "hbox",
                  styles: {
                    width: "30px",
                    height: "16px",
                    padding: 0,
                    backgroundColor: "#D5D5D5",
                    cursor: "pointer",
                    borderRadius: "999px"
                  },
                  children: {
                    // the thumb
                    type: "hbox",
                    styles: {
                      width: "12px",
                      height: "12px",
                      position: "absolute",
                      top: "2px",
                      left: "2px",
                      borderRadius: "100%",
                      backgroundColor: "#fff",
                      padding: 0,
                      transitionProperty: "all",
                      transitionDuration: "0.5s",
                      transitionTimingFunction: "ease-in-out"
                    }
                  }
                },
                {
                  // the label
                  type: "component",
                  name: LABEL_COMPONENT_NAME,
                  props: {
                    children: {
                      type: "text",
                      value: "Label"
                    }
                  }
                }
              ]
            },
            {
              type: "component",
              name: DESCRIPTION_COMPONENT_NAME,
              styles: {
                fontSize: "12px"
              },
              props: {
                children: {
                  type: "text",
                  value: "Use the registered variants to see it in action..."
                }
              }
            }
          ]
        },
        value: {
          type: "string",
          description: 'The value of the switch in "selected" state, used when submitting an HTML form.',
          defaultValueHint: "on"
        },
        isSelected: {
          type: "boolean",
          editOnly: true,
          displayName: "Default Selected",
          uncontrolledProp: "defaultSelected",
          description: "Whether the switch should be selected by default",
          defaultValueHint: false
        },
        onChange: {
          type: "eventHandler",
          argTypes: [{ name: "isSelected", type: "boolean" }]
        }
      }),
      states: {
        isSelected: {
          type: "writable",
          valueProp: "isSelected",
          onChangeProp: "onChange",
          variableType: "boolean"
        }
      },
      trapsFocus: true
    },
    overrides
  );
}

var __defProp$2 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b)) {
      if (__propIsEnum$2.call(b, prop))
        __defNormalProp$2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));
var __objRest$1 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const TEXTAREA_VARIANTS = [
  "focused",
  "focusVisible",
  "hovered",
  "disabled"
];
const { variants: variants$2 } = pickAriaComponentVariants(TEXTAREA_VARIANTS);
const inputHelpers = {
  states: {
    value: {
      onChangeArgsToValue: (e) => {
        return e.target.value;
      }
    }
  }
};
function BaseTextArea(props) {
  const _a = props, { className, plasmicUpdateVariant, setControlContextData } = _a, rest = __objRest$1(_a, ["className", "plasmicUpdateVariant", "setControlContextData"]);
  const textFieldContext = React__default.default.useContext(PlasmicTextFieldContext);
  setControlContextData == null ? void 0 : setControlContextData({
    parent: textFieldContext
  });
  const classNameProp = React.useCallback(
    ({
      isDisabled,
      isFocusVisible,
      isFocused,
      isHovered
    }) => {
      plasmicUpdateVariant == null ? void 0 : plasmicUpdateVariant({
        disabled: isDisabled,
        focused: isFocused,
        focusVisible: isFocusVisible,
        hovered: isHovered
      });
      return className != null ? className : "";
    },
    [className, plasmicUpdateVariant]
  );
  const mergedProps = reactAria.mergeProps(rest, {
    className: classNameProp
  });
  return /* @__PURE__ */ React__default.default.createElement(reactAriaComponents.TextArea, __spreadProps$2(__spreadValues$2({}, mergedProps), { style: COMMON_STYLES }));
}
function registerTextArea(loader, overrides) {
  registerComponentHelper(
    loader,
    BaseTextArea,
    {
      name: makeComponentName("textarea"),
      displayName: "Aria TextArea",
      importPath: "@plasmicpkgs/react-aria/skinny/registerTextArea",
      importName: "BaseTextArea",
      variants: variants$2,
      props: __spreadValues$2({}, getCommonProps("Text Area", [
        "name",
        "disabled",
        "readOnly",
        "autoFocus",
        "aria-label",
        "required",
        "placeholder",
        "value",
        "maxLength",
        "minLength",
        "inputMode",
        "onChange",
        "onFocus",
        "onBlur",
        "onKeyDown",
        "onKeyUp",
        "onCopy",
        "onCut",
        "onPaste",
        "onCompositionStart",
        "onCompositionEnd",
        "onCompositionUpdate",
        "onSelect",
        "onBeforeInput",
        "onInput"
      ])),
      states: {
        value: __spreadValues$2({
          type: "writable",
          valueProp: "value",
          onChangeProp: "onChange",
          variableType: "text"
        }, inputHelpers.states.value)
      },
      componentHelpers: {
        helpers: inputHelpers,
        importName: "inputHelpers",
        importPath: "@plasmicpkgs/react-aria/skinny/registerTextArea"
      }
    },
    overrides
  );
}

var __defProp$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const TEXT_FIELD_VARIANTS = ["disabled", "readonly"];
const { variants: variants$1, withObservedValues: withObservedValues$1 } = pickAriaComponentVariants(TEXT_FIELD_VARIANTS);
function BaseTextField(props) {
  const _a = props, { children, plasmicUpdateVariant, autoComplete } = _a, rest = __objRest(_a, ["children", "plasmicUpdateVariant", "autoComplete"]);
  return /* @__PURE__ */ React__default.default.createElement(PlasmicTextFieldContext.Provider, { value: props }, /* @__PURE__ */ React__default.default.createElement(
    reactAriaComponents.TextField,
    __spreadProps$1(__spreadValues$1({
      autoComplete: resolveAutoComplete(autoComplete)
    }, rest), {
      style: COMMON_STYLES
    }),
    ({ isDisabled, isReadOnly }) => withObservedValues$1(
      children,
      {
        disabled: isDisabled,
        readonly: isReadOnly
      },
      plasmicUpdateVariant
    )
  ));
}
const TEXT_FIELD_COMPONENT_NAME = makeComponentName("textField");
function registerTextField(loader, overrides) {
  registerComponentHelper(
    loader,
    BaseTextField,
    {
      name: TEXT_FIELD_COMPONENT_NAME,
      displayName: "Aria TextField",
      importPath: "@plasmicpkgs/react-aria/skinny/registerTextField",
      importName: "BaseTextField",
      variants: variants$1,
      // TODO: Support for validate prop
      props: __spreadProps$1(__spreadValues$1({}, getCommonProps("Text Field", [
        "name",
        "isDisabled",
        "isReadOnly",
        "autoFocus",
        "aria-label",
        "isRequired",
        "value",
        "maxLength",
        "minLength",
        "pattern",
        "type",
        "inputMode",
        "validationBehavior",
        "autoComplete",
        "onChange",
        "onFocus",
        "onBlur",
        "onFocusChange",
        "onKeyDown",
        "onKeyUp",
        "onCopy",
        "onCut",
        "onPaste",
        "onCompositionStart",
        "onCompositionEnd",
        "onCompositionUpdate",
        "onSelect",
        "onBeforeInput",
        "onInput"
      ])), {
        children: {
          type: "slot",
          mergeWithParent: true,
          defaultValue: {
            type: "vbox",
            styles: {
              justifyContent: "flex-start",
              alignItems: "flex-start",
              width: "300px",
              gap: "5px",
              padding: 0
            },
            children: [
              {
                type: "component",
                name: LABEL_COMPONENT_NAME,
                props: {
                  children: {
                    type: "text",
                    value: "Label"
                  }
                }
              },
              {
                type: "component",
                name: INPUT_COMPONENT_NAME,
                styles: {
                  width: "100%"
                }
              },
              {
                type: "component",
                name: DESCRIPTION_COMPONENT_NAME,
                props: {
                  children: {
                    type: "text",
                    value: "Type something..."
                  }
                }
              }
            ]
          }
        },
        isInvalid: {
          // TODO: Not sure if needed
          displayName: "Invalid",
          type: "boolean",
          description: "Whether the input value is invalid",
          defaultValueHint: false
        },
        customValidationErrors: {
          // TODO: Not sure if needed
          type: "array",
          description: "Errors for custom validation"
        }
      }),
      states: {
        value: {
          type: "writable",
          valueProp: "value",
          onChangeProp: "onChange",
          variableType: "text"
        }
      },
      trapsFocus: true
    },
    overrides
  );
}

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const TOOLTIP_VARIANTS = [
  "placementTop",
  "placementBottom",
  "placementLeft",
  "placementRight"
];
const { variants, withObservedValues } = pickAriaComponentVariants(TOOLTIP_VARIANTS);
function TriggerWrapper({ children, className }) {
  const ref = React__default.default.useRef(null);
  const { focusableProps } = reactAria.useFocusable({}, ref);
  return /* @__PURE__ */ React__default.default.createElement(
    "div",
    __spreadProps(__spreadValues({
      ref,
      className
    }, focusableProps), {
      style: COMMON_STYLES
    }),
    children
  );
}
function BaseTooltip(props) {
  var _a, _b, _c;
  const {
    children,
    isDisabled,
    delay,
    closeDelay,
    trigger,
    isOpen,
    defaultOpen,
    tooltipContent,
    resetClassName,
    placement,
    offset,
    crossOffset,
    shouldFlip,
    onOpenChange,
    plasmicUpdateVariant
  } = props;
  const { isSelected, selectedSlotName } = (_b = (_a = host.usePlasmicCanvasComponentInfo) == null ? void 0 : _a(props)) != null ? _b : {};
  const isAutoOpen = selectedSlotName !== "children" && isSelected;
  const _isOpen = (_c = isAutoOpen || isOpen) != null ? _c : false;
  return /* @__PURE__ */ React__default.default.createElement(
    reactAriaComponents.TooltipTrigger,
    {
      isDisabled,
      delay,
      closeDelay,
      trigger,
      isOpen: _isOpen,
      defaultOpen,
      onOpenChange
    },
    /* @__PURE__ */ React__default.default.createElement(TriggerWrapper, { className: resetClassName }, children),
    /* @__PURE__ */ React__default.default.createElement(
      reactAriaComponents.Tooltip,
      {
        isOpen: _isOpen,
        offset,
        crossOffset,
        shouldFlip,
        defaultOpen,
        className: resetClassName,
        onOpenChange,
        placement
      },
      ({ placement: _placement }) => withObservedValues(
        /* @__PURE__ */ React__default.default.createElement(React__default.default.Fragment, null, tooltipContent),
        {
          placementTop: _placement === "top",
          placementBottom: _placement === "bottom",
          placementLeft: _placement === "left",
          placementRight: _placement === "right"
        },
        plasmicUpdateVariant
      )
    )
  );
}
function registerTooltip(loader, overrides) {
  registerComponentHelper(
    loader,
    BaseTooltip,
    {
      name: "plasmic-react-aria-tooltip",
      displayName: "Aria Tooltip",
      importPath: "@plasmicpkgs/react-aria/skinny/registerTooltip",
      importName: "BaseTooltip",
      isAttachment: true,
      styleSections: false,
      variants,
      props: __spreadProps(__spreadValues({
        children: {
          type: "slot",
          mergeWithParent: true,
          displayName: "Trigger",
          defaultValue: {
            type: "text",
            value: "Hover me!",
            styles: {
              width: "hug"
            }
          }
        },
        tooltipContent: {
          type: "slot",
          mergeWithParent: true,
          displayName: "Tooltip Content",
          // NOTE: This is not applied in attachment
          defaultValue: {
            type: "text",
            value: "Hello from Tooltip!",
            styles: {
              background: "black",
              color: "white",
              padding: "7px",
              borderRadius: "7px"
            }
          }
        },
        resetClassName: {
          type: "themeResetClass"
        },
        isDisabled: {
          type: "boolean"
        },
        delay: {
          type: "number",
          // Default value is explicitly set to 0 to prevent users from mistakenly thinking the tooltip isn’t opening due to a delay.
          defaultValue: 0,
          defaultValueHint: 0,
          description: "The delay (in milliseconds) for the tooltip to show up."
        },
        closeDelay: {
          type: "number",
          // Default value is explicitly set to 0 to prevent users from mistakenly thinking the tooltip isn’t closing due to a delay.
          defaultValue: 0,
          defaultValueHint: 0,
          description: "The delay (in milliseconds) for the tooltip to close."
        },
        trigger: {
          type: "choice",
          options: ["focus", "focus and hover"],
          defaultValueHint: "focus and hover"
        }
      }, getCommonOverlayProps("popover", {
        placement: { defaultValueHint: "top" },
        offset: { defaultValueHint: 0 },
        containerPadding: { defaultValueHint: 12 },
        crossOffset: { defaultValueHint: 0 }
      })), {
        isOpen: {
          type: "boolean",
          editOnly: true,
          uncontrolledProp: "defaultOpen",
          description: "Whether the overlay is open by default",
          defaultValueHint: false,
          hidden: () => true
        },
        onOpenChange: {
          type: "eventHandler",
          argTypes: [{ name: "isOpen", type: "boolean" }]
        }
      }),
      states: {
        isOpen: {
          type: "writable",
          valueProp: "isOpen",
          onChangeProp: "onOpenChange",
          variableType: "boolean"
        }
      },
      trapsFocus: true
    },
    overrides
  );
}

function registerAll(loader) {
  registerText(loader);
  registerHeading(loader);
  registerDescription(loader);
  registerDialog(loader);
  registerOverlayArrow(loader);
  registerSelect(loader);
  registerComboBox(loader);
  registerButton(loader);
  registerLabel(loader);
  registerListBox(loader);
  registerPopover(loader);
  registerTextArea(loader);
  registerInput(loader);
  registerSwitch(loader);
  registerCheckbox(loader);
  registerCheckboxGroup(loader);
  registerRadioGroup(loader);
  registerTextField(loader);
  registerModal(loader);
  registerTooltip(loader);
  registerDialogTrigger(loader);
  registerSlider(loader);
}

exports.registerAll = registerAll;
//# sourceMappingURL=react-aria.js.map

{"ast":null,"code":"import _objectSpread from \"C:/Users/rewac/OneDrive/Documents/GitHub/scatch-store.me/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { createListActions as $0d86e9c8f07f9a7b$export$79c0c687a5963b0a } from \"./useListData.mjs\";\nimport { useReducer as $fh1mr$useReducer, useRef as $fh1mr$useRef, useEffect as $fh1mr$useEffect } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $f86e6c1ec7da6ebb$var$reducer(data, action) {\n  let selectedKeys;\n  switch (data.state) {\n    case 'idle':\n    case 'error':\n      switch (action.type) {\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          var _action_filterText, _action_sortDescriptor;\n          return _objectSpread(_objectSpread({}, data), {}, {\n            filterText: (_action_filterText = action.filterText) !== null && _action_filterText !== void 0 ? _action_filterText : data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            sortDescriptor: (_action_sortDescriptor = action.sortDescriptor) !== null && _action_sortDescriptor !== void 0 ? _action_sortDescriptor : data.sortDescriptor,\n            abortController: action.abortController\n          });\n        case 'update':\n          var _action_updater;\n          return _objectSpread(_objectSpread({}, data), (_action_updater = action.updater) === null || _action_updater === void 0 ? void 0 : _action_updater.call(action, data));\n        case 'success':\n        case 'error':\n          return data;\n        default:\n          throw new Error(\"Invalid action \\\"\".concat(action.type, \"\\\" in state \\\"\").concat(data.state, \"\\\"\"));\n      }\n    case 'loading':\n    case 'sorting':\n    case 'filtering':\n      switch (action.type) {\n        case 'success':\n          // Ignore if there is a newer abortcontroller in state.\n          // This means that multiple requests were going at once.\n          // We want to take only the latest result.\n          if (action.abortController !== data.abortController) return data;\n          var _action_selectedKeys;\n          selectedKeys = (_action_selectedKeys = action.selectedKeys) !== null && _action_selectedKeys !== void 0 ? _action_selectedKeys : data.selectedKeys;\n          var _action_filterText1, _action_items, _action_sortDescriptor1;\n          return _objectSpread(_objectSpread({}, data), {}, {\n            filterText: (_action_filterText1 = action.filterText) !== null && _action_filterText1 !== void 0 ? _action_filterText1 : data.filterText,\n            state: 'idle',\n            items: [...((_action_items = action.items) !== null && _action_items !== void 0 ? _action_items : [])],\n            selectedKeys: selectedKeys === 'all' ? 'all' : new Set(selectedKeys),\n            sortDescriptor: (_action_sortDescriptor1 = action.sortDescriptor) !== null && _action_sortDescriptor1 !== void 0 ? _action_sortDescriptor1 : data.sortDescriptor,\n            abortController: undefined,\n            cursor: action.cursor\n          });\n        case 'error':\n          if (action.abortController !== data.abortController) return data;\n          return _objectSpread(_objectSpread({}, data), {}, {\n            state: 'error',\n            error: action.error,\n            abortController: undefined\n          });\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          var\n          // We're already loading, and another load was triggered at the same time.\n          // We need to abort the previous load and start a new one.\n          _data_abortController;\n          (_data_abortController = data.abortController) === null || _data_abortController === void 0 ? void 0 : _data_abortController.abort();\n          var _action_filterText2;\n          return _objectSpread(_objectSpread({}, data), {}, {\n            filterText: (_action_filterText2 = action.filterText) !== null && _action_filterText2 !== void 0 ? _action_filterText2 : data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          });\n        case 'update':\n          var _action_updater1;\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return _objectSpread(_objectSpread({}, data), (_action_updater1 = action.updater) === null || _action_updater1 === void 0 ? void 0 : _action_updater1.call(action, data));\n        default:\n          throw new Error(\"Invalid action \\\"\".concat(action.type, \"\\\" in state \\\"\").concat(data.state, \"\\\"\"));\n      }\n    case 'loadingMore':\n      switch (action.type) {\n        case 'success':\n          var _action_selectedKeys1;\n          selectedKeys = data.selectedKeys === 'all' || action.selectedKeys === 'all' ? 'all' : new Set([...data.selectedKeys, ...((_action_selectedKeys1 = action.selectedKeys) !== null && _action_selectedKeys1 !== void 0 ? _action_selectedKeys1 : [])]);\n          var _action_items1, _action_sortDescriptor2;\n          // Append the new items\n          return _objectSpread(_objectSpread({}, data), {}, {\n            state: 'idle',\n            items: [...data.items, ...((_action_items1 = action.items) !== null && _action_items1 !== void 0 ? _action_items1 : [])],\n            selectedKeys: selectedKeys,\n            sortDescriptor: (_action_sortDescriptor2 = action.sortDescriptor) !== null && _action_sortDescriptor2 !== void 0 ? _action_sortDescriptor2 : data.sortDescriptor,\n            abortController: undefined,\n            cursor: action.cursor\n          });\n        case 'error':\n          if (action.abortController !== data.abortController) return data;\n          return _objectSpread(_objectSpread({}, data), {}, {\n            state: 'error',\n            error: action.error\n          });\n        case 'loading':\n        case 'sorting':\n        case 'filtering':\n          var\n          // We're already loading more, and another load was triggered at the same time.\n          // We need to abort the previous load more and start a new one.\n          _data_abortController1;\n          (_data_abortController1 = data.abortController) === null || _data_abortController1 === void 0 ? void 0 : _data_abortController1.abort();\n          var _action_filterText3;\n          return _objectSpread(_objectSpread({}, data), {}, {\n            filterText: (_action_filterText3 = action.filterText) !== null && _action_filterText3 !== void 0 ? _action_filterText3 : data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          });\n        case 'loadingMore':\n          var\n          // If already loading more and another loading more is triggered, abort the new load more since\n          // it is a duplicate request since the cursor hasn't been updated.\n          // Do not overwrite the data.abortController\n          _action_abortController;\n          (_action_abortController = action.abortController) === null || _action_abortController === void 0 ? void 0 : _action_abortController.abort();\n          return data;\n        case 'update':\n          var _action_updater2;\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return _objectSpread(_objectSpread({}, data), (_action_updater2 = action.updater) === null || _action_updater2 === void 0 ? void 0 : _action_updater2.call(action, data));\n        default:\n          throw new Error(\"Invalid action \\\"\".concat(action.type, \"\\\" in state \\\"\").concat(data.state, \"\\\"\"));\n      }\n    default:\n      throw new Error(\"Invalid state \\\"\".concat(data.state, \"\\\"\"));\n  }\n}\nfunction $f86e6c1ec7da6ebb$export$bc3384a35de93d66(options) {\n  const {\n    load: load,\n    sort: sort,\n    initialSelectedKeys: initialSelectedKeys,\n    initialSortDescriptor: initialSortDescriptor,\n    getKey = item => item.id || item.key,\n    initialFilterText = ''\n  } = options;\n  let [data, dispatch] = (0, $fh1mr$useReducer)($f86e6c1ec7da6ebb$var$reducer, {\n    state: 'idle',\n    error: undefined,\n    items: [],\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys),\n    sortDescriptor: initialSortDescriptor,\n    filterText: initialFilterText\n  });\n  const dispatchFetch = async (action, fn) => {\n    let abortController = new AbortController();\n    try {\n      dispatch(_objectSpread(_objectSpread({}, action), {}, {\n        abortController: abortController\n      }));\n      var _action_filterText;\n      let previousFilterText = (_action_filterText = action.filterText) !== null && _action_filterText !== void 0 ? _action_filterText : data.filterText;\n      var _action_sortDescriptor;\n      let response = await fn({\n        items: data.items.slice(),\n        selectedKeys: data.selectedKeys,\n        sortDescriptor: (_action_sortDescriptor = action.sortDescriptor) !== null && _action_sortDescriptor !== void 0 ? _action_sortDescriptor : data.sortDescriptor,\n        signal: abortController.signal,\n        cursor: action.type === 'loadingMore' ? data.cursor : undefined,\n        filterText: previousFilterText\n      });\n      var _response_filterText;\n      let filterText = (_response_filterText = response.filterText) !== null && _response_filterText !== void 0 ? _response_filterText : previousFilterText;\n      dispatch(_objectSpread(_objectSpread({\n        type: 'success'\n      }, response), {}, {\n        abortController: abortController\n      }));\n      // Fetch a new filtered list if filterText is updated via `load` response func rather than list.setFilterText\n      // Only do this if not aborted (e.g. user triggers another filter action before load completes)\n      if (filterText && filterText !== previousFilterText && !abortController.signal.aborted) dispatchFetch({\n        type: 'filtering',\n        filterText: filterText\n      }, load);\n    } catch (e) {\n      dispatch({\n        type: 'error',\n        error: e,\n        abortController: abortController\n      });\n    }\n  };\n  let didDispatchInitialFetch = (0, $fh1mr$useRef)(false);\n  (0, $fh1mr$useEffect)(() => {\n    if (!didDispatchInitialFetch.current) {\n      dispatchFetch({\n        type: 'loading'\n      }, load);\n      didDispatchInitialFetch.current = true;\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return _objectSpread(_objectSpread({\n    items: data.items,\n    selectedKeys: data.selectedKeys,\n    sortDescriptor: data.sortDescriptor,\n    isLoading: data.state === 'loading' || data.state === 'loadingMore' || data.state === 'sorting' || data.state === 'filtering',\n    loadingState: data.state,\n    error: data.error,\n    filterText: data.filterText,\n    getItem(key) {\n      return data.items.find(item => getKey(item) === key);\n    },\n    reload() {\n      dispatchFetch({\n        type: 'loading'\n      }, load);\n    },\n    loadMore() {\n      // Ignore if already loading more or if performing server side filtering.\n      if (data.state === 'loadingMore' || data.state === 'filtering' || data.cursor == null) return;\n      dispatchFetch({\n        type: 'loadingMore'\n      }, load);\n    },\n    sort(sortDescriptor) {\n      dispatchFetch({\n        type: 'sorting',\n        sortDescriptor: sortDescriptor\n      }, sort || load);\n    }\n  }, (0, $0d86e9c8f07f9a7b$export$79c0c687a5963b0a)(_objectSpread(_objectSpread({}, options), {}, {\n    getKey: getKey,\n    cursor: data.cursor\n  }), fn => {\n    dispatch({\n      type: 'update',\n      updater: fn\n    });\n  })), {}, {\n    setFilterText(filterText) {\n      dispatchFetch({\n        type: 'filtering',\n        filterText: filterText\n      }, load);\n    }\n  });\n}\nexport { $f86e6c1ec7da6ebb$export$bc3384a35de93d66 as useAsyncList };","map":{"version":3,"names":["$f86e6c1ec7da6ebb$var$reducer","data","action","selectedKeys","state","type","_action_filterText","_action_sortDescriptor","_objectSpread","filterText","items","sortDescriptor","abortController","_action_updater","updater","call","Error","concat","_action_selectedKeys","_action_filterText1","_action_items","_action_sortDescriptor1","Set","undefined","cursor","error","_data_abortController","abort","_action_filterText2","_action_updater1","_action_selectedKeys1","_action_items1","_action_sortDescriptor2","_data_abortController1","_action_filterText3","_action_abortController","_action_updater2","$f86e6c1ec7da6ebb$export$bc3384a35de93d66","options","load","sort","initialSelectedKeys","initialSortDescriptor","getKey","item","id","key","initialFilterText","dispatch","$fh1mr$useReducer","dispatchFetch","fn","AbortController","previousFilterText","response","slice","signal","_response_filterText","aborted","e","didDispatchInitialFetch","$fh1mr$useRef","$fh1mr$useEffect","current","isLoading","loadingState","getItem","find","reload","loadMore","$0d86e9c8f07f9a7b$export$79c0c687a5963b0a","setFilterText"],"sources":["C:\\Users\\rewac\\OneDrive\\Documents\\GitHub\\scatch-store.me\\node_modules\\@react-stately\\data\\dist\\packages\\@react-stately\\data\\src\\useAsyncList.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {createListActions, ListData, ListState} from './useListData';\nimport {Key, LoadingState, Selection, SortDescriptor} from '@react-types/shared';\nimport {useEffect, useReducer, useRef} from 'react';\n\nexport interface AsyncListOptions<T, C> {\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: Iterable<Key>,\n  /** The initial sort descriptor. */\n  initialSortDescriptor?: SortDescriptor,\n  /** The initial filter text. */\n  initialFilterText?: string,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that loads the data for the items in the list. */\n  load: AsyncListLoadFunction<T, C>,\n  /**\n   * An optional function that performs sorting. If not provided,\n   * then `sortDescriptor` is passed to the `load` function.\n   */\n  sort?: AsyncListLoadFunction<T, C, AsyncListLoadOptions<T, C> & {sortDescriptor: SortDescriptor}>\n}\n\ntype AsyncListLoadFunction<T, C, S extends AsyncListLoadOptions<T, C> = AsyncListLoadOptions<T, C>> = (state: S) => AsyncListStateUpdate<T, C> | Promise<AsyncListStateUpdate<T, C>>;\n\ninterface AsyncListLoadOptions<T, C> {\n  /** The items currently in the list. */\n  items: T[],\n  /** The keys of the currently selected items in the list. */\n  selectedKeys: Selection,\n  /** The current sort descriptor for the list. */\n  sortDescriptor?: SortDescriptor,\n  /** An abort signal used to notify the load function that the request has been aborted. */\n  signal: AbortSignal,\n  /** The pagination cursor returned from the last page load. */\n  cursor?: C,\n  /** The current filter text used to perform server side filtering. */\n  filterText?: string,\n  /** The current loading state of the list. */\n  loadingState?: LoadingState\n}\n\ninterface AsyncListStateUpdate<T, C> {\n  /** The new items to append to the list. */\n  items: Iterable<T>,\n  /** The keys to add to the selection. */\n  selectedKeys?: Iterable<Key>,\n  /** The sort descriptor to set. */\n  sortDescriptor?: SortDescriptor,\n  /** The pagination cursor to be used for the next page load. */\n  cursor?: C,\n  /** The updated filter text for the list. */\n  filterText?: string\n}\n\ninterface AsyncListState<T, C> extends ListState<T> {\n  state: LoadingState,\n  items: T[],\n  // disabledKeys?: Iterable<Key>,\n  selectedKeys: Selection,\n  // selectedKey?: Key,\n  // expandedKeys?: Iterable<Key>,\n  sortDescriptor?: SortDescriptor,\n  error?: Error,\n  abortController?: AbortController,\n  cursor?: C\n}\n\ntype ActionType = 'success' | 'error' | 'loading' | 'loadingMore' | 'sorting' | 'update' | 'filtering';\ninterface Action<T, C> {\n  type: ActionType,\n  items?: Iterable<T>,\n  selectedKeys?: Iterable<Key>,\n  sortDescriptor?: SortDescriptor,\n  error?: Error,\n  abortController?: AbortController,\n  updater?: (state: ListState<T>) => ListState<T>,\n  cursor?: C,\n  filterText?: string\n}\n\nexport interface AsyncListData<T> extends ListData<T> {\n  /** Whether data is currently being loaded. */\n  isLoading: boolean,\n  /** If loading data failed, then this contains the error that occurred. */\n  error?: Error,\n  // disabledKeys?: Set<Key>,\n  // selectedKey?: Key,\n  // expandedKeys?: Set<Key>,\n  /** The current sort descriptor for the list. */\n  sortDescriptor?: SortDescriptor,\n\n  /** Reloads the data in the list. */\n  reload(): void,\n  /** Loads the next page of data in the list. */\n  loadMore(): void,\n  /** Triggers sorting for the list. */\n  sort(descriptor: SortDescriptor): void,\n  /** The current loading state for the list. */\n  loadingState: LoadingState\n}\n\nfunction reducer<T, C>(data: AsyncListState<T, C>, action: Action<T, C>): AsyncListState<T, C> {\n  let selectedKeys;\n  switch (data.state) {\n    case 'idle':\n    case 'error':\n      switch (action.type) {\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: action.abortController\n          };\n        case 'update':\n          return {\n            ...data,\n            ...action.updater?.(data)\n          };\n        case 'success':\n        case 'error':\n          return data;\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    case 'loading':\n    case 'sorting':\n    case 'filtering':\n      switch (action.type) {\n        case 'success':\n          // Ignore if there is a newer abortcontroller in state.\n          // This means that multiple requests were going at once.\n          // We want to take only the latest result.\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          selectedKeys = action.selectedKeys ?? data.selectedKeys;\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: 'idle',\n            items: [...(action.items) ?? []],\n            selectedKeys: selectedKeys === 'all' ? 'all' : new Set(selectedKeys),\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: undefined,\n            cursor: action.cursor\n          };\n        case 'error':\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          return {\n            ...data,\n            state: 'error',\n            error: action.error,\n            abortController: undefined\n          };\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading, and another load was triggered at the same time.\n          // We need to abort the previous load and start a new one.\n          data.abortController?.abort();\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          };\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return {\n            ...data,\n            ...action.updater?.(data)\n          };\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    case 'loadingMore':\n      switch (action.type) {\n        case 'success':\n          selectedKeys = (data.selectedKeys === 'all' || action.selectedKeys === 'all')\n            ? 'all'\n            : new Set([...data.selectedKeys, ...(action.selectedKeys ?? [])]);\n          // Append the new items\n          return {\n            ...data,\n            state: 'idle',\n            items: [...data.items, ...(action.items ?? [])],\n            selectedKeys,\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: undefined,\n            cursor: action.cursor\n          };\n        case 'error':\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          return {\n            ...data,\n            state: 'error',\n            error: action.error\n          };\n        case 'loading':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading more, and another load was triggered at the same time.\n          // We need to abort the previous load more and start a new one.\n          data.abortController?.abort();\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          };\n        case 'loadingMore':\n          // If already loading more and another loading more is triggered, abort the new load more since\n          // it is a duplicate request since the cursor hasn't been updated.\n          // Do not overwrite the data.abortController\n          action.abortController?.abort();\n\n          return data;\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return {\n            ...data,\n            ...action.updater?.(data)\n          };\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    default:\n      throw new Error(`Invalid state \"${data.state}\"`);\n  }\n}\n\n/**\n * Manages state for an immutable async loaded list data structure, and provides convenience methods to\n * update the data over time. Manages loading and error states, pagination, and sorting.\n */\nexport function useAsyncList<T, C = string>(options: AsyncListOptions<T, C>): AsyncListData<T> {\n  const {\n    load,\n    sort,\n    initialSelectedKeys,\n    initialSortDescriptor,\n    getKey = (item: any) => item.id || item.key,\n    initialFilterText = ''\n  } = options;\n\n  let [data, dispatch] = useReducer<AsyncListState<T, C>, [Action<T, C>]>(reducer, {\n    state: 'idle',\n    error: undefined,\n    items: [],\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys),\n    sortDescriptor: initialSortDescriptor,\n    filterText: initialFilterText\n  });\n\n  const dispatchFetch = async (action: Action<T, C>, fn: AsyncListLoadFunction<T, C>) => {\n    let abortController = new AbortController();\n    try {\n      dispatch({...action, abortController});\n      let previousFilterText = action.filterText ?? data.filterText;\n\n      let response = await fn({\n        items: data.items.slice(),\n        selectedKeys: data.selectedKeys,\n        sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n        signal: abortController.signal,\n        cursor: action.type === 'loadingMore' ? data.cursor : undefined,\n        filterText: previousFilterText\n      });\n\n      let filterText = response.filterText ?? previousFilterText;\n      dispatch({type: 'success', ...response, abortController});\n\n      // Fetch a new filtered list if filterText is updated via `load` response func rather than list.setFilterText\n      // Only do this if not aborted (e.g. user triggers another filter action before load completes)\n      if (filterText && (filterText !== previousFilterText) && !abortController.signal.aborted) {\n        dispatchFetch({type: 'filtering', filterText}, load);\n      }\n    } catch (e) {\n      dispatch({type: 'error', error: e as Error, abortController});\n    }\n  };\n\n  let didDispatchInitialFetch = useRef(false);\n  useEffect(() => {\n    if (!didDispatchInitialFetch.current) {\n      dispatchFetch({type: 'loading'}, load);\n      didDispatchInitialFetch.current = true;\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return {\n    items: data.items,\n    selectedKeys: data.selectedKeys,\n    sortDescriptor: data.sortDescriptor,\n    isLoading: data.state === 'loading' || data.state === 'loadingMore' || data.state === 'sorting' || data.state === 'filtering',\n    loadingState: data.state,\n    error: data.error,\n    filterText: data.filterText,\n    getItem(key: Key) {\n      return data.items.find(item => getKey(item) === key);\n    },\n    reload() {\n      dispatchFetch({type: 'loading'}, load);\n    },\n    loadMore() {\n      // Ignore if already loading more or if performing server side filtering.\n      if (data.state === 'loadingMore' || data.state === 'filtering' || data.cursor == null) {\n        return;\n      }\n\n      dispatchFetch({type: 'loadingMore'}, load);\n    },\n    sort(sortDescriptor: SortDescriptor) {\n      dispatchFetch({type: 'sorting', sortDescriptor}, (sort || load) as AsyncListLoadFunction<T, C>);\n    },\n    ...createListActions({...options, getKey, cursor: data.cursor}, fn => {\n      dispatch({type: 'update', updater: fn});\n    }),\n    setFilterText(filterText: string) {\n      dispatchFetch({type: 'filtering', filterText}, load);\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _objectSpread from \"C:/Users/rewac/OneDrive/Documents/GitHub/scatch-store.me/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"C:/Users/rewac/OneDrive/Documents/GitHub/scatch-store.me/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"itemProps\"];\nimport { getRowId as $ce9b18daab526bbd$export$f45c25170b9a99c2, listMap as $ce9b18daab526bbd$export$5b9bb410392e3991 } from \"./utils.mjs\";\nimport { useSlotId as $lxFUG$useSlotId, chain as $lxFUG$chain, scrollIntoViewport as $lxFUG$scrollIntoViewport, getScrollParent as $lxFUG$getScrollParent, useSyntheticLinkProps as $lxFUG$useSyntheticLinkProps, mergeProps as $lxFUG$mergeProps } from \"@react-aria/utils\";\nimport { focusSafely as $lxFUG$focusSafely, getFocusableTreeWalker as $lxFUG$getFocusableTreeWalker } from \"@react-aria/focus\";\nimport { getLastItem as $lxFUG$getLastItem } from \"@react-stately/collections\";\nimport { useRef as $lxFUG$useRef } from \"react\";\nimport { isFocusVisible as $lxFUG$isFocusVisible } from \"@react-aria/interactions\";\nimport { useSelectableItem as $lxFUG$useSelectableItem } from \"@react-aria/selection\";\nimport { useLocale as $lxFUG$useLocale } from \"@react-aria/i18n\";\n\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nconst $4e8b0456ef72939f$var$EXPANSION_KEYS = {\n  'expand': {\n    ltr: 'ArrowRight',\n    rtl: 'ArrowLeft'\n  },\n  'collapse': {\n    ltr: 'ArrowLeft',\n    rtl: 'ArrowRight'\n  }\n};\nfunction $4e8b0456ef72939f$export$9610e69494fadfd2(props, state, ref) {\n  var _node_props, _node_props1;\n  // Copied from useGridCell + some modifications to make it not so grid specific\n  let {\n    node: node,\n    isVirtualized: isVirtualized,\n    shouldSelectOnPressUp: shouldSelectOnPressUp\n  } = props;\n  // let stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/gridlist');\n  let {\n    direction: direction\n  } = (0, $lxFUG$useLocale)();\n  let {\n    onAction: onAction,\n    linkBehavior: linkBehavior,\n    keyboardNavigationBehavior: keyboardNavigationBehavior\n  } = (0, $ce9b18daab526bbd$export$5b9bb410392e3991).get(state);\n  let descriptionId = (0, $lxFUG$useSlotId)();\n  // We need to track the key of the item at the time it was last focused so that we force\n  // focus to go to the item when the DOM node is reused for a different item in a virtualizer.\n  let keyWhenFocused = (0, $lxFUG$useRef)(null);\n  let focus = () => {\n    var _ref_current;\n    // Don't shift focus to the row if the active element is a element within the row already\n    // (e.g. clicking on a row button)\n    if (ref.current !== null && (keyWhenFocused.current != null && node.key !== keyWhenFocused.current || !((_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.contains(document.activeElement)))) (0, $lxFUG$focusSafely)(ref.current);\n  };\n  let treeGridRowProps = {};\n  let hasChildRows;\n  let hasLink = state.selectionManager.isLink(node.key);\n  if (node != null && 'expandedKeys' in state) {\n    var _state_collection_getChildren, _state_collection, _filter_at;\n    // TODO: ideally node.hasChildNodes would be a way to tell if a row has child nodes, but the row's contents make it so that value is always\n    // true...\n    let children = (_state_collection_getChildren = (_state_collection = state.collection).getChildren) === null || _state_collection_getChildren === void 0 ? void 0 : _state_collection_getChildren.call(_state_collection, node.key);\n    hasChildRows = [...(children !== null && children !== void 0 ? children : [])].length > 1;\n    if (onAction == null && !hasLink && state.selectionManager.selectionMode === 'none' && hasChildRows) onAction = () => state.toggleKey(node.key);\n    let isExpanded = hasChildRows ? state.expandedKeys.has(node.key) : undefined;\n    let setSize = 1;\n    var _filter_at_index;\n    if (node.level > 0 && (node === null || node === void 0 ? void 0 : node.parentKey) != null) {\n      let parent = state.collection.getItem(node.parentKey);\n      if (parent) {\n        var _state_collection_getChildren1, _state_collection1;\n        // siblings must exist because our original node exists, same with lastItem\n        let siblings = (_state_collection_getChildren1 = (_state_collection1 = state.collection).getChildren) === null || _state_collection_getChildren1 === void 0 ? void 0 : _state_collection_getChildren1.call(_state_collection1, parent.key);\n        setSize = (0, $lxFUG$getLastItem)(siblings).index + 1;\n      }\n    } else setSize = ((_filter_at_index = (_filter_at = [...state.collection].filter(row => row.level === 0).at(-1)) === null || _filter_at === void 0 ? void 0 : _filter_at.index) !== null && _filter_at_index !== void 0 ? _filter_at_index : 0) + 1;\n    treeGridRowProps = {\n      'aria-expanded': isExpanded,\n      'aria-level': node.level + 1,\n      'aria-posinset': (node === null || node === void 0 ? void 0 : node.index) + 1,\n      'aria-setsize': setSize\n    };\n  }\n  let _ref = (0, $lxFUG$useSelectableItem)({\n      selectionManager: state.selectionManager,\n      key: node.key,\n      ref: ref,\n      isVirtualized: isVirtualized,\n      shouldSelectOnPressUp: shouldSelectOnPressUp,\n      onAction: onAction || ((_node_props = node.props) === null || _node_props === void 0 ? void 0 : _node_props.onAction) ? (0, $lxFUG$chain)((_node_props1 = node.props) === null || _node_props1 === void 0 ? void 0 : _node_props1.onAction, onAction ? () => onAction(node.key) : undefined) : undefined,\n      focus: focus,\n      linkBehavior: linkBehavior\n    }),\n    {\n      itemProps: itemProps\n    } = _ref,\n    itemStates = _objectWithoutProperties(_ref, _excluded);\n  let onKeyDown = e => {\n    if (!e.currentTarget.contains(e.target) || !ref.current || !document.activeElement) return;\n    let walker = (0, $lxFUG$getFocusableTreeWalker)(ref.current);\n    walker.currentNode = document.activeElement;\n    if ('expandedKeys' in state && document.activeElement === ref.current) {\n      if (e.key === $4e8b0456ef72939f$var$EXPANSION_KEYS['expand'][direction] && state.selectionManager.focusedKey === node.key && hasChildRows && !state.expandedKeys.has(node.key)) {\n        state.toggleKey(node.key);\n        e.stopPropagation();\n        return;\n      } else if (e.key === $4e8b0456ef72939f$var$EXPANSION_KEYS['collapse'][direction] && state.selectionManager.focusedKey === node.key && hasChildRows && state.expandedKeys.has(node.key)) {\n        state.toggleKey(node.key);\n        e.stopPropagation();\n        return;\n      }\n    }\n    switch (e.key) {\n      case 'ArrowLeft':\n        if (keyboardNavigationBehavior === 'arrow') {\n          // Find the next focusable element within the row.\n          let focusable = direction === 'rtl' ? walker.nextNode() : walker.previousNode();\n          if (focusable) {\n            e.preventDefault();\n            e.stopPropagation();\n            (0, $lxFUG$focusSafely)(focusable);\n            (0, $lxFUG$scrollIntoViewport)(focusable, {\n              containingElement: (0, $lxFUG$getScrollParent)(ref.current)\n            });\n          } else {\n            // If there is no next focusable child, then return focus back to the row\n            e.preventDefault();\n            e.stopPropagation();\n            if (direction === 'rtl') {\n              (0, $lxFUG$focusSafely)(ref.current);\n              (0, $lxFUG$scrollIntoViewport)(ref.current, {\n                containingElement: (0, $lxFUG$getScrollParent)(ref.current)\n              });\n            } else {\n              walker.currentNode = ref.current;\n              let lastElement = $4e8b0456ef72939f$var$last(walker);\n              if (lastElement) {\n                (0, $lxFUG$focusSafely)(lastElement);\n                (0, $lxFUG$scrollIntoViewport)(lastElement, {\n                  containingElement: (0, $lxFUG$getScrollParent)(ref.current)\n                });\n              }\n            }\n          }\n        }\n        break;\n      case 'ArrowRight':\n        if (keyboardNavigationBehavior === 'arrow') {\n          let focusable = direction === 'rtl' ? walker.previousNode() : walker.nextNode();\n          if (focusable) {\n            e.preventDefault();\n            e.stopPropagation();\n            (0, $lxFUG$focusSafely)(focusable);\n            (0, $lxFUG$scrollIntoViewport)(focusable, {\n              containingElement: (0, $lxFUG$getScrollParent)(ref.current)\n            });\n          } else {\n            e.preventDefault();\n            e.stopPropagation();\n            if (direction === 'ltr') {\n              (0, $lxFUG$focusSafely)(ref.current);\n              (0, $lxFUG$scrollIntoViewport)(ref.current, {\n                containingElement: (0, $lxFUG$getScrollParent)(ref.current)\n              });\n            } else {\n              walker.currentNode = ref.current;\n              let lastElement = $4e8b0456ef72939f$var$last(walker);\n              if (lastElement) {\n                (0, $lxFUG$focusSafely)(lastElement);\n                (0, $lxFUG$scrollIntoViewport)(lastElement, {\n                  containingElement: (0, $lxFUG$getScrollParent)(ref.current)\n                });\n              }\n            }\n          }\n        }\n        break;\n      case 'ArrowUp':\n      case 'ArrowDown':\n        // Prevent this event from reaching row children, e.g. menu buttons. We want arrow keys to navigate\n        // to the row above/below instead. We need to re-dispatch the event from a higher parent so it still\n        // bubbles and gets handled by useSelectableCollection.\n        if (!e.altKey && ref.current.contains(e.target)) {\n          var _ref_current_parentElement;\n          e.stopPropagation();\n          e.preventDefault();\n          (_ref_current_parentElement = ref.current.parentElement) === null || _ref_current_parentElement === void 0 ? void 0 : _ref_current_parentElement.dispatchEvent(new KeyboardEvent(e.nativeEvent.type, e.nativeEvent));\n        }\n        break;\n      case 'Tab':\n        if (keyboardNavigationBehavior === 'tab') {\n          // If there is another focusable element within this item, stop propagation so the tab key\n          // is handled by the browser and not by useSelectableCollection (which would take us out of the list).\n          let walker = (0, $lxFUG$getFocusableTreeWalker)(ref.current, {\n            tabbable: true\n          });\n          walker.currentNode = document.activeElement;\n          let next = e.shiftKey ? walker.previousNode() : walker.nextNode();\n          if (next) e.stopPropagation();\n        }\n    }\n  };\n  let onFocus = e => {\n    keyWhenFocused.current = node.key;\n    if (e.target !== ref.current) {\n      // useSelectableItem only handles setting the focused key when\n      // the focused element is the row itself. We also want to\n      // set the focused key when a child element receives focus.\n      // If focus is currently visible (e.g. the user is navigating with the keyboard),\n      // then skip this. We want to restore focus to the previously focused row\n      // in that case since the list should act like a single tab stop.\n      if (!(0, $lxFUG$isFocusVisible)()) state.selectionManager.setFocusedKey(node.key);\n      return;\n    }\n  };\n  let syntheticLinkProps = (0, $lxFUG$useSyntheticLinkProps)(node.props);\n  let linkProps = itemStates.hasAction ? syntheticLinkProps : {};\n  // TODO: re-add when we get translations and fix this for iOS VO\n  // let rowAnnouncement;\n  // if (onAction) {\n  //   rowAnnouncement = stringFormatter.format('hasActionAnnouncement');\n  // } else if (hasLink) {\n  //   rowAnnouncement = stringFormatter.format('hasLinkAnnouncement', {\n  //     link: node.props.href\n  //   });\n  // }\n  let rowProps = (0, $lxFUG$mergeProps)(itemProps, linkProps, {\n    role: 'row',\n    onKeyDownCapture: onKeyDown,\n    onFocus: onFocus,\n    // 'aria-label': [(node.textValue || undefined), rowAnnouncement].filter(Boolean).join(', '),\n    'aria-label': node.textValue || undefined,\n    'aria-selected': state.selectionManager.canSelectItem(node.key) ? state.selectionManager.isSelected(node.key) : undefined,\n    'aria-disabled': state.selectionManager.isDisabled(node.key) || undefined,\n    'aria-labelledby': descriptionId && node.textValue ? \"\".concat((0, $ce9b18daab526bbd$export$f45c25170b9a99c2)(state, node.key), \" \").concat(descriptionId) : undefined,\n    id: (0, $ce9b18daab526bbd$export$f45c25170b9a99c2)(state, node.key)\n  });\n  if (isVirtualized) rowProps['aria-rowindex'] = node.index + 1;\n  let gridCellProps = {\n    role: 'gridcell',\n    'aria-colindex': 1\n  };\n  // TODO: should isExpanded and hasChildRows be a item state that gets returned by the hook?\n  return _objectSpread({\n    rowProps: _objectSpread({}, (0, $lxFUG$mergeProps)(rowProps, treeGridRowProps)),\n    gridCellProps: gridCellProps,\n    descriptionProps: {\n      id: descriptionId\n    }\n  }, itemStates);\n}\nfunction $4e8b0456ef72939f$var$last(walker) {\n  let next = null;\n  let last = null;\n  do {\n    last = walker.lastChild();\n    if (last) next = last;\n  } while (last);\n  return next;\n}\nexport { $4e8b0456ef72939f$export$9610e69494fadfd2 as useGridListItem };","map":{"version":3,"names":["$4e8b0456ef72939f$var$EXPANSION_KEYS","ltr","rtl","$4e8b0456ef72939f$export$9610e69494fadfd2","props","state","ref","_node_props","_node_props1","node","isVirtualized","shouldSelectOnPressUp","direction","$lxFUG$useLocale","onAction","linkBehavior","keyboardNavigationBehavior","$ce9b18daab526bbd$export$5b9bb410392e3991","get","descriptionId","$lxFUG$useSlotId","keyWhenFocused","$lxFUG$useRef","focus","_ref_current","current","key","contains","document","activeElement","$lxFUG$focusSafely","treeGridRowProps","hasChildRows","hasLink","selectionManager","isLink","_state_collection_getChildren","_state_collection","_filter_at","children","collection","getChildren","call","length","selectionMode","toggleKey","isExpanded","expandedKeys","has","undefined","setSize","_filter_at_index","level","parentKey","parent","getItem","_state_collection_getChildren1","_state_collection1","siblings","$lxFUG$getLastItem","index","filter","row","at","_ref","$lxFUG$useSelectableItem","$lxFUG$chain","itemProps","itemStates","_objectWithoutProperties","_excluded","onKeyDown","e","currentTarget","target","walker","$lxFUG$getFocusableTreeWalker","currentNode","focusedKey","stopPropagation","focusable","nextNode","previousNode","preventDefault","$lxFUG$scrollIntoViewport","containingElement","$lxFUG$getScrollParent","lastElement","$4e8b0456ef72939f$var$last","altKey","_ref_current_parentElement","parentElement","dispatchEvent","KeyboardEvent","nativeEvent","type","tabbable","next","shiftKey","onFocus","$lxFUG$isFocusVisible","setFocusedKey","syntheticLinkProps","$lxFUG$useSyntheticLinkProps","linkProps","hasAction","rowProps","$lxFUG$mergeProps","role","onKeyDownCapture","textValue","canSelectItem","isSelected","isDisabled","concat","$ce9b18daab526bbd$export$f45c25170b9a99c2","id","gridCellProps","_objectSpread","descriptionProps","last","lastChild"],"sources":["C:\\Users\\rewac\\OneDrive\\Documents\\GitHub\\scatch-store.me\\node_modules\\@react-aria\\gridlist\\dist\\packages\\@react-aria\\gridlist\\src\\useGridListItem.ts"],"sourcesContent":["/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {chain, getScrollParent, mergeProps, scrollIntoViewport, useSlotId, useSyntheticLinkProps} from '@react-aria/utils';\nimport {DOMAttributes, FocusableElement, Key, RefObject, Node as RSNode} from '@react-types/shared';\nimport {focusSafely, getFocusableTreeWalker} from '@react-aria/focus';\nimport {getLastItem} from '@react-stately/collections';\nimport {getRowId, listMap} from './utils';\nimport {HTMLAttributes, KeyboardEvent as ReactKeyboardEvent, useRef} from 'react';\nimport {isFocusVisible} from '@react-aria/interactions';\nimport type {ListState} from '@react-stately/list';\nimport {SelectableItemStates, useSelectableItem} from '@react-aria/selection';\nimport type {TreeState} from '@react-stately/tree';\nimport {useLocale} from '@react-aria/i18n';\n\nexport interface AriaGridListItemOptions {\n  /** An object representing the list item. Contains all the relevant information that makes up the list row. */\n  node: RSNode<unknown>,\n  /** Whether the list row is contained in a virtual scroller. */\n  isVirtualized?: boolean,\n  /** Whether selection should occur on press up instead of press down. */\n  shouldSelectOnPressUp?: boolean\n}\n\nexport interface GridListItemAria extends SelectableItemStates {\n  /** Props for the list row element. */\n  rowProps: DOMAttributes,\n  /** Props for the grid cell element within the list row. */\n  gridCellProps: DOMAttributes,\n  /** Props for the list item description element, if any. */\n  descriptionProps: DOMAttributes\n}\n\nconst EXPANSION_KEYS = {\n  'expand': {\n    ltr: 'ArrowRight',\n    rtl: 'ArrowLeft'\n  },\n  'collapse': {\n    ltr: 'ArrowLeft',\n    rtl: 'ArrowRight'\n  }\n};\n\n/**\n * Provides the behavior and accessibility implementation for a row in a grid list.\n * @param props - Props for the row.\n * @param state - State of the parent list, as returned by `useListState`.\n * @param ref - The ref attached to the row element.\n */\nexport function useGridListItem<T>(props: AriaGridListItemOptions, state: ListState<T> | TreeState<T>, ref: RefObject<FocusableElement | null>): GridListItemAria {\n  // Copied from useGridCell + some modifications to make it not so grid specific\n  let {\n    node,\n    isVirtualized,\n    shouldSelectOnPressUp\n  } = props;\n\n  // let stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/gridlist');\n  let {direction} = useLocale();\n  let {onAction, linkBehavior, keyboardNavigationBehavior} = listMap.get(state)!;\n  let descriptionId = useSlotId();\n\n  // We need to track the key of the item at the time it was last focused so that we force\n  // focus to go to the item when the DOM node is reused for a different item in a virtualizer.\n  let keyWhenFocused = useRef<Key | null>(null);\n  let focus = () => {\n    // Don't shift focus to the row if the active element is a element within the row already\n    // (e.g. clicking on a row button)\n    if (\n      ref.current !== null &&\n      ((keyWhenFocused.current != null && node.key !== keyWhenFocused.current) ||\n      !ref.current?.contains(document.activeElement))\n    ) {\n      focusSafely(ref.current);\n    }\n  };\n\n  let treeGridRowProps: HTMLAttributes<HTMLElement> = {};\n  let hasChildRows;\n  let hasLink = state.selectionManager.isLink(node.key);\n  if (node != null && 'expandedKeys' in state) {\n    // TODO: ideally node.hasChildNodes would be a way to tell if a row has child nodes, but the row's contents make it so that value is always\n    // true...\n    let children = state.collection.getChildren?.(node.key);\n    hasChildRows = [...(children ?? [])].length > 1;\n    if (onAction == null && !hasLink && state.selectionManager.selectionMode === 'none' && hasChildRows) {\n      onAction = () => state.toggleKey(node.key);\n    }\n\n    let isExpanded = hasChildRows ? state.expandedKeys.has(node.key) : undefined;\n    let setSize = 1;\n    if (node.level > 0 && node?.parentKey != null) {\n      let parent = state.collection.getItem(node.parentKey);\n      if (parent) {\n        // siblings must exist because our original node exists, same with lastItem\n        let siblings = state.collection.getChildren?.(parent.key)!;\n        setSize = getLastItem(siblings)!.index + 1;\n      }\n    } else {\n      setSize = ([...state.collection].filter(row => row.level === 0).at(-1)?.index ?? 0) + 1;\n    }\n    treeGridRowProps = {\n      'aria-expanded': isExpanded,\n      'aria-level': node.level + 1,\n      'aria-posinset': node?.index + 1,\n      'aria-setsize': setSize\n    };\n  }\n\n  let {itemProps, ...itemStates} = useSelectableItem({\n    selectionManager: state.selectionManager,\n    key: node.key,\n    ref,\n    isVirtualized,\n    shouldSelectOnPressUp,\n    onAction: onAction || node.props?.onAction ? chain(node.props?.onAction, onAction ? () => onAction(node.key) : undefined) : undefined,\n    focus,\n    linkBehavior\n  });\n\n  let onKeyDown = (e: ReactKeyboardEvent) => {\n    if (!e.currentTarget.contains(e.target as Element) || !ref.current || !document.activeElement) {\n      return;\n    }\n\n    let walker = getFocusableTreeWalker(ref.current);\n    walker.currentNode = document.activeElement;\n\n    if ('expandedKeys' in state && document.activeElement === ref.current) {\n      if ((e.key === EXPANSION_KEYS['expand'][direction]) && state.selectionManager.focusedKey === node.key && hasChildRows && !state.expandedKeys.has(node.key)) {\n        state.toggleKey(node.key);\n        e.stopPropagation();\n        return;\n      } else if ((e.key === EXPANSION_KEYS['collapse'][direction]) && state.selectionManager.focusedKey === node.key && hasChildRows && state.expandedKeys.has(node.key)) {\n        state.toggleKey(node.key);\n        e.stopPropagation();\n        return;\n      }\n    }\n\n    switch (e.key) {\n      case 'ArrowLeft': {\n        if (keyboardNavigationBehavior === 'arrow') {\n          // Find the next focusable element within the row.\n          let focusable = direction === 'rtl'\n            ? walker.nextNode() as FocusableElement\n            : walker.previousNode() as FocusableElement;\n\n          if (focusable) {\n            e.preventDefault();\n            e.stopPropagation();\n            focusSafely(focusable);\n            scrollIntoViewport(focusable, {containingElement: getScrollParent(ref.current)});\n          } else {\n            // If there is no next focusable child, then return focus back to the row\n            e.preventDefault();\n            e.stopPropagation();\n            if (direction === 'rtl') {\n              focusSafely(ref.current);\n              scrollIntoViewport(ref.current, {containingElement: getScrollParent(ref.current)});\n            } else {\n              walker.currentNode = ref.current;\n              let lastElement = last(walker);\n              if (lastElement) {\n                focusSafely(lastElement);\n                scrollIntoViewport(lastElement, {containingElement: getScrollParent(ref.current)});\n              }\n            }\n          }\n        }\n        break;\n      }\n      case 'ArrowRight': {\n        if (keyboardNavigationBehavior === 'arrow') {\n          let focusable = direction === 'rtl'\n            ? walker.previousNode() as FocusableElement\n            : walker.nextNode() as FocusableElement;\n\n          if (focusable) {\n            e.preventDefault();\n            e.stopPropagation();\n            focusSafely(focusable);\n            scrollIntoViewport(focusable, {containingElement: getScrollParent(ref.current)});\n          } else {\n            e.preventDefault();\n            e.stopPropagation();\n            if (direction === 'ltr') {\n              focusSafely(ref.current);\n              scrollIntoViewport(ref.current, {containingElement: getScrollParent(ref.current)});\n            } else {\n              walker.currentNode = ref.current;\n              let lastElement = last(walker);\n              if (lastElement) {\n                focusSafely(lastElement);\n                scrollIntoViewport(lastElement, {containingElement: getScrollParent(ref.current)});\n              }\n            }\n          }\n        }\n        break;\n      }\n      case 'ArrowUp':\n      case 'ArrowDown':\n        // Prevent this event from reaching row children, e.g. menu buttons. We want arrow keys to navigate\n        // to the row above/below instead. We need to re-dispatch the event from a higher parent so it still\n        // bubbles and gets handled by useSelectableCollection.\n        if (!e.altKey && ref.current.contains(e.target as Element)) {\n          e.stopPropagation();\n          e.preventDefault();\n          ref.current.parentElement?.dispatchEvent(\n            new KeyboardEvent(e.nativeEvent.type, e.nativeEvent)\n          );\n        }\n        break;\n      case 'Tab': {\n        if (keyboardNavigationBehavior === 'tab') {\n          // If there is another focusable element within this item, stop propagation so the tab key\n          // is handled by the browser and not by useSelectableCollection (which would take us out of the list).\n          let walker = getFocusableTreeWalker(ref.current, {tabbable: true});\n          walker.currentNode = document.activeElement;\n          let next = e.shiftKey ? walker.previousNode() : walker.nextNode();\n          if (next) {\n            e.stopPropagation();\n          }\n        }\n      }\n    }\n  };\n\n  let onFocus = (e) => {\n    keyWhenFocused.current = node.key;\n    if (e.target !== ref.current) {\n      // useSelectableItem only handles setting the focused key when\n      // the focused element is the row itself. We also want to\n      // set the focused key when a child element receives focus.\n      // If focus is currently visible (e.g. the user is navigating with the keyboard),\n      // then skip this. We want to restore focus to the previously focused row\n      // in that case since the list should act like a single tab stop.\n      if (!isFocusVisible()) {\n        state.selectionManager.setFocusedKey(node.key);\n      }\n      return;\n    }\n  };\n\n  let syntheticLinkProps = useSyntheticLinkProps(node.props);\n  let linkProps = itemStates.hasAction ? syntheticLinkProps : {};\n  // TODO: re-add when we get translations and fix this for iOS VO\n  // let rowAnnouncement;\n  // if (onAction) {\n  //   rowAnnouncement = stringFormatter.format('hasActionAnnouncement');\n  // } else if (hasLink) {\n  //   rowAnnouncement = stringFormatter.format('hasLinkAnnouncement', {\n  //     link: node.props.href\n  //   });\n  // }\n\n  let rowProps: DOMAttributes = mergeProps(itemProps, linkProps, {\n    role: 'row',\n    onKeyDownCapture: onKeyDown,\n    onFocus,\n    // 'aria-label': [(node.textValue || undefined), rowAnnouncement].filter(Boolean).join(', '),\n    'aria-label': node.textValue || undefined,\n    'aria-selected': state.selectionManager.canSelectItem(node.key) ? state.selectionManager.isSelected(node.key) : undefined,\n    'aria-disabled': state.selectionManager.isDisabled(node.key) || undefined,\n    'aria-labelledby': descriptionId && node.textValue ? `${getRowId(state, node.key)} ${descriptionId}` : undefined,\n    id: getRowId(state, node.key)\n  });\n\n  if (isVirtualized) {\n    rowProps['aria-rowindex'] = node.index + 1;\n  }\n\n  let gridCellProps = {\n    role: 'gridcell',\n    'aria-colindex': 1\n  };\n\n  // TODO: should isExpanded and hasChildRows be a item state that gets returned by the hook?\n  return {\n    rowProps: {...mergeProps(rowProps, treeGridRowProps)},\n    gridCellProps,\n    descriptionProps: {\n      id: descriptionId\n    },\n    ...itemStates\n  };\n}\n\nfunction last(walker: TreeWalker) {\n  let next: FocusableElement | null = null;\n  let last: FocusableElement | null = null;\n  do {\n    last = walker.lastChild() as FocusableElement | null;\n    if (last) {\n      next = last;\n    }\n  } while (last);\n  return next;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
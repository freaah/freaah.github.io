{"ast":null,"code":"import { clearGlobalDnDState as $7252cd45fc48c07c$export$70936501603e6c57, DIRECTORY_DRAG_TYPE as $7252cd45fc48c07c$export$990fced5dfac2637, droppableCollectionMap as $7252cd45fc48c07c$export$dfdf5deeaf27473f, getTypes as $7252cd45fc48c07c$export$e1d41611756c6326, globalDndState as $7252cd45fc48c07c$export$6ca6700462636d0b, isInternalDropOperation as $7252cd45fc48c07c$export$78bf638634500fa5, setDropCollectionRef as $7252cd45fc48c07c$export$dac8db29d42db9a1 } from \"./utils.mjs\";\nimport { registerDropTarget as $67560de7c78cb232$export$c28d9fb4a54e471a } from \"./DragManager.mjs\";\nimport { useAutoScroll as $80d9daea3067eff3$export$6323452ca4533ed8 } from \"./useAutoScroll.mjs\";\nimport { useDrop as $5c06e4929e123553$export$ccdee5eaf73cf661 } from \"./useDrop.mjs\";\nimport { useRef as $4ZR0C$useRef, useCallback as $4ZR0C$useCallback, useEffect as $4ZR0C$useEffect } from \"react\";\nimport { useLayoutEffect as $4ZR0C$useLayoutEffect, useId as $4ZR0C$useId, mergeProps as $4ZR0C$mergeProps } from \"@react-aria/utils\";\nimport { setInteractionModality as $4ZR0C$setInteractionModality } from \"@react-aria/interactions\";\nimport { useLocale as $4ZR0C$useLocale } from \"@react-aria/i18n\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nconst $4b52e4eff84e5217$var$DROP_POSITIONS = ['before', 'on', 'after'];\nconst $4b52e4eff84e5217$var$DROP_POSITIONS_RTL = ['after', 'on', 'before'];\nfunction $4b52e4eff84e5217$export$f4e2f423c21f7b04(props, state, ref) {\n  let localState = (0, $4ZR0C$useRef)({\n    props: props,\n    state: state,\n    nextTarget: null,\n    dropOperation: null\n  }).current;\n  localState.props = props;\n  localState.state = state;\n  let defaultOnDrop = (0, $4ZR0C$useCallback)(async e => {\n    let {\n      onInsert: onInsert,\n      onRootDrop: onRootDrop,\n      onItemDrop: onItemDrop,\n      onReorder: onReorder,\n      acceptedDragTypes = 'all',\n      shouldAcceptItemDrop: shouldAcceptItemDrop\n    } = localState.props;\n    let {\n      draggingKeys: draggingKeys\n    } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);\n    let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);\n    let {\n      target: target,\n      dropOperation: dropOperation,\n      items: items\n    } = e;\n    let filteredItems = items;\n    if (acceptedDragTypes !== 'all' || shouldAcceptItemDrop) filteredItems = items.filter(item => {\n      let itemTypes;\n      if (item.kind === 'directory') itemTypes = new Set([(0, $7252cd45fc48c07c$export$990fced5dfac2637)]);else itemTypes = item.kind === 'file' ? new Set([item.type]) : item.types;\n      if (acceptedDragTypes === 'all' || acceptedDragTypes.some(type => itemTypes.has(type))) {\n        // If we are performing a on item drop, check if the item in question accepts the dropped item since the item may have heavier restrictions\n        // than the droppable collection itself\n        if (target.type === 'item' && target.dropPosition === 'on' && shouldAcceptItemDrop) return shouldAcceptItemDrop(target, itemTypes);\n        return true;\n      }\n      return false;\n    });\n    if (filteredItems.length > 0) {\n      if (target.type === 'root' && onRootDrop) await onRootDrop({\n        items: filteredItems,\n        dropOperation: dropOperation\n      });\n      if (target.type === 'item') {\n        if (target.dropPosition === 'on' && onItemDrop) await onItemDrop({\n          items: filteredItems,\n          dropOperation: dropOperation,\n          isInternal: isInternal,\n          target: target\n        });\n        if (target.dropPosition !== 'on') {\n          if (!isInternal && onInsert) await onInsert({\n            items: filteredItems,\n            dropOperation: dropOperation,\n            target: target\n          });\n          if (isInternal && onReorder) await onReorder({\n            keys: draggingKeys,\n            dropOperation: dropOperation,\n            target: target\n          });\n        }\n      }\n    }\n  }, [localState, ref]);\n  let autoScroll = (0, $80d9daea3067eff3$export$6323452ca4533ed8)(ref);\n  let {\n    dropProps: dropProps\n  } = (0, $5c06e4929e123553$export$ccdee5eaf73cf661)({\n    ref: ref,\n    onDropEnter() {\n      if (localState.nextTarget != null) state.setTarget(localState.nextTarget);\n    },\n    onDropMove(e) {\n      if (localState.nextTarget != null) state.setTarget(localState.nextTarget);\n      autoScroll.move(e.x, e.y);\n    },\n    getDropOperationForPoint(types, allowedOperations, x, y) {\n      let {\n        draggingKeys: draggingKeys,\n        dropCollectionRef: dropCollectionRef\n      } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);\n      let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);\n      let isValidDropTarget = target => state.getDropOperation({\n        target: target,\n        types: types,\n        allowedOperations: allowedOperations,\n        isInternal: isInternal,\n        draggingKeys: draggingKeys\n      }) !== 'cancel';\n      let target = props.dropTargetDelegate.getDropTargetFromPoint(x, y, isValidDropTarget);\n      if (!target) {\n        localState.dropOperation = 'cancel';\n        localState.nextTarget = null;\n        return 'cancel';\n      }\n      localState.dropOperation = state.getDropOperation({\n        target: target,\n        types: types,\n        allowedOperations: allowedOperations,\n        isInternal: isInternal,\n        draggingKeys: draggingKeys\n      });\n      // If the target doesn't accept the drop, see if the root accepts it instead.\n      if (localState.dropOperation === 'cancel') {\n        let rootTarget = {\n          type: 'root'\n        };\n        let dropOperation = state.getDropOperation({\n          target: rootTarget,\n          types: types,\n          allowedOperations: allowedOperations,\n          isInternal: isInternal,\n          draggingKeys: draggingKeys\n        });\n        if (dropOperation !== 'cancel') {\n          target = rootTarget;\n          localState.dropOperation = dropOperation;\n        }\n      }\n      // Only set dropCollectionRef if there is a valid drop target since we cleanup dropCollectionRef in onDropExit\n      // which only runs when leaving a valid drop target or if the dropEffect become none (mouse dnd only).\n      if (target && localState.dropOperation !== 'cancel' && (ref === null || ref === void 0 ? void 0 : ref.current) !== (dropCollectionRef === null || dropCollectionRef === void 0 ? void 0 : dropCollectionRef.current)) (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(ref);\n      localState.nextTarget = localState.dropOperation === 'cancel' ? null : target;\n      return localState.dropOperation;\n    },\n    onDropExit() {\n      (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(undefined);\n      state.setTarget(null);\n      autoScroll.stop();\n    },\n    onDropActivate(e) {\n      var _state_target, _state_target1;\n      if (((_state_target = state.target) === null || _state_target === void 0 ? void 0 : _state_target.type) === 'item' && ((_state_target1 = state.target) === null || _state_target1 === void 0 ? void 0 : _state_target1.dropPosition) === 'on' && typeof props.onDropActivate === 'function') props.onDropActivate({\n        type: 'dropactivate',\n        x: e.x,\n        y: e.y,\n        target: state.target\n      });\n    },\n    onDrop(e) {\n      (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(ref);\n      if (state.target) onDrop(e, state.target);\n      // If there wasn't a collection being tracked as a dragged collection, then we are in a case where a non RSP drag is dropped on a\n      // RSP collection and thus we don't need to preserve the global DnD state for onDragEnd\n      let {\n        draggingCollectionRef: draggingCollectionRef\n      } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);\n      if (draggingCollectionRef == null) (0, $7252cd45fc48c07c$export$70936501603e6c57)();\n    }\n  });\n  let droppingState = (0, $4ZR0C$useRef)(null);\n  let updateFocusAfterDrop = (0, $4ZR0C$useCallback)(() => {\n    let {\n      state: state\n    } = localState;\n    if (droppingState.current) {\n      var _state_collection_getItem;\n      let {\n        target: target,\n        collection: prevCollection,\n        selectedKeys: prevSelectedKeys,\n        focusedKey: prevFocusedKey,\n        isInternal: isInternal,\n        draggingKeys: draggingKeys\n      } = droppingState.current;\n      // If an insert occurs during a drop, we want to immediately select these items to give\n      // feedback to the user that a drop occurred. Only do this if the selection didn't change\n      // since the drop started so we don't override if the user or application did something.\n      if (state.collection.size > prevCollection.size && state.selectionManager.isSelectionEqual(prevSelectedKeys)) {\n        let newKeys = new Set();\n        for (let key of state.collection.getKeys()) if (!prevCollection.getItem(key)) newKeys.add(key);\n        state.selectionManager.setSelectedKeys(newKeys);\n        // If the focused item didn't change since the drop occurred, also focus the first\n        // inserted item. If selection is disabled, then also show the focus ring so there\n        // is some indication that items were added.\n        if (state.selectionManager.focusedKey === prevFocusedKey) {\n          let first = newKeys.keys().next().value;\n          let item = state.collection.getItem(first);\n          // If this is a cell, focus the parent row.\n          if ((item === null || item === void 0 ? void 0 : item.type) === 'cell') first = item.parentKey;\n          state.selectionManager.setFocusedKey(first);\n          if (state.selectionManager.selectionMode === 'none') (0, $4ZR0C$setInteractionModality)('keyboard');\n        }\n      } else if (prevFocusedKey != null && state.selectionManager.focusedKey === prevFocusedKey && isInternal && target.type === 'item' && target.dropPosition !== 'on' && draggingKeys.has((_state_collection_getItem = state.collection.getItem(prevFocusedKey)) === null || _state_collection_getItem === void 0 ? void 0 : _state_collection_getItem.parentKey)) {\n        var _state_collection_getItem1;\n        var _state_collection_getItem_parentKey;\n        // Focus row instead of cell when reordering.\n        state.selectionManager.setFocusedKey((_state_collection_getItem_parentKey = (_state_collection_getItem1 = state.collection.getItem(prevFocusedKey)) === null || _state_collection_getItem1 === void 0 ? void 0 : _state_collection_getItem1.parentKey) !== null && _state_collection_getItem_parentKey !== void 0 ? _state_collection_getItem_parentKey : null);\n        (0, $4ZR0C$setInteractionModality)('keyboard');\n      } else if (state.selectionManager.focusedKey === prevFocusedKey && target.type === 'item' && target.dropPosition === 'on' && state.collection.getItem(target.key) != null) {\n        // If focus didn't move already (e.g. due to an insert), and the user dropped on an item,\n        // focus that item and show the focus ring to give the user feedback that the drop occurred.\n        // Also show the focus ring if the focused key is not selected, e.g. in case of a reorder.\n        state.selectionManager.setFocusedKey(target.key);\n        (0, $4ZR0C$setInteractionModality)('keyboard');\n      } else if (state.selectionManager.focusedKey != null && !state.selectionManager.isSelected(state.selectionManager.focusedKey)) (0, $4ZR0C$setInteractionModality)('keyboard');\n      state.selectionManager.setFocused(true);\n    }\n  }, [localState]);\n  let onDrop = (0, $4ZR0C$useCallback)((e, target) => {\n    let {\n      state: state\n    } = localState;\n    // Save some state of the collection/selection before the drop occurs so we can compare later.\n    droppingState.current = {\n      timeout: undefined,\n      focusedKey: state.selectionManager.focusedKey,\n      collection: state.collection,\n      selectedKeys: state.selectionManager.selectedKeys,\n      draggingKeys: (0, $7252cd45fc48c07c$export$6ca6700462636d0b).draggingKeys,\n      isInternal: (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref),\n      target: target\n    };\n    let onDropFn = localState.props.onDrop || defaultOnDrop;\n    onDropFn({\n      type: 'drop',\n      x: e.x,\n      y: e.y,\n      target: target,\n      items: e.items,\n      dropOperation: e.dropOperation\n    });\n    // Wait for a short time period after the onDrop is called to allow the data to be read asynchronously\n    // and for React to re-render. If the collection didn't already change during this time (handled below),\n    // update the focused key here.\n    droppingState.current.timeout = setTimeout(() => {\n      updateFocusAfterDrop();\n      droppingState.current = null;\n    }, 50);\n  }, [localState, defaultOnDrop, ref, updateFocusAfterDrop]);\n  (0, $4ZR0C$useEffect)(() => {\n    return () => {\n      if (droppingState.current) clearTimeout(droppingState.current.timeout);\n    };\n  }, []);\n  (0, $4ZR0C$useLayoutEffect)(() => {\n    // If the collection changed after a drop, update the focused key.\n    if (droppingState.current && state.collection !== droppingState.current.collection) updateFocusAfterDrop();\n  });\n  let {\n    direction: direction\n  } = (0, $4ZR0C$useLocale)();\n  (0, $4ZR0C$useEffect)(() => {\n    if (!ref.current) return;\n    let getNextTarget = (target, wrap = true, horizontal = false) => {\n      var _keyboardDelegate_getKeyRightOf, _keyboardDelegate_getKeyBelow, _keyboardDelegate_getLastKey, _keyboardDelegate_getFirstKey;\n      if (!target) return {\n        type: 'root'\n      };\n      let {\n        keyboardDelegate: keyboardDelegate\n      } = localState.props;\n      let nextKey;\n      if ((target === null || target === void 0 ? void 0 : target.type) === 'item') nextKey = horizontal ? (_keyboardDelegate_getKeyRightOf = keyboardDelegate.getKeyRightOf) === null || _keyboardDelegate_getKeyRightOf === void 0 ? void 0 : _keyboardDelegate_getKeyRightOf.call(keyboardDelegate, target.key) : (_keyboardDelegate_getKeyBelow = keyboardDelegate.getKeyBelow) === null || _keyboardDelegate_getKeyBelow === void 0 ? void 0 : _keyboardDelegate_getKeyBelow.call(keyboardDelegate, target.key);else nextKey = horizontal && direction === 'rtl' ? (_keyboardDelegate_getLastKey = keyboardDelegate.getLastKey) === null || _keyboardDelegate_getLastKey === void 0 ? void 0 : _keyboardDelegate_getLastKey.call(keyboardDelegate) : (_keyboardDelegate_getFirstKey = keyboardDelegate.getFirstKey) === null || _keyboardDelegate_getFirstKey === void 0 ? void 0 : _keyboardDelegate_getFirstKey.call(keyboardDelegate);\n      let dropPositions = horizontal && direction === 'rtl' ? $4b52e4eff84e5217$var$DROP_POSITIONS_RTL : $4b52e4eff84e5217$var$DROP_POSITIONS;\n      let dropPosition = dropPositions[0];\n      if (target.type === 'item') {\n        // If the the keyboard delegate returned the next key in the collection,\n        // first try the other positions in the current key. Otherwise (e.g. in a grid layout),\n        // jump to the same drop position in the new key.\n        let nextCollectionKey = horizontal && direction === 'rtl' ? localState.state.collection.getKeyBefore(target.key) : localState.state.collection.getKeyAfter(target.key);\n        if (nextKey == null || nextKey === nextCollectionKey) {\n          let positionIndex = dropPositions.indexOf(target.dropPosition);\n          let nextDropPosition = dropPositions[positionIndex + 1];\n          if (positionIndex < dropPositions.length - 1 && !(nextDropPosition === dropPositions[2] && nextKey != null)) return {\n            type: 'item',\n            key: target.key,\n            dropPosition: nextDropPosition\n          };\n          // If the last drop position was 'after', then 'before' on the next key is equivalent.\n          // Switch to 'on' instead.\n          if (target.dropPosition === dropPositions[2]) dropPosition = 'on';\n        } else dropPosition = target.dropPosition;\n      }\n      if (nextKey == null) {\n        if (wrap) return {\n          type: 'root'\n        };\n        return null;\n      }\n      return {\n        type: 'item',\n        key: nextKey,\n        dropPosition: dropPosition\n      };\n    };\n    let getPreviousTarget = (target, wrap = true, horizontal = false) => {\n      var _keyboardDelegate_getKeyLeftOf, _keyboardDelegate_getKeyAbove, _keyboardDelegate_getFirstKey, _keyboardDelegate_getLastKey;\n      let {\n        keyboardDelegate: keyboardDelegate\n      } = localState.props;\n      let nextKey;\n      if ((target === null || target === void 0 ? void 0 : target.type) === 'item') nextKey = horizontal ? (_keyboardDelegate_getKeyLeftOf = keyboardDelegate.getKeyLeftOf) === null || _keyboardDelegate_getKeyLeftOf === void 0 ? void 0 : _keyboardDelegate_getKeyLeftOf.call(keyboardDelegate, target.key) : (_keyboardDelegate_getKeyAbove = keyboardDelegate.getKeyAbove) === null || _keyboardDelegate_getKeyAbove === void 0 ? void 0 : _keyboardDelegate_getKeyAbove.call(keyboardDelegate, target.key);else nextKey = horizontal && direction === 'rtl' ? (_keyboardDelegate_getFirstKey = keyboardDelegate.getFirstKey) === null || _keyboardDelegate_getFirstKey === void 0 ? void 0 : _keyboardDelegate_getFirstKey.call(keyboardDelegate) : (_keyboardDelegate_getLastKey = keyboardDelegate.getLastKey) === null || _keyboardDelegate_getLastKey === void 0 ? void 0 : _keyboardDelegate_getLastKey.call(keyboardDelegate);\n      let dropPositions = horizontal && direction === 'rtl' ? $4b52e4eff84e5217$var$DROP_POSITIONS_RTL : $4b52e4eff84e5217$var$DROP_POSITIONS;\n      let dropPosition = !target || target.type === 'root' ? dropPositions[2] : 'on';\n      if ((target === null || target === void 0 ? void 0 : target.type) === 'item') {\n        // If the the keyboard delegate returned the previous key in the collection,\n        // first try the other positions in the current key. Otherwise (e.g. in a grid layout),\n        // jump to the same drop position in the new key.\n        let prevCollectionKey = horizontal && direction === 'rtl' ? localState.state.collection.getKeyAfter(target.key) : localState.state.collection.getKeyBefore(target.key);\n        if (nextKey == null || nextKey === prevCollectionKey) {\n          let positionIndex = dropPositions.indexOf(target.dropPosition);\n          let nextDropPosition = dropPositions[positionIndex - 1];\n          if (positionIndex > 0 && nextDropPosition !== dropPositions[2]) return {\n            type: 'item',\n            key: target.key,\n            dropPosition: nextDropPosition\n          };\n          // If the last drop position was 'before', then 'after' on the previous key is equivalent.\n          // Switch to 'on' instead.\n          if (target.dropPosition === dropPositions[0]) dropPosition = 'on';\n        } else dropPosition = target.dropPosition;\n      }\n      if (nextKey == null) {\n        if (wrap) return {\n          type: 'root'\n        };\n        return null;\n      }\n      return {\n        type: 'item',\n        key: nextKey,\n        dropPosition: dropPosition\n      };\n    };\n    let nextValidTarget = (target, types, allowedDropOperations, getNextTarget, wrap = true) => {\n      let seenRoot = 0;\n      let operation;\n      let {\n        draggingKeys: draggingKeys\n      } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);\n      let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);\n      do {\n        let nextTarget = getNextTarget(target, wrap);\n        if (!nextTarget) return null;\n        target = nextTarget;\n        operation = localState.state.getDropOperation({\n          target: nextTarget,\n          types: types,\n          allowedOperations: allowedDropOperations,\n          isInternal: isInternal,\n          draggingKeys: draggingKeys\n        });\n        if (target.type === 'root') seenRoot++;\n      } while (operation === 'cancel' && !localState.state.isDropTarget(target) && seenRoot < 2);\n      if (operation === 'cancel') return null;\n      return target;\n    };\n    return $67560de7c78cb232$export$c28d9fb4a54e471a({\n      element: ref.current,\n      preventFocusOnDrop: true,\n      getDropOperation(types, allowedOperations) {\n        if (localState.state.target) {\n          let {\n            draggingKeys: draggingKeys\n          } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);\n          let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);\n          return localState.state.getDropOperation({\n            target: localState.state.target,\n            types: types,\n            allowedOperations: allowedOperations,\n            isInternal: isInternal,\n            draggingKeys: draggingKeys\n          });\n        }\n        // Check if any of the targets accept the drop.\n        // TODO: should we have a faster way of doing this or e.g. for pagination?\n        let target = nextValidTarget(null, types, allowedOperations, getNextTarget);\n        return target ? 'move' : 'cancel';\n      },\n      onDropEnter(e, drag) {\n        let types = (0, $7252cd45fc48c07c$export$e1d41611756c6326)(drag.items);\n        let selectionManager = localState.state.selectionManager;\n        let target = null;\n        // Update the drop collection ref tracker for useDroppableItem's getDropOperation isInternal check\n        (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(ref);\n        // When entering the droppable collection for the first time, the default drop target\n        // is after the focused key.\n        let key = selectionManager.focusedKey;\n        let dropPosition = 'after';\n        // If the focused key is a cell, get the parent item instead.\n        // For now, we assume that individual cells cannot be dropped on.\n        let item = key != null ? localState.state.collection.getItem(key) : null;\n        if ((item === null || item === void 0 ? void 0 : item.type) === 'cell') key = item.parentKey;\n        // If the focused item is also selected, the default drop target is after the last selected item.\n        // But if the focused key is the first selected item, then default to before the first selected item.\n        // This is to make reordering lists slightly easier. If you select top down, we assume you want to\n        // move the items down. If you select bottom up, we assume you want to move the items up.\n        if (key != null && selectionManager.isSelected(key)) {\n          if (selectionManager.selectedKeys.size > 1 && selectionManager.firstSelectedKey === key) dropPosition = 'before';else key = selectionManager.lastSelectedKey;\n        }\n        if (key != null) {\n          target = {\n            type: 'item',\n            key: key,\n            dropPosition: dropPosition\n          };\n          let {\n            draggingKeys: draggingKeys\n          } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);\n          let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);\n          var _nextValidTarget;\n          // If the default target is not valid, find the next one that is.\n          if (localState.state.getDropOperation({\n            target: target,\n            types: types,\n            allowedOperations: drag.allowedDropOperations,\n            isInternal: isInternal,\n            draggingKeys: draggingKeys\n          }) === 'cancel') target = (_nextValidTarget = nextValidTarget(target, types, drag.allowedDropOperations, getNextTarget, false)) !== null && _nextValidTarget !== void 0 ? _nextValidTarget : nextValidTarget(target, types, drag.allowedDropOperations, getPreviousTarget, false);\n        }\n        // If no focused key, then start from the root.\n        if (!target) target = nextValidTarget(null, types, drag.allowedDropOperations, getNextTarget);\n        localState.state.setTarget(target);\n      },\n      onDropExit() {\n        (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(undefined);\n        localState.state.setTarget(null);\n      },\n      onDropTargetEnter(target) {\n        localState.state.setTarget(target);\n      },\n      onDropActivate(e) {\n        var _localState_state_target, _localState_state_target1;\n        if (((_localState_state_target = localState.state.target) === null || _localState_state_target === void 0 ? void 0 : _localState_state_target.type) === 'item' && ((_localState_state_target1 = localState.state.target) === null || _localState_state_target1 === void 0 ? void 0 : _localState_state_target1.dropPosition) === 'on' && typeof localState.props.onDropActivate === 'function') localState.props.onDropActivate({\n          type: 'dropactivate',\n          x: e.x,\n          y: e.y,\n          target: localState.state.target\n        });\n      },\n      onDrop(e, target) {\n        (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(ref);\n        if (localState.state.target) onDrop(e, target || localState.state.target);\n      },\n      onKeyDown(e, drag) {\n        let {\n          keyboardDelegate: keyboardDelegate\n        } = localState.props;\n        let types = (0, $7252cd45fc48c07c$export$e1d41611756c6326)(drag.items);\n        switch (e.key) {\n          case 'ArrowDown':\n            if (keyboardDelegate.getKeyBelow) {\n              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, getNextTarget);\n              localState.state.setTarget(target);\n            }\n            break;\n          case 'ArrowUp':\n            if (keyboardDelegate.getKeyAbove) {\n              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, getPreviousTarget);\n              localState.state.setTarget(target);\n            }\n            break;\n          case 'ArrowLeft':\n            if (keyboardDelegate.getKeyLeftOf) {\n              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, (target, wrap) => getPreviousTarget(target, wrap, true));\n              localState.state.setTarget(target);\n            }\n            break;\n          case 'ArrowRight':\n            if (keyboardDelegate.getKeyRightOf) {\n              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, (target, wrap) => getNextTarget(target, wrap, true));\n              localState.state.setTarget(target);\n            }\n            break;\n          case 'Home':\n            if (keyboardDelegate.getFirstKey) {\n              let target = nextValidTarget(null, types, drag.allowedDropOperations, getNextTarget);\n              localState.state.setTarget(target);\n            }\n            break;\n          case 'End':\n            if (keyboardDelegate.getLastKey) {\n              let target = nextValidTarget(null, types, drag.allowedDropOperations, getPreviousTarget);\n              localState.state.setTarget(target);\n            }\n            break;\n          case 'PageDown':\n            if (keyboardDelegate.getKeyPageBelow) {\n              let target = localState.state.target;\n              if (!target) target = nextValidTarget(null, types, drag.allowedDropOperations, getNextTarget);else {\n                var _keyboardDelegate_getFirstKey, _keyboardDelegate_getLastKey;\n                // If on the root, go to the item a page below the top. Otherwise a page below the current item.\n                let targetKey = (_keyboardDelegate_getFirstKey = keyboardDelegate.getFirstKey) === null || _keyboardDelegate_getFirstKey === void 0 ? void 0 : _keyboardDelegate_getFirstKey.call(keyboardDelegate);\n                if (target.type === 'item') targetKey = target.key;\n                let nextKey = null;\n                if (targetKey != null) nextKey = keyboardDelegate.getKeyPageBelow(targetKey);\n                let dropPosition = target.type === 'item' ? target.dropPosition : 'after';\n                // If there is no next key, or we are starting on the last key, jump to the last possible position.\n                if (nextKey == null || target.type === 'item' && target.key === ((_keyboardDelegate_getLastKey = keyboardDelegate.getLastKey) === null || _keyboardDelegate_getLastKey === void 0 ? void 0 : _keyboardDelegate_getLastKey.call(keyboardDelegate))) {\n                  var _keyboardDelegate_getLastKey1;\n                  var _keyboardDelegate_getLastKey2;\n                  nextKey = (_keyboardDelegate_getLastKey2 = (_keyboardDelegate_getLastKey1 = keyboardDelegate.getLastKey) === null || _keyboardDelegate_getLastKey1 === void 0 ? void 0 : _keyboardDelegate_getLastKey1.call(keyboardDelegate)) !== null && _keyboardDelegate_getLastKey2 !== void 0 ? _keyboardDelegate_getLastKey2 : null;\n                  dropPosition = 'after';\n                }\n                if (nextKey == null) break;\n                target = {\n                  type: 'item',\n                  key: nextKey,\n                  dropPosition: dropPosition\n                };\n                // If the target does not accept the drop, find the next valid target.\n                // If no next valid target, find the previous valid target.\n                let {\n                  draggingCollectionRef: draggingCollectionRef,\n                  draggingKeys: draggingKeys\n                } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);\n                let isInternal = (draggingCollectionRef === null || draggingCollectionRef === void 0 ? void 0 : draggingCollectionRef.current) === (ref === null || ref === void 0 ? void 0 : ref.current);\n                let operation = localState.state.getDropOperation({\n                  target: target,\n                  types: types,\n                  allowedOperations: drag.allowedDropOperations,\n                  isInternal: isInternal,\n                  draggingKeys: draggingKeys\n                });\n                var _nextValidTarget;\n                if (operation === 'cancel') target = (_nextValidTarget = nextValidTarget(target, types, drag.allowedDropOperations, getNextTarget, false)) !== null && _nextValidTarget !== void 0 ? _nextValidTarget : nextValidTarget(target, types, drag.allowedDropOperations, getPreviousTarget, false);\n              }\n              localState.state.setTarget(target !== null && target !== void 0 ? target : localState.state.target);\n            }\n            break;\n          case 'PageUp':\n            {\n              if (!keyboardDelegate.getKeyPageAbove) break;\n              let target = localState.state.target;\n              if (!target) target = nextValidTarget(null, types, drag.allowedDropOperations, getPreviousTarget);else if (target.type === 'item') {\n                var _keyboardDelegate_getFirstKey1;\n                // If at the top already, switch to the root. Otherwise navigate a page up.\n                if (target.key === ((_keyboardDelegate_getFirstKey1 = keyboardDelegate.getFirstKey) === null || _keyboardDelegate_getFirstKey1 === void 0 ? void 0 : _keyboardDelegate_getFirstKey1.call(keyboardDelegate))) target = {\n                  type: 'root'\n                };else {\n                  let nextKey = keyboardDelegate.getKeyPageAbove(target.key);\n                  let dropPosition = target.dropPosition;\n                  if (nextKey == null) {\n                    var _keyboardDelegate_getFirstKey2;\n                    nextKey = (_keyboardDelegate_getFirstKey2 = keyboardDelegate.getFirstKey) === null || _keyboardDelegate_getFirstKey2 === void 0 ? void 0 : _keyboardDelegate_getFirstKey2.call(keyboardDelegate);\n                    dropPosition = 'before';\n                  }\n                  if (nextKey == null) break;\n                  target = {\n                    type: 'item',\n                    key: nextKey,\n                    dropPosition: dropPosition\n                  };\n                }\n                // If the target does not accept the drop, find the previous valid target.\n                // If no next valid target, find the next valid target.\n                let {\n                  draggingKeys: draggingKeys\n                } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);\n                let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);\n                let operation = localState.state.getDropOperation({\n                  target: target,\n                  types: types,\n                  allowedOperations: drag.allowedDropOperations,\n                  isInternal: isInternal,\n                  draggingKeys: draggingKeys\n                });\n                var _nextValidTarget1;\n                if (operation === 'cancel') target = (_nextValidTarget1 = nextValidTarget(target, types, drag.allowedDropOperations, getPreviousTarget, false)) !== null && _nextValidTarget1 !== void 0 ? _nextValidTarget1 : nextValidTarget(target, types, drag.allowedDropOperations, getNextTarget, false);\n              }\n              localState.state.setTarget(target !== null && target !== void 0 ? target : localState.state.target);\n              break;\n            }\n        }\n      }\n    });\n  }, [localState, ref, onDrop, direction]);\n  let id = (0, $4ZR0C$useId)();\n  (0, $7252cd45fc48c07c$export$dfdf5deeaf27473f).set(state, {\n    id: id,\n    ref: ref\n  });\n  return {\n    collectionProps: (0, $4ZR0C$mergeProps)(dropProps, {\n      id: id,\n      // Remove description from collection element. If dropping on the entire collection,\n      // there should be a drop indicator that has this description, so no need to double announce.\n      'aria-describedby': null\n    })\n  };\n}\nexport { $4b52e4eff84e5217$export$f4e2f423c21f7b04 as useDroppableCollection };","map":{"version":3,"names":["$4b52e4eff84e5217$var$DROP_POSITIONS","$4b52e4eff84e5217$var$DROP_POSITIONS_RTL","$4b52e4eff84e5217$export$f4e2f423c21f7b04","props","state","ref","localState","$4ZR0C$useRef","nextTarget","dropOperation","current","defaultOnDrop","$4ZR0C$useCallback","e","onInsert","onRootDrop","onItemDrop","onReorder","acceptedDragTypes","shouldAcceptItemDrop","draggingKeys","$7252cd45fc48c07c$export$6ca6700462636d0b","isInternal","$7252cd45fc48c07c$export$78bf638634500fa5","target","items","filteredItems","filter","item","itemTypes","kind","Set","$7252cd45fc48c07c$export$990fced5dfac2637","type","types","some","has","dropPosition","length","keys","autoScroll","$80d9daea3067eff3$export$6323452ca4533ed8","dropProps","$5c06e4929e123553$export$ccdee5eaf73cf661","onDropEnter","setTarget","onDropMove","move","x","y","getDropOperationForPoint","allowedOperations","dropCollectionRef","isValidDropTarget","getDropOperation","dropTargetDelegate","getDropTargetFromPoint","rootTarget","$7252cd45fc48c07c$export$dac8db29d42db9a1","onDropExit","undefined","stop","onDropActivate","_state_target","_state_target1","onDrop","draggingCollectionRef","$7252cd45fc48c07c$export$70936501603e6c57","droppingState","updateFocusAfterDrop","_state_collection_getItem","collection","prevCollection","selectedKeys","prevSelectedKeys","focusedKey","prevFocusedKey","size","selectionManager","isSelectionEqual","newKeys","key","getKeys","getItem","add","setSelectedKeys","first","next","value","parentKey","setFocusedKey","selectionMode","$4ZR0C$setInteractionModality","_state_collection_getItem1","_state_collection_getItem_parentKey","isSelected","setFocused","timeout","onDropFn","setTimeout","$4ZR0C$useEffect","clearTimeout","$4ZR0C$useLayoutEffect","direction","$4ZR0C$useLocale","getNextTarget","wrap","horizontal","_keyboardDelegate_getKeyRightOf","_keyboardDelegate_getKeyBelow","_keyboardDelegate_getLastKey","_keyboardDelegate_getFirstKey","keyboardDelegate","nextKey","getKeyRightOf","call","getKeyBelow","getLastKey","getFirstKey","dropPositions","nextCollectionKey","getKeyBefore","getKeyAfter","positionIndex","indexOf","nextDropPosition","getPreviousTarget","_keyboardDelegate_getKeyLeftOf","_keyboardDelegate_getKeyAbove","getKeyLeftOf","getKeyAbove","prevCollectionKey","nextValidTarget","allowedDropOperations","seenRoot","operation","isDropTarget","$67560de7c78cb232$export$c28d9fb4a54e471a","element","preventFocusOnDrop","drag","$7252cd45fc48c07c$export$e1d41611756c6326","firstSelectedKey","lastSelectedKey","_nextValidTarget","onDropTargetEnter","_localState_state_target","_localState_state_target1","onKeyDown","getKeyPageBelow","targetKey","_keyboardDelegate_getLastKey1","_keyboardDelegate_getLastKey2","getKeyPageAbove","_keyboardDelegate_getFirstKey1","_keyboardDelegate_getFirstKey2","_nextValidTarget1","id","$4ZR0C$useId","$7252cd45fc48c07c$export$dfdf5deeaf27473f","set","collectionProps","$4ZR0C$mergeProps"],"sources":["C:\\Users\\rewac\\OneDrive\\Documents\\GitHub\\scatch-store.me\\node_modules\\@react-aria\\dnd\\dist\\packages\\@react-aria\\dnd\\src\\useDroppableCollection.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {\n  clearGlobalDnDState,\n  DIRECTORY_DRAG_TYPE,\n  droppableCollectionMap,\n  getTypes,\n  globalDndState,\n  isInternalDropOperation,\n  setDropCollectionRef\n} from './utils';\nimport {\n  Collection,\n  DropEvent,\n  DropOperation,\n  DroppableCollectionDropEvent,\n  DroppableCollectionProps,\n  DropPosition,\n  DropTarget,\n  DropTargetDelegate,\n  Key,\n  KeyboardDelegate,\n  Node,\n  RefObject\n} from '@react-types/shared';\nimport * as DragManager from './DragManager';\nimport {DroppableCollectionState} from '@react-stately/dnd';\nimport {HTMLAttributes, useCallback, useEffect, useRef} from 'react';\nimport {mergeProps, useId, useLayoutEffect} from '@react-aria/utils';\nimport {setInteractionModality} from '@react-aria/interactions';\nimport {useAutoScroll} from './useAutoScroll';\nimport {useDrop} from './useDrop';\nimport {useLocale} from '@react-aria/i18n';\n\nexport interface DroppableCollectionOptions extends DroppableCollectionProps {\n  /** A delegate object that implements behavior for keyboard focus movement. */\n  keyboardDelegate: KeyboardDelegate,\n  /** A delegate object that provides drop targets for pointer coordinates within the collection. */\n  dropTargetDelegate: DropTargetDelegate\n}\n\nexport interface DroppableCollectionResult {\n  /** Props for the collection element. */\n  collectionProps: HTMLAttributes<HTMLElement>\n}\n\ninterface DroppingState {\n  collection: Collection<Node<unknown>>,\n  focusedKey: Key | null,\n  selectedKeys: Set<Key>,\n  target: DropTarget,\n  draggingKeys: Set<Key | null | undefined>,\n  isInternal: boolean,\n  timeout: ReturnType<typeof setTimeout> | undefined\n}\n\nconst DROP_POSITIONS: DropPosition[] = ['before', 'on', 'after'];\nconst DROP_POSITIONS_RTL: DropPosition[] = ['after', 'on', 'before'];\n\n/**\n * Handles drop interactions for a collection component, with support for traditional mouse and touch\n * based drag and drop, in addition to full parity for keyboard and screen reader users.\n */\nexport function useDroppableCollection(props: DroppableCollectionOptions, state: DroppableCollectionState, ref: RefObject<HTMLElement | null>): DroppableCollectionResult {\n  let localState = useRef<{\n    props: DroppableCollectionOptions,\n    state: DroppableCollectionState,\n    nextTarget: DropTarget | null,\n    dropOperation: DropOperation | null\n  }>({\n    props,\n    state,\n    nextTarget: null,\n    dropOperation: null\n  }).current;\n  localState.props = props;\n  localState.state = state;\n\n  let defaultOnDrop = useCallback(async (e: DroppableCollectionDropEvent) => {\n    let {\n      onInsert,\n      onRootDrop,\n      onItemDrop,\n      onReorder,\n      acceptedDragTypes = 'all',\n      shouldAcceptItemDrop\n    } = localState.props;\n\n    let {draggingKeys} = globalDndState;\n    let isInternal = isInternalDropOperation(ref);\n    let {\n      target,\n      dropOperation,\n      items\n    } = e;\n\n    let filteredItems = items;\n    if (acceptedDragTypes !== 'all' || shouldAcceptItemDrop) {\n      filteredItems = items.filter(item => {\n        let itemTypes: Set<string | symbol>;\n        if (item.kind === 'directory') {\n          itemTypes = new Set([DIRECTORY_DRAG_TYPE]);\n        } else {\n          itemTypes = item.kind === 'file' ? new Set([item.type]) : item.types;\n        }\n\n        if (acceptedDragTypes === 'all' || acceptedDragTypes.some(type => itemTypes.has(type))) {\n          // If we are performing a on item drop, check if the item in question accepts the dropped item since the item may have heavier restrictions\n          // than the droppable collection itself\n          if (target.type === 'item' && target.dropPosition === 'on' && shouldAcceptItemDrop) {\n            return shouldAcceptItemDrop(target, itemTypes);\n          }\n          return true;\n        }\n\n        return false;\n      });\n    }\n\n    if (filteredItems.length > 0) {\n      if (target.type === 'root' && onRootDrop) {\n        await onRootDrop({items: filteredItems, dropOperation});\n      }\n\n      if (target.type === 'item') {\n        if (target.dropPosition === 'on' && onItemDrop) {\n          await onItemDrop({items: filteredItems, dropOperation, isInternal, target});\n        }\n\n        if (target.dropPosition !== 'on') {\n          if (!isInternal && onInsert) {\n            await onInsert({items: filteredItems, dropOperation, target});\n          }\n\n          if (isInternal && onReorder) {\n            await onReorder({keys: draggingKeys, dropOperation, target});\n          }\n        }\n      }\n    }\n  }, [localState, ref]);\n\n  let autoScroll = useAutoScroll(ref);\n  let {dropProps} = useDrop({\n    ref,\n    onDropEnter() {\n      if (localState.nextTarget != null) {\n        state.setTarget(localState.nextTarget);\n      }\n    },\n    onDropMove(e) {\n      if (localState.nextTarget != null) {\n        state.setTarget(localState.nextTarget);\n      }\n      autoScroll.move(e.x, e.y);\n    },\n    getDropOperationForPoint(types, allowedOperations, x, y) {\n      let {draggingKeys, dropCollectionRef} = globalDndState;\n      let isInternal = isInternalDropOperation(ref);\n      let isValidDropTarget = (target) => state.getDropOperation({target, types, allowedOperations, isInternal, draggingKeys}) !== 'cancel';\n      let target = props.dropTargetDelegate.getDropTargetFromPoint(x, y, isValidDropTarget);\n      if (!target) {\n        localState.dropOperation = 'cancel';\n        localState.nextTarget = null;\n        return 'cancel';\n      }\n\n      localState.dropOperation = state.getDropOperation({target, types, allowedOperations, isInternal, draggingKeys});\n\n      // If the target doesn't accept the drop, see if the root accepts it instead.\n      if (localState.dropOperation === 'cancel') {\n        let rootTarget: DropTarget = {type: 'root'};\n        let dropOperation = state.getDropOperation({target: rootTarget, types, allowedOperations, isInternal, draggingKeys});\n        if (dropOperation !== 'cancel') {\n          target = rootTarget;\n          localState.dropOperation = dropOperation;\n        }\n      }\n\n      // Only set dropCollectionRef if there is a valid drop target since we cleanup dropCollectionRef in onDropExit\n      // which only runs when leaving a valid drop target or if the dropEffect become none (mouse dnd only).\n      if (target && localState.dropOperation !== 'cancel' && ref?.current !== dropCollectionRef?.current) {\n        setDropCollectionRef(ref);\n      }\n      localState.nextTarget = localState.dropOperation === 'cancel' ? null : target;\n      return localState.dropOperation;\n    },\n    onDropExit() {\n      setDropCollectionRef(undefined);\n      state.setTarget(null);\n      autoScroll.stop();\n    },\n    onDropActivate(e) {\n      if (state.target?.type === 'item' && state.target?.dropPosition === 'on' && typeof props.onDropActivate === 'function') {\n        props.onDropActivate({\n          type: 'dropactivate',\n          x: e.x, // todo\n          y: e.y,\n          target: state.target\n        });\n      }\n    },\n    onDrop(e) {\n      setDropCollectionRef(ref);\n      if (state.target) {\n        onDrop(e, state.target);\n      }\n\n      // If there wasn't a collection being tracked as a dragged collection, then we are in a case where a non RSP drag is dropped on a\n      // RSP collection and thus we don't need to preserve the global DnD state for onDragEnd\n      let {draggingCollectionRef} = globalDndState;\n      if (draggingCollectionRef == null) {\n        clearGlobalDnDState();\n      }\n    }\n  });\n\n  let droppingState = useRef<DroppingState>(null);\n  let updateFocusAfterDrop = useCallback(() => {\n    let {state} = localState;\n    if (droppingState.current) {\n      let {\n        target,\n        collection: prevCollection,\n        selectedKeys: prevSelectedKeys,\n        focusedKey: prevFocusedKey,\n        isInternal,\n        draggingKeys\n      } = droppingState.current;\n\n      // If an insert occurs during a drop, we want to immediately select these items to give\n      // feedback to the user that a drop occurred. Only do this if the selection didn't change\n      // since the drop started so we don't override if the user or application did something.\n      if (\n        state.collection.size > prevCollection.size &&\n        state.selectionManager.isSelectionEqual(prevSelectedKeys)\n      ) {\n        let newKeys = new Set<Key>();\n        for (let key of state.collection.getKeys()) {\n          if (!prevCollection.getItem(key)) {\n            newKeys.add(key);\n          }\n        }\n\n        state.selectionManager.setSelectedKeys(newKeys);\n\n        // If the focused item didn't change since the drop occurred, also focus the first\n        // inserted item. If selection is disabled, then also show the focus ring so there\n        // is some indication that items were added.\n        if (state.selectionManager.focusedKey === prevFocusedKey) {\n          let first = newKeys.keys().next().value;\n          let item = state.collection.getItem(first);\n\n          // If this is a cell, focus the parent row.\n          if (item?.type === 'cell') {\n            first = item.parentKey;\n          }\n\n          state.selectionManager.setFocusedKey(first);\n\n          if (state.selectionManager.selectionMode === 'none') {\n            setInteractionModality('keyboard');\n          }\n        }\n      } else if (\n        prevFocusedKey != null &&\n        state.selectionManager.focusedKey === prevFocusedKey &&\n        isInternal &&\n        target.type === 'item' &&\n        target.dropPosition !== 'on' &&\n        draggingKeys.has(state.collection.getItem(prevFocusedKey)?.parentKey)\n      ) {\n        // Focus row instead of cell when reordering.\n        state.selectionManager.setFocusedKey(state.collection.getItem(prevFocusedKey)?.parentKey ?? null);\n        setInteractionModality('keyboard');\n      } else if (\n        state.selectionManager.focusedKey === prevFocusedKey &&\n        target.type === 'item' &&\n        target.dropPosition === 'on' &&\n        state.collection.getItem(target.key) != null\n      ) {\n        // If focus didn't move already (e.g. due to an insert), and the user dropped on an item,\n        // focus that item and show the focus ring to give the user feedback that the drop occurred.\n        // Also show the focus ring if the focused key is not selected, e.g. in case of a reorder.\n        state.selectionManager.setFocusedKey(target.key);\n        setInteractionModality('keyboard');\n      } else if (state.selectionManager.focusedKey != null && !state.selectionManager.isSelected(state.selectionManager.focusedKey)) {\n        setInteractionModality('keyboard');\n      }\n\n      state.selectionManager.setFocused(true);\n    }\n  }, [localState]);\n\n  let onDrop = useCallback((e: DropEvent, target: DropTarget) => {\n    let {state} = localState;\n\n    // Save some state of the collection/selection before the drop occurs so we can compare later.\n    droppingState.current = {\n      timeout: undefined,\n      focusedKey: state.selectionManager.focusedKey,\n      collection: state.collection,\n      selectedKeys: state.selectionManager.selectedKeys,\n      draggingKeys: globalDndState.draggingKeys,\n      isInternal: isInternalDropOperation(ref),\n      target\n    };\n\n    let onDropFn = localState.props.onDrop || defaultOnDrop;\n    onDropFn({\n      type: 'drop',\n      x: e.x, // todo\n      y: e.y,\n      target,\n      items: e.items,\n      dropOperation: e.dropOperation\n    });\n\n    // Wait for a short time period after the onDrop is called to allow the data to be read asynchronously\n    // and for React to re-render. If the collection didn't already change during this time (handled below),\n    // update the focused key here.\n    droppingState.current.timeout = setTimeout(() => {\n      updateFocusAfterDrop();\n      droppingState.current = null;\n    }, 50);\n  }, [localState, defaultOnDrop, ref, updateFocusAfterDrop]);\n\n   \n  useEffect(() => {\n    return () => {\n      if (droppingState.current) {\n        clearTimeout(droppingState.current.timeout);\n      }\n    };\n  }, []);\n\n  useLayoutEffect(() => {\n    // If the collection changed after a drop, update the focused key.\n    if (droppingState.current && state.collection !== droppingState.current.collection) {\n      updateFocusAfterDrop();\n    }\n  });\n\n  let {direction} = useLocale();\n  useEffect(() => {\n    if (!ref.current) {\n      return;\n    }\n\n    let getNextTarget = (target: DropTarget | null | undefined, wrap = true, horizontal = false): DropTarget | null => {\n      if (!target) {\n        return {\n          type: 'root'\n        };\n      }\n\n      let {keyboardDelegate} = localState.props;\n      let nextKey: Key | null | undefined;\n      if (target?.type === 'item') {\n        nextKey = horizontal ? keyboardDelegate.getKeyRightOf?.(target.key) : keyboardDelegate.getKeyBelow?.(target.key);\n      } else {\n        nextKey = horizontal && direction === 'rtl' ? keyboardDelegate.getLastKey?.() : keyboardDelegate.getFirstKey?.();\n      }\n      let dropPositions = horizontal && direction === 'rtl' ? DROP_POSITIONS_RTL : DROP_POSITIONS;\n      let dropPosition: DropPosition = dropPositions[0];\n\n      if (target.type === 'item') {\n        // If the the keyboard delegate returned the next key in the collection,\n        // first try the other positions in the current key. Otherwise (e.g. in a grid layout),\n        // jump to the same drop position in the new key.\n        let nextCollectionKey = horizontal && direction === 'rtl' ? localState.state.collection.getKeyBefore(target.key) : localState.state.collection.getKeyAfter(target.key);\n        if (nextKey == null || nextKey === nextCollectionKey) {\n          let positionIndex = dropPositions.indexOf(target.dropPosition);\n          let nextDropPosition = dropPositions[positionIndex + 1];\n          if (positionIndex < dropPositions.length - 1 && !(nextDropPosition === dropPositions[2] && nextKey != null)) {\n            return {\n              type: 'item',\n              key: target.key,\n              dropPosition: nextDropPosition\n            };\n          }\n\n          // If the last drop position was 'after', then 'before' on the next key is equivalent.\n          // Switch to 'on' instead.\n          if (target.dropPosition === dropPositions[2]) {\n            dropPosition = 'on';\n          }\n        } else {\n          dropPosition = target.dropPosition;\n        }\n      }\n\n      if (nextKey == null) {\n        if (wrap) {\n          return {\n            type: 'root'\n          };\n        }\n\n        return null;\n      }\n\n      return {\n        type: 'item',\n        key: nextKey,\n        dropPosition\n      };\n    };\n\n    let getPreviousTarget = (target: DropTarget | null | undefined, wrap = true, horizontal = false): DropTarget | null => {\n      let {keyboardDelegate} = localState.props;\n      let nextKey: Key | null | undefined;\n      if (target?.type === 'item') {\n        nextKey = horizontal ? keyboardDelegate.getKeyLeftOf?.(target.key) : keyboardDelegate.getKeyAbove?.(target.key);\n      } else {\n        nextKey = horizontal && direction === 'rtl' ? keyboardDelegate.getFirstKey?.() : keyboardDelegate.getLastKey?.();\n      }\n      let dropPositions = horizontal && direction === 'rtl' ? DROP_POSITIONS_RTL : DROP_POSITIONS;\n      let dropPosition: DropPosition = !target || target.type === 'root' ? dropPositions[2] : 'on';\n\n      if (target?.type === 'item') {\n        // If the the keyboard delegate returned the previous key in the collection,\n        // first try the other positions in the current key. Otherwise (e.g. in a grid layout),\n        // jump to the same drop position in the new key.\n        let prevCollectionKey = horizontal && direction === 'rtl' ? localState.state.collection.getKeyAfter(target.key) : localState.state.collection.getKeyBefore(target.key);\n        if (nextKey == null || nextKey === prevCollectionKey) {\n          let positionIndex = dropPositions.indexOf(target.dropPosition);\n          let nextDropPosition = dropPositions[positionIndex - 1];\n          if (positionIndex > 0 && nextDropPosition !== dropPositions[2]) {\n            return {\n              type: 'item',\n              key: target.key,\n              dropPosition: nextDropPosition\n            };\n          }\n\n          // If the last drop position was 'before', then 'after' on the previous key is equivalent.\n          // Switch to 'on' instead.\n          if (target.dropPosition === dropPositions[0]) {\n            dropPosition = 'on';\n          }\n        } else {\n          dropPosition = target.dropPosition;\n        }\n      }\n\n      if (nextKey == null) {\n        if (wrap) {\n          return {\n            type: 'root'\n          };\n        }\n\n        return null;\n      }\n\n      return {\n        type: 'item',\n        key: nextKey,\n        dropPosition\n      };\n    };\n\n    let nextValidTarget = (\n      target: DropTarget | null | undefined,\n      types: Set<string>,\n      allowedDropOperations: DropOperation[],\n      getNextTarget: (target: DropTarget | null | undefined, wrap: boolean) => DropTarget | null,\n      wrap = true\n    ): DropTarget | null => {\n      let seenRoot = 0;\n      let operation: DropOperation;\n      let {draggingKeys} = globalDndState;\n      let isInternal = isInternalDropOperation(ref);\n      do {\n        let nextTarget = getNextTarget(target, wrap);\n        if (!nextTarget) {\n          return null;\n        }\n        target = nextTarget;\n        operation = localState.state.getDropOperation({target: nextTarget, types, allowedOperations: allowedDropOperations, isInternal, draggingKeys});\n        if (target.type === 'root') {\n          seenRoot++;\n        }\n      } while (\n        operation === 'cancel' &&\n        !localState.state.isDropTarget(target) &&\n        seenRoot < 2\n      );\n\n      if (operation === 'cancel') {\n        return null;\n      }\n\n      return target;\n    };\n\n    return DragManager.registerDropTarget({\n      element: ref.current,\n      preventFocusOnDrop: true,\n      getDropOperation(types, allowedOperations) {\n        if (localState.state.target) {\n          let {draggingKeys} = globalDndState;\n          let isInternal = isInternalDropOperation(ref);\n          return localState.state.getDropOperation({target: localState.state.target, types, allowedOperations, isInternal, draggingKeys});\n        }\n\n        // Check if any of the targets accept the drop.\n        // TODO: should we have a faster way of doing this or e.g. for pagination?\n        let target = nextValidTarget(null, types, allowedOperations, getNextTarget);\n        return target ? 'move' : 'cancel';\n      },\n      onDropEnter(e, drag) {\n        let types = getTypes(drag.items);\n        let selectionManager = localState.state.selectionManager;\n        let target: DropTarget | null = null;\n        // Update the drop collection ref tracker for useDroppableItem's getDropOperation isInternal check\n        setDropCollectionRef(ref);\n\n        // When entering the droppable collection for the first time, the default drop target\n        // is after the focused key.\n        let key: Key | null | undefined = selectionManager.focusedKey;\n        let dropPosition: DropPosition = 'after';\n\n        // If the focused key is a cell, get the parent item instead.\n        // For now, we assume that individual cells cannot be dropped on.\n        let item = key != null ? localState.state.collection.getItem(key) : null;\n        if (item?.type === 'cell') {\n          key = item.parentKey;\n        }\n\n        // If the focused item is also selected, the default drop target is after the last selected item.\n        // But if the focused key is the first selected item, then default to before the first selected item.\n        // This is to make reordering lists slightly easier. If you select top down, we assume you want to\n        // move the items down. If you select bottom up, we assume you want to move the items up.\n        if (key != null && selectionManager.isSelected(key)) {\n          if (selectionManager.selectedKeys.size > 1 && selectionManager.firstSelectedKey === key) {\n            dropPosition = 'before';\n          } else {\n            key = selectionManager.lastSelectedKey;\n          }\n        }\n\n        if (key != null) {\n          target = {\n            type: 'item',\n            key,\n            dropPosition\n          };\n\n          let {draggingKeys} = globalDndState;\n          let isInternal = isInternalDropOperation(ref);\n          // If the default target is not valid, find the next one that is.\n          if (localState.state.getDropOperation({target, types, allowedOperations: drag.allowedDropOperations, isInternal, draggingKeys}) === 'cancel') {\n            target = nextValidTarget(target, types, drag.allowedDropOperations, getNextTarget, false)\n              ?? nextValidTarget(target, types, drag.allowedDropOperations, getPreviousTarget, false);\n          }\n        }\n\n        // If no focused key, then start from the root.\n        if (!target) {\n          target = nextValidTarget(null, types, drag.allowedDropOperations, getNextTarget);\n        }\n\n        localState.state.setTarget(target);\n      },\n      onDropExit() {\n        setDropCollectionRef(undefined);\n        localState.state.setTarget(null);\n      },\n      onDropTargetEnter(target) {\n        localState.state.setTarget(target);\n      },\n      onDropActivate(e) {\n        if (\n          localState.state.target?.type === 'item' &&\n          localState.state.target?.dropPosition === 'on' &&\n          typeof localState.props.onDropActivate === 'function'\n        ) {\n          localState.props.onDropActivate({\n            type: 'dropactivate',\n            x: e.x, // todo\n            y: e.y,\n            target: localState.state.target\n          });\n        }\n      },\n      onDrop(e, target) {\n        setDropCollectionRef(ref);\n        if (localState.state.target) {\n          onDrop(e, target || localState.state.target);\n        }\n      },\n      onKeyDown(e, drag) {\n        let {keyboardDelegate} = localState.props;\n        let types = getTypes(drag.items);\n        switch (e.key) {\n          case 'ArrowDown': {\n            if (keyboardDelegate.getKeyBelow) {\n              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, getNextTarget);\n              localState.state.setTarget(target);\n            }\n            break;\n          }\n          case 'ArrowUp': {\n            if (keyboardDelegate.getKeyAbove) {\n              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, getPreviousTarget);\n              localState.state.setTarget(target);\n            }\n            break;\n          }\n          case 'ArrowLeft': {\n            if (keyboardDelegate.getKeyLeftOf) {\n              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, (target, wrap) => getPreviousTarget(target, wrap, true));\n              localState.state.setTarget(target);\n            }\n            break;\n          }\n          case 'ArrowRight': {\n            if (keyboardDelegate.getKeyRightOf) {\n              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, (target, wrap) => getNextTarget(target, wrap, true));\n              localState.state.setTarget(target);\n            }\n            break;\n          }\n          case 'Home': {\n            if (keyboardDelegate.getFirstKey) {\n              let target = nextValidTarget(null, types, drag.allowedDropOperations, getNextTarget);\n              localState.state.setTarget(target);\n            }\n            break;\n          }\n          case 'End': {\n            if (keyboardDelegate.getLastKey) {\n              let target = nextValidTarget(null, types, drag.allowedDropOperations, getPreviousTarget);\n              localState.state.setTarget(target);\n            }\n            break;\n          }\n          case 'PageDown': {\n            if (keyboardDelegate.getKeyPageBelow) {\n              let target = localState.state.target;\n              if (!target) {\n                target = nextValidTarget(null, types, drag.allowedDropOperations, getNextTarget);\n              } else {\n                // If on the root, go to the item a page below the top. Otherwise a page below the current item.\n                let targetKey = keyboardDelegate.getFirstKey?.();\n                if (target.type === 'item') {\n                  targetKey = target.key;\n                }\n                let nextKey: Key | null = null;\n                if (targetKey != null) {\n                  nextKey = keyboardDelegate.getKeyPageBelow(targetKey);\n                }\n                let dropPosition = target.type === 'item' ? target.dropPosition : 'after';\n\n                // If there is no next key, or we are starting on the last key, jump to the last possible position.\n                if (nextKey == null || (target.type === 'item' && target.key === keyboardDelegate.getLastKey?.())) {\n                  nextKey = keyboardDelegate.getLastKey?.() ?? null;\n                  dropPosition = 'after';\n                }\n\n                if (nextKey == null) {\n                  break;\n                }\n                target = {\n                  type: 'item',\n                  key: nextKey,\n                  dropPosition\n                };\n\n                // If the target does not accept the drop, find the next valid target.\n                // If no next valid target, find the previous valid target.\n                let {draggingCollectionRef, draggingKeys} = globalDndState;\n                let isInternal = draggingCollectionRef?.current === ref?.current;\n                let operation = localState.state.getDropOperation({target, types, allowedOperations: drag.allowedDropOperations, isInternal, draggingKeys});\n                if (operation === 'cancel') {\n                  target = nextValidTarget(target, types, drag.allowedDropOperations, getNextTarget, false)\n                    ?? nextValidTarget(target, types, drag.allowedDropOperations, getPreviousTarget, false);\n                }\n              }\n\n              localState.state.setTarget(target ?? localState.state.target);\n            }\n            break;\n          }\n          case 'PageUp': {\n            if (!keyboardDelegate.getKeyPageAbove) {\n              break;\n            }\n\n            let target = localState.state.target;\n            if (!target) {\n              target = nextValidTarget(null, types, drag.allowedDropOperations, getPreviousTarget);\n            } else if (target.type === 'item') {\n              // If at the top already, switch to the root. Otherwise navigate a page up.\n              if (target.key === keyboardDelegate.getFirstKey?.()) {\n                target = {\n                  type: 'root'\n                };\n              } else {\n                let nextKey: Key | null | undefined = keyboardDelegate.getKeyPageAbove(target.key);\n                let dropPosition = target.dropPosition;\n                if (nextKey == null) {\n                  nextKey = keyboardDelegate.getFirstKey?.();\n                  dropPosition = 'before';\n                }\n\n                if (nextKey == null) {\n                  break;\n                }\n                target = {\n                  type: 'item',\n                  key: nextKey,\n                  dropPosition\n                };\n              }\n\n              // If the target does not accept the drop, find the previous valid target.\n              // If no next valid target, find the next valid target.\n              let {draggingKeys} = globalDndState;\n              let isInternal = isInternalDropOperation(ref);\n              let operation = localState.state.getDropOperation({target, types, allowedOperations: drag.allowedDropOperations, isInternal, draggingKeys});\n              if (operation === 'cancel') {\n                target = nextValidTarget(target, types, drag.allowedDropOperations, getPreviousTarget, false)\n                  ?? nextValidTarget(target, types, drag.allowedDropOperations, getNextTarget, false);\n              }\n            }\n\n            localState.state.setTarget(target ?? localState.state.target);\n            break;\n          }\n        }\n      }\n    });\n  }, [localState, ref, onDrop, direction]);\n\n  let id = useId();\n  droppableCollectionMap.set(state, {id, ref});\n  return {\n    collectionProps: mergeProps(dropProps, {\n      id,\n      // Remove description from collection element. If dropping on the entire collection,\n      // there should be a drop indicator that has this description, so no need to double announce.\n      'aria-describedby': null\n    })\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"\"use client\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/query-data.tsx\nimport React from \"react\";\nimport useSWR, { SWRConfig, useSWRConfig } from \"swr\";\nvar __SWRConfig = void 0;\nvar mutateKeys = invalidateKey => {\n  if (__SWRConfig) {\n    const {\n      cache,\n      mutate\n    } = __SWRConfig;\n    (invalidateKey != null ? [invalidateKey] : Array.from(cache.keys())).forEach(key => {\n      mutate(key);\n    });\n  }\n};\nfunction getPlasmicDefaultSWROptions(opts) {\n  return {\n    revalidateIfStale: !!(opts == null ? void 0 : opts.isMutable),\n    revalidateOnFocus: false,\n    revalidateOnReconnect: false\n  };\n}\nfunction usePlasmicQueryData(key, fetcher) {\n  const prepassCtx = React.useContext(PrepassContext);\n  const opts = getPlasmicDefaultSWROptions();\n  if (prepassCtx) {\n    opts.suspense = true;\n  }\n  const config = useSWRConfig();\n  React.useEffect(() => {\n    __SWRConfig = config;\n  }, [config]);\n  const wrappedFetcher = React.useMemo(() => wrapLoadingFetcher(fetcher), [fetcher]);\n  const resp = useSWR(key, wrappedFetcher, opts);\n  if (resp.data !== void 0) {\n    return {\n      data: resp.data\n    };\n  } else if (resp.error) {\n    return {\n      error: resp.error\n    };\n  } else {\n    return {\n      isLoading: true\n    };\n  }\n}\nfunction useMutablePlasmicQueryData(key, fetcher, options) {\n  var _this = this;\n  const prepassCtx = React.useContext(PrepassContext);\n  const opts = __spreadValues(__spreadValues({}, getPlasmicDefaultSWROptions({\n    isMutable: true\n  })), options);\n  if (prepassCtx) {\n    opts.suspense = true;\n  }\n  const config = useSWRConfig();\n  React.useEffect(() => {\n    __SWRConfig = config;\n  }, [config]);\n  const [isLoading, setIsLoading] = React.useState(false);\n  const fetcherWrapper = React.useCallback(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return __async(_this, null, function* () {\n      setIsLoading(true);\n      try {\n        return yield wrapLoadingFetcher(fetcher)(...args);\n      } finally {\n        setIsLoading(false);\n      }\n    });\n  }, [fetcher]);\n  const laggyDataRef = React.useRef();\n  const {\n    isValidating,\n    mutate,\n    data,\n    error\n  } = useSWR(key, fetcherWrapper, opts);\n  React.useEffect(() => {\n    if (data !== void 0) {\n      laggyDataRef.current = data;\n    }\n  }, [data]);\n  return React.useMemo(() => __spreadValues(__spreadValues({\n    isValidating,\n    mutate,\n    isLoading: data === void 0 && error === void 0 || isLoading\n  }, data !== void 0 ? {\n    data\n  } : error === void 0 && laggyDataRef.current ?\n  // Show previous data if available\n  {\n    data: laggyDataRef.current,\n    isLagging: true\n  } : {}), error !== void 0 ? {\n    error\n  } : {}), [isValidating, mutate, data, error, isLoading]);\n}\nfunction PlasmicQueryDataProvider(props) {\n  const {\n    children,\n    suspense,\n    prefetchedCache\n  } = props;\n  const prepass = React.useContext(PrepassContext);\n  if (prepass) {\n    return /* @__PURE__ */React.createElement(React.Fragment, null, children);\n  } else {\n    return /* @__PURE__ */React.createElement(SWRConfig, {\n      value: {\n        fallback: prefetchedCache != null ? prefetchedCache : {},\n        suspense\n      }\n    }, children);\n  }\n}\nvar PrepassContext = React.createContext(false);\nfunction PlasmicPrepassContext(props) {\n  const {\n    cache,\n    children\n  } = props;\n  return /* @__PURE__ */React.createElement(PrepassContext.Provider, {\n    value: true\n  }, /* @__PURE__ */React.createElement(SWRConfig, {\n    value: {\n      provider: () => cache,\n      suspense: true,\n      fallback: {}\n    }\n  }, children));\n}\nvar usePlasmicDataConfig = useSWRConfig;\nvar loadingCount = 0;\nvar listeners = [];\nfunction addLoadingStateListener(listener, opts) {\n  listeners.push(listener);\n  if (opts == null ? void 0 : opts.immediate) {\n    listener(loadingCount > 0);\n  }\n  return () => {\n    listeners.splice(listeners.indexOf(listener), 1);\n  };\n}\nfunction wrapLoadingFetcher(fetcher) {\n  var _this2 = this;\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    return __async(_this2, null, function* () {\n      if (loadingCount === 0) {\n        listeners.forEach(listener => listener(true));\n      }\n      loadingCount += 1;\n      try {\n        const res = fetcher(...args);\n        return isPromiseLike(res) ? yield res : res;\n      } finally {\n        loadingCount -= 1;\n        if (loadingCount === 0) {\n          listeners.forEach(listener => listener(false));\n        }\n      }\n    });\n  };\n}\nfunction isPromiseLike(x) {\n  return !!x && typeof x === \"object\" && \"then\" in x && typeof x.then === \"function\";\n}\nfunction isPlasmicPrepass() {\n  var _a, _b, _c;\n  return !!((_c = (_b = (_a = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) == null ? void 0 : _a.ReactCurrentDispatcher) == null ? void 0 : _b.current) == null ? void 0 : _c.isPlasmicPrepass);\n}\nvar HeadMetadataContext = React.createContext({});\n\n// src/index.tsx\nimport { useSWRConfig as useSWRConfig2 } from \"swr\";\nif (typeof window !== \"undefined\") {\n  const root = window;\n  const maybeExistingMutateAllKeys = root.__SWRMutateAllKeys;\n  root.__SWRMutateAllKeys = invalidateKey => {\n    mutateKeys(invalidateKey);\n    if (typeof maybeExistingMutateAllKeys === \"function\") {\n      maybeExistingMutateAllKeys(invalidateKey);\n    }\n  };\n}\nexport { HeadMetadataContext, PlasmicPrepassContext, PlasmicQueryDataProvider, addLoadingStateListener, isPlasmicPrepass, useMutablePlasmicQueryData, usePlasmicDataConfig, usePlasmicQueryData, useSWRConfig2 as useSWRConfig, wrapLoadingFetcher };","map":{"version":3,"names":["React","useSWR","SWRConfig","useSWRConfig","__SWRConfig","mutateKeys","invalidateKey","cache","mutate","Array","from","keys","forEach","key","getPlasmicDefaultSWROptions","opts","revalidateIfStale","isMutable","revalidateOnFocus","revalidateOnReconnect","usePlasmicQueryData","fetcher","prepassCtx","useContext","PrepassContext","suspense","config","useEffect","wrappedFetcher","useMemo","wrapLoadingFetcher","resp","data","error","isLoading","useMutablePlasmicQueryData","options","_this","__spreadValues","setIsLoading","useState","fetcherWrapper","useCallback","_len","arguments","length","args","_key","__async","laggyDataRef","useRef","isValidating","current","isLagging","PlasmicQueryDataProvider","props","children","prefetchedCache","prepass","createElement","Fragment","value","fallback","createContext","PlasmicPrepassContext","Provider","provider","usePlasmicDataConfig","loadingCount","listeners","addLoadingStateListener","listener","push","immediate","splice","indexOf","_this2","_len2","_key2","res","isPromiseLike","x","then","isPlasmicPrepass","_a","_b","_c","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentDispatcher","HeadMetadataContext","useSWRConfig2","window","root","maybeExistingMutateAllKeys","__SWRMutateAllKeys"],"sources":["C:\\Users\\rewac\\OneDrive\\Documents\\GitHub\\scatch-store.me\\node_modules\\@plasmicapp\\query\\src\\query-data.tsx","C:\\Users\\rewac\\OneDrive\\Documents\\GitHub\\scatch-store.me\\node_modules\\@plasmicapp\\query\\src\\index.tsx"],"sourcesContent":["import React, { PropsWithChildren } from \"react\";\nimport useSWR, {\n  Fetcher,\n  Key,\n  SWRConfig,\n  SWRConfiguration,\n  SWRResponse,\n  useSWRConfig,\n} from \"swr\";\n\nexport type { SWRResponse } from \"swr\";\n\nlet __SWRConfig: ReturnType<typeof useSWRConfig> | undefined = undefined;\nexport const mutateKeys = (invalidateKey?: string) => {\n  if (__SWRConfig) {\n    const { cache, mutate } = __SWRConfig;\n    (invalidateKey != null\n      ? [invalidateKey]\n      : Array.from((cache as Map<string, any>).keys())\n    ).forEach((key) => {\n      mutate(key);\n    });\n  }\n};\n\n// @plasmicapp/query is optimized for SSR, so we do not revalidate\n// automatically upon hydration; as if the data is immutable.\nfunction getPlasmicDefaultSWROptions(opts?: {\n  isMutable?: boolean;\n}): SWRConfiguration {\n  return {\n    revalidateIfStale: !!opts?.isMutable,\n    revalidateOnFocus: false,\n    revalidateOnReconnect: false,\n  };\n}\n\n/**\n * Fetches data asynchronously. This data should be considered immutable for the\n * session -- there is no way to invalidate or re-fetch this data.\n *\n * @param key a unique key for this data fetch; if data already exists under this\n *   key, that data is returned immediately.\n * @param fetcher an async function that resolves to the fetched data.\n * @returns an object with either a \"data\" key with the fetched data if the fetch\n *   was successful, or an \"error\" key with the thrown Error if the fetch failed.\n */\nexport function usePlasmicQueryData<T>(\n  key: Key,\n  fetcher: Fetcher<T>\n): { data?: T; error?: Error; isLoading?: boolean } {\n  const prepassCtx = React.useContext(PrepassContext);\n\n  const opts = getPlasmicDefaultSWROptions();\n  if (prepassCtx) {\n    // If we're doing prepass, then we are always in suspense mode, because\n    // react-ssr-prepass only works with suspense-throwing data fetching.\n    opts.suspense = true;\n  }\n\n  const config = useSWRConfig();\n  React.useEffect(() => {\n    __SWRConfig = config;\n  }, [config]);\n\n  const wrappedFetcher = React.useMemo(\n    () => wrapLoadingFetcher(fetcher),\n    [fetcher]\n  );\n\n  const resp = useSWR(key, wrappedFetcher, opts);\n  if (resp.data !== undefined) {\n    return { data: resp.data };\n  } else if (resp.error) {\n    return { error: resp.error };\n  } else {\n    return { isLoading: true };\n  }\n}\n\n/**\n * Fetches data asynchronously using SWR Hook (https://swr.vercel.app/)\n *\n * @param key a unique key for this data fetch; if data already exists under this\n *   key, that data is returned immediately.\n * @param fetcher an async function that resolves to the fetched data.\n * @param options (optional) an object of options for this hook (https://swr.vercel.app/docs/options).\n * @returns an object with either a \"data\" key with the fetched data if the fetch\n *   was successful, or an \"error\" key with the thrown Error if the fetch failed.\n */\nexport function useMutablePlasmicQueryData<T, E>(\n  key: Key,\n  fetcher: Fetcher<T>,\n  options?: SWRConfiguration<T, E>\n): SWRResponse<T, E> & { isLoading?: boolean; isLagging?: boolean } {\n  const prepassCtx = React.useContext(PrepassContext);\n\n  const opts = {\n    ...getPlasmicDefaultSWROptions({ isMutable: true }),\n    ...options,\n  };\n  if (prepassCtx) {\n    opts.suspense = true;\n  }\n\n  const config = useSWRConfig();\n  React.useEffect(() => {\n    __SWRConfig = config;\n  }, [config]);\n\n  const [isLoading, setIsLoading] = React.useState(false);\n  const fetcherWrapper = React.useCallback(\n    async (...args: any[]) => {\n      setIsLoading(true);\n      try {\n        return await wrapLoadingFetcher(fetcher)(...args);\n      } finally {\n        setIsLoading(false);\n      }\n    },\n    [fetcher]\n  );\n\n  // Based on https://swr.vercel.app/docs/middleware#keep-previous-result\n  const laggyDataRef = React.useRef<any>();\n\n  const { isValidating, mutate, data, error } = useSWR(\n    key,\n    fetcherWrapper,\n    opts\n  );\n\n  React.useEffect(() => {\n    if (data !== undefined) {\n      laggyDataRef.current = data;\n    }\n  }, [data]);\n\n  return React.useMemo(\n    () => ({\n      isValidating,\n      mutate,\n      isLoading: (data === undefined && error === undefined) || isLoading,\n      ...(data !== undefined\n        ? { data }\n        : error === undefined && laggyDataRef.current\n        ? // Show previous data if available\n          { data: laggyDataRef.current, isLagging: true }\n        : {}),\n      ...(error !== undefined ? { error } : {}),\n    }),\n    [isValidating, mutate, data, error, isLoading]\n  );\n}\n\nexport function PlasmicQueryDataProvider(props: {\n  suspense?: boolean;\n  children: React.ReactNode;\n  prefetchedCache?: Record<string, any>;\n}) {\n  const { children, suspense, prefetchedCache } = props;\n  const prepass = React.useContext(PrepassContext);\n  if (prepass) {\n    // If we're in prepass, then there's already a wrappign SWRConfig;\n    // don't interfere with it.\n    return <>{children}</>;\n  } else {\n    return (\n      <SWRConfig\n        value={{\n          fallback: prefetchedCache ?? {},\n          suspense,\n        }}\n      >\n        {children}\n      </SWRConfig>\n    );\n  }\n}\n\nconst PrepassContext = React.createContext<boolean>(false);\n\nexport function PlasmicPrepassContext(\n  props: PropsWithChildren<{\n    cache: Map<string, any>;\n  }>\n) {\n  const { cache, children } = props;\n  return (\n    <PrepassContext.Provider value={true}>\n      <SWRConfig\n        value={{\n          provider: () => cache,\n          suspense: true,\n          fallback: {},\n        }}\n      >\n        {children}\n      </SWRConfig>\n    </PrepassContext.Provider>\n  );\n}\n\nexport const usePlasmicDataConfig: typeof useSWRConfig = useSWRConfig;\n\nlet loadingCount = 0;\nexport type LoadingStateListener = (isLoading: boolean) => void;\nconst listeners: LoadingStateListener[] = [];\n\n/**\n * Subscribes to whether any loading is happening via @plasmicapp/query.\n * Returns a function to unsubscribe.\n */\nexport function addLoadingStateListener(\n  listener: LoadingStateListener,\n  opts?: { immediate?: boolean }\n) {\n  listeners.push(listener);\n  if (opts?.immediate) {\n    listener(loadingCount > 0);\n  }\n  return () => {\n    listeners.splice(listeners.indexOf(listener), 1);\n  };\n}\n\n/**\n * Instruments an async function to increment and decrement the number of\n * simultaneous async loads. You can then subscribe to whether there\n * are any loads happening via addLoadingStateListener().\n */\nexport function wrapLoadingFetcher<\n  T extends (...args: any[]) => Promise<any> | any\n>(fetcher: T): T {\n  return (async (...args: any) => {\n    if (loadingCount === 0) {\n      listeners.forEach((listener) => listener(true));\n    }\n    loadingCount += 1;\n    try {\n      const res = fetcher(...args);\n      return isPromiseLike(res) ? await res : res;\n    } finally {\n      loadingCount -= 1;\n      if (loadingCount === 0) {\n        listeners.forEach((listener) => listener(false));\n      }\n    }\n  }) as T;\n}\n\nfunction isPromiseLike(x: any) {\n  return (\n    !!x && typeof x === \"object\" && \"then\" in x && typeof x.then === \"function\"\n  );\n}\n\nexport function isPlasmicPrepass() {\n  return !!(React as any).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n    ?.ReactCurrentDispatcher?.current?.isPlasmicPrepass;\n}\n\nexport type HeadMetadata = {\n  title?: string;\n  description?: string;\n  image?: string;\n  canonical?: string;\n};\n\nexport const HeadMetadataContext = React.createContext<HeadMetadata>({});\n","import { mutateKeys } from \"./query-data\";\nexport { useSWRConfig } from \"swr\";\nexport {\n  addLoadingStateListener,\n  HeadMetadataContext,\n  isPlasmicPrepass,\n  PlasmicPrepassContext,\n  PlasmicQueryDataProvider,\n  useMutablePlasmicQueryData,\n  usePlasmicDataConfig,\n  usePlasmicQueryData,\n  wrapLoadingFetcher,\n} from \"./query-data\";\nexport type {\n  HeadMetadata,\n  LoadingStateListener,\n  SWRResponse,\n} from \"./query-data\";\n\nif (typeof window !== \"undefined\") {\n  const root = window as any;\n  const maybeExistingMutateAllKeys = root.__SWRMutateAllKeys;\n  root.__SWRMutateAllKeys = (invalidateKey?: string) => {\n    mutateKeys(invalidateKey);\n    if (typeof maybeExistingMutateAllKeys === \"function\") {\n      maybeExistingMutateAllKeys(invalidateKey);\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
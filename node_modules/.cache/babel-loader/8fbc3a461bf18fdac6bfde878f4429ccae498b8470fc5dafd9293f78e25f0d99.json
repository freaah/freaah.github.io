{"ast":null,"code":"\"use client\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/query-data.tsx\nimport React from \"react\";\nimport useSWR, { SWRConfig, useSWRConfig } from \"swr\";\nvar __SWRConfig = void 0;\nvar mutateKeys = invalidateKey => {\n  if (__SWRConfig) {\n    const {\n      cache,\n      mutate\n    } = __SWRConfig;\n    (invalidateKey != null ? [invalidateKey] : Array.from(cache.keys())).forEach(key => {\n      mutate(key);\n    });\n  }\n};\nfunction getPlasmicDefaultSWROptions(opts) {\n  return {\n    revalidateIfStale: !!(opts == null ? void 0 : opts.isMutable),\n    revalidateOnFocus: false,\n    revalidateOnReconnect: false\n  };\n}\nfunction usePlasmicQueryData(key, fetcher) {\n  const prepassCtx = React.useContext(PrepassContext);\n  const opts = getPlasmicDefaultSWROptions();\n  if (prepassCtx) {\n    opts.suspense = true;\n  }\n  const config = useSWRConfig();\n  React.useEffect(() => {\n    __SWRConfig = config;\n  }, [config]);\n  const wrappedFetcher = React.useMemo(() => wrapLoadingFetcher(fetcher), [fetcher]);\n  const resp = useSWR(key, wrappedFetcher, opts);\n  if (resp.data !== void 0) {\n    return {\n      data: resp.data\n    };\n  } else if (resp.error) {\n    return {\n      error: resp.error\n    };\n  } else {\n    return {\n      isLoading: true\n    };\n  }\n}\nfunction useMutablePlasmicQueryData(key, fetcher, options) {\n  const prepassCtx = React.useContext(PrepassContext);\n  const opts = __spreadValues(__spreadValues({}, getPlasmicDefaultSWROptions({\n    isMutable: true\n  })), options);\n  if (prepassCtx) {\n    opts.suspense = true;\n  }\n  const config = useSWRConfig();\n  React.useEffect(() => {\n    __SWRConfig = config;\n  }, [config]);\n  const [isLoading, setIsLoading] = React.useState(false);\n  const fetcherWrapper = React.useCallback((...args) => __async(this, null, function* () {\n    setIsLoading(true);\n    try {\n      return yield wrapLoadingFetcher(fetcher)(...args);\n    } finally {\n      setIsLoading(false);\n    }\n  }), [fetcher]);\n  const laggyDataRef = React.useRef();\n  const {\n    isValidating,\n    mutate,\n    data,\n    error\n  } = useSWR(key, fetcherWrapper, opts);\n  React.useEffect(() => {\n    if (data !== void 0) {\n      laggyDataRef.current = data;\n    }\n  }, [data]);\n  return React.useMemo(() => __spreadValues(__spreadValues({\n    isValidating,\n    mutate,\n    isLoading: data === void 0 && error === void 0 || isLoading\n  }, data !== void 0 ? {\n    data\n  } : error === void 0 && laggyDataRef.current ?\n  // Show previous data if available\n  {\n    data: laggyDataRef.current,\n    isLagging: true\n  } : {}), error !== void 0 ? {\n    error\n  } : {}), [isValidating, mutate, data, error, isLoading]);\n}\nfunction PlasmicQueryDataProvider(props) {\n  const {\n    children,\n    suspense,\n    prefetchedCache\n  } = props;\n  const prepass = React.useContext(PrepassContext);\n  if (prepass) {\n    return /* @__PURE__ */React.createElement(React.Fragment, null, children);\n  } else {\n    return /* @__PURE__ */React.createElement(SWRConfig, {\n      value: {\n        fallback: prefetchedCache != null ? prefetchedCache : {},\n        suspense\n      }\n    }, children);\n  }\n}\nvar PrepassContext = React.createContext(false);\nfunction PlasmicPrepassContext(props) {\n  const {\n    cache,\n    children\n  } = props;\n  return /* @__PURE__ */React.createElement(PrepassContext.Provider, {\n    value: true\n  }, /* @__PURE__ */React.createElement(SWRConfig, {\n    value: {\n      provider: () => cache,\n      suspense: true,\n      fallback: {}\n    }\n  }, children));\n}\nvar usePlasmicDataConfig = useSWRConfig;\nvar loadingCount = 0;\nvar listeners = [];\nfunction addLoadingStateListener(listener, opts) {\n  listeners.push(listener);\n  if (opts == null ? void 0 : opts.immediate) {\n    listener(loadingCount > 0);\n  }\n  return () => {\n    listeners.splice(listeners.indexOf(listener), 1);\n  };\n}\nfunction wrapLoadingFetcher(fetcher) {\n  return (...args) => __async(this, null, function* () {\n    if (loadingCount === 0) {\n      listeners.forEach(listener => listener(true));\n    }\n    loadingCount += 1;\n    try {\n      const res = fetcher(...args);\n      return isPromiseLike(res) ? yield res : res;\n    } finally {\n      loadingCount -= 1;\n      if (loadingCount === 0) {\n        listeners.forEach(listener => listener(false));\n      }\n    }\n  });\n}\nfunction isPromiseLike(x) {\n  return !!x && typeof x === \"object\" && \"then\" in x && typeof x.then === \"function\";\n}\nfunction isPlasmicPrepass() {\n  var _a, _b, _c;\n  return !!((_c = (_b = (_a = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) == null ? void 0 : _a.ReactCurrentDispatcher) == null ? void 0 : _b.current) == null ? void 0 : _c.isPlasmicPrepass);\n}\nvar HeadMetadataContext = React.createContext({});\n\n// src/index.tsx\nimport { useSWRConfig as useSWRConfig2 } from \"swr\";\nif (typeof window !== \"undefined\") {\n  const root = window;\n  const maybeExistingMutateAllKeys = root.__SWRMutateAllKeys;\n  root.__SWRMutateAllKeys = invalidateKey => {\n    mutateKeys(invalidateKey);\n    if (typeof maybeExistingMutateAllKeys === \"function\") {\n      maybeExistingMutateAllKeys(invalidateKey);\n    }\n  };\n}\nexport { HeadMetadataContext, PlasmicPrepassContext, PlasmicQueryDataProvider, addLoadingStateListener, isPlasmicPrepass, useMutablePlasmicQueryData, usePlasmicDataConfig, usePlasmicQueryData, useSWRConfig2 as useSWRConfig, wrapLoadingFetcher };","map":{"version":3,"names":["React","useSWR","SWRConfig","useSWRConfig","__SWRConfig","mutateKeys","invalidateKey","cache","mutate","Array","from","keys","forEach","key","getPlasmicDefaultSWROptions","opts","revalidateIfStale","isMutable","revalidateOnFocus","revalidateOnReconnect","usePlasmicQueryData","fetcher","prepassCtx","useContext","PrepassContext","suspense","config","useEffect","wrappedFetcher","useMemo","wrapLoadingFetcher","resp","data","error","isLoading","useMutablePlasmicQueryData","options","__spreadValues","setIsLoading","useState","fetcherWrapper","useCallback","args","__async","laggyDataRef","useRef","isValidating","current","isLagging","PlasmicQueryDataProvider","props","children","prefetchedCache","prepass","createElement","Fragment","value","fallback","createContext","PlasmicPrepassContext","Provider","provider","usePlasmicDataConfig","loadingCount","listeners","addLoadingStateListener","listener","push","immediate","splice","indexOf","res","isPromiseLike","x","then","isPlasmicPrepass","_a","_b","_c","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentDispatcher","HeadMetadataContext","useSWRConfig2","window","root","maybeExistingMutateAllKeys","__SWRMutateAllKeys"],"sources":["C:\\Users\\rewac\\OneDrive\\Documents\\GitHub\\scatch-store.me\\node_modules\\@plasmicapp\\query\\src\\query-data.tsx","C:\\Users\\rewac\\OneDrive\\Documents\\GitHub\\scatch-store.me\\node_modules\\@plasmicapp\\query\\src\\index.tsx"],"sourcesContent":["import React, { PropsWithChildren } from \"react\";\nimport useSWR, {\n  Fetcher,\n  Key,\n  SWRConfig,\n  SWRConfiguration,\n  SWRResponse,\n  useSWRConfig,\n} from \"swr\";\n\nexport type { SWRResponse } from \"swr\";\n\nlet __SWRConfig: ReturnType<typeof useSWRConfig> | undefined = undefined;\nexport const mutateKeys = (invalidateKey?: string) => {\n  if (__SWRConfig) {\n    const { cache, mutate } = __SWRConfig;\n    (invalidateKey != null\n      ? [invalidateKey]\n      : Array.from((cache as Map<string, any>).keys())\n    ).forEach((key) => {\n      mutate(key);\n    });\n  }\n};\n\n// @plasmicapp/query is optimized for SSR, so we do not revalidate\n// automatically upon hydration; as if the data is immutable.\nfunction getPlasmicDefaultSWROptions(opts?: {\n  isMutable?: boolean;\n}): SWRConfiguration {\n  return {\n    revalidateIfStale: !!opts?.isMutable,\n    revalidateOnFocus: false,\n    revalidateOnReconnect: false,\n  };\n}\n\n/**\n * Fetches data asynchronously. This data should be considered immutable for the\n * session -- there is no way to invalidate or re-fetch this data.\n *\n * @param key a unique key for this data fetch; if data already exists under this\n *   key, that data is returned immediately.\n * @param fetcher an async function that resolves to the fetched data.\n * @returns an object with either a \"data\" key with the fetched data if the fetch\n *   was successful, or an \"error\" key with the thrown Error if the fetch failed.\n */\nexport function usePlasmicQueryData<T>(\n  key: Key,\n  fetcher: Fetcher<T>\n): { data?: T; error?: Error; isLoading?: boolean } {\n  const prepassCtx = React.useContext(PrepassContext);\n\n  const opts = getPlasmicDefaultSWROptions();\n  if (prepassCtx) {\n    // If we're doing prepass, then we are always in suspense mode, because\n    // react-ssr-prepass only works with suspense-throwing data fetching.\n    opts.suspense = true;\n  }\n\n  const config = useSWRConfig();\n  React.useEffect(() => {\n    __SWRConfig = config;\n  }, [config]);\n\n  const wrappedFetcher = React.useMemo(\n    () => wrapLoadingFetcher(fetcher),\n    [fetcher]\n  );\n\n  const resp = useSWR(key, wrappedFetcher, opts);\n  if (resp.data !== undefined) {\n    return { data: resp.data };\n  } else if (resp.error) {\n    return { error: resp.error };\n  } else {\n    return { isLoading: true };\n  }\n}\n\n/**\n * Fetches data asynchronously using SWR Hook (https://swr.vercel.app/)\n *\n * @param key a unique key for this data fetch; if data already exists under this\n *   key, that data is returned immediately.\n * @param fetcher an async function that resolves to the fetched data.\n * @param options (optional) an object of options for this hook (https://swr.vercel.app/docs/options).\n * @returns an object with either a \"data\" key with the fetched data if the fetch\n *   was successful, or an \"error\" key with the thrown Error if the fetch failed.\n */\nexport function useMutablePlasmicQueryData<T, E>(\n  key: Key,\n  fetcher: Fetcher<T>,\n  options?: SWRConfiguration<T, E>\n): SWRResponse<T, E> & { isLoading?: boolean; isLagging?: boolean } {\n  const prepassCtx = React.useContext(PrepassContext);\n\n  const opts = {\n    ...getPlasmicDefaultSWROptions({ isMutable: true }),\n    ...options,\n  };\n  if (prepassCtx) {\n    opts.suspense = true;\n  }\n\n  const config = useSWRConfig();\n  React.useEffect(() => {\n    __SWRConfig = config;\n  }, [config]);\n\n  const [isLoading, setIsLoading] = React.useState(false);\n  const fetcherWrapper = React.useCallback(\n    async (...args: any[]) => {\n      setIsLoading(true);\n      try {\n        return await wrapLoadingFetcher(fetcher)(...args);\n      } finally {\n        setIsLoading(false);\n      }\n    },\n    [fetcher]\n  );\n\n  // Based on https://swr.vercel.app/docs/middleware#keep-previous-result\n  const laggyDataRef = React.useRef<any>();\n\n  const { isValidating, mutate, data, error } = useSWR(\n    key,\n    fetcherWrapper,\n    opts\n  );\n\n  React.useEffect(() => {\n    if (data !== undefined) {\n      laggyDataRef.current = data;\n    }\n  }, [data]);\n\n  return React.useMemo(\n    () => ({\n      isValidating,\n      mutate,\n      isLoading: (data === undefined && error === undefined) || isLoading,\n      ...(data !== undefined\n        ? { data }\n        : error === undefined && laggyDataRef.current\n        ? // Show previous data if available\n          { data: laggyDataRef.current, isLagging: true }\n        : {}),\n      ...(error !== undefined ? { error } : {}),\n    }),\n    [isValidating, mutate, data, error, isLoading]\n  );\n}\n\nexport function PlasmicQueryDataProvider(props: {\n  suspense?: boolean;\n  children: React.ReactNode;\n  prefetchedCache?: Record<string, any>;\n}) {\n  const { children, suspense, prefetchedCache } = props;\n  const prepass = React.useContext(PrepassContext);\n  if (prepass) {\n    // If we're in prepass, then there's already a wrappign SWRConfig;\n    // don't interfere with it.\n    return <>{children}</>;\n  } else {\n    return (\n      <SWRConfig\n        value={{\n          fallback: prefetchedCache ?? {},\n          suspense,\n        }}\n      >\n        {children}\n      </SWRConfig>\n    );\n  }\n}\n\nconst PrepassContext = React.createContext<boolean>(false);\n\nexport function PlasmicPrepassContext(\n  props: PropsWithChildren<{\n    cache: Map<string, any>;\n  }>\n) {\n  const { cache, children } = props;\n  return (\n    <PrepassContext.Provider value={true}>\n      <SWRConfig\n        value={{\n          provider: () => cache,\n          suspense: true,\n          fallback: {},\n        }}\n      >\n        {children}\n      </SWRConfig>\n    </PrepassContext.Provider>\n  );\n}\n\nexport const usePlasmicDataConfig: typeof useSWRConfig = useSWRConfig;\n\nlet loadingCount = 0;\nexport type LoadingStateListener = (isLoading: boolean) => void;\nconst listeners: LoadingStateListener[] = [];\n\n/**\n * Subscribes to whether any loading is happening via @plasmicapp/query.\n * Returns a function to unsubscribe.\n */\nexport function addLoadingStateListener(\n  listener: LoadingStateListener,\n  opts?: { immediate?: boolean }\n) {\n  listeners.push(listener);\n  if (opts?.immediate) {\n    listener(loadingCount > 0);\n  }\n  return () => {\n    listeners.splice(listeners.indexOf(listener), 1);\n  };\n}\n\n/**\n * Instruments an async function to increment and decrement the number of\n * simultaneous async loads. You can then subscribe to whether there\n * are any loads happening via addLoadingStateListener().\n */\nexport function wrapLoadingFetcher<\n  T extends (...args: any[]) => Promise<any> | any\n>(fetcher: T): T {\n  return (async (...args: any) => {\n    if (loadingCount === 0) {\n      listeners.forEach((listener) => listener(true));\n    }\n    loadingCount += 1;\n    try {\n      const res = fetcher(...args);\n      return isPromiseLike(res) ? await res : res;\n    } finally {\n      loadingCount -= 1;\n      if (loadingCount === 0) {\n        listeners.forEach((listener) => listener(false));\n      }\n    }\n  }) as T;\n}\n\nfunction isPromiseLike(x: any) {\n  return (\n    !!x && typeof x === \"object\" && \"then\" in x && typeof x.then === \"function\"\n  );\n}\n\nexport function isPlasmicPrepass() {\n  return !!(React as any).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n    ?.ReactCurrentDispatcher?.current?.isPlasmicPrepass;\n}\n\nexport type HeadMetadata = {\n  title?: string;\n  description?: string;\n  image?: string;\n  canonical?: string;\n};\n\nexport const HeadMetadataContext = React.createContext<HeadMetadata>({});\n","import { mutateKeys } from \"./query-data\";\nexport { useSWRConfig } from \"swr\";\nexport {\n  addLoadingStateListener,\n  HeadMetadataContext,\n  isPlasmicPrepass,\n  PlasmicPrepassContext,\n  PlasmicQueryDataProvider,\n  useMutablePlasmicQueryData,\n  usePlasmicDataConfig,\n  usePlasmicQueryData,\n  wrapLoadingFetcher,\n} from \"./query-data\";\nexport type {\n  HeadMetadata,\n  LoadingStateListener,\n  SWRResponse,\n} from \"./query-data\";\n\nif (typeof window !== \"undefined\") {\n  const root = window as any;\n  const maybeExistingMutateAllKeys = root.__SWRMutateAllKeys;\n  root.__SWRMutateAllKeys = (invalidateKey?: string) => {\n    mutateKeys(invalidateKey);\n    if (typeof maybeExistingMutateAllKeys === \"function\") {\n      maybeExistingMutateAllKeys(invalidateKey);\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
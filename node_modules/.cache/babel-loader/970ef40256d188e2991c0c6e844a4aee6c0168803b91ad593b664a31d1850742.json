{"ast":null,"code":"import React from 'react';\nconst ARIA_COMPONENTS_VARIANTS = {\n  hovered: {\n    cssSelector: \"[data-hovered]\",\n    displayName: \"Hovered\"\n  },\n  pressed: {\n    cssSelector: \"[data-pressed]\",\n    displayName: \"Pressed\"\n  },\n  focused: {\n    cssSelector: \"[data-focused]\",\n    displayName: \"Focused\"\n  },\n  focusVisible: {\n    cssSelector: \"[data-focus-visible]\",\n    displayName: \"Focus Visible\"\n  },\n  dragging: {\n    cssSelector: \"[data-dragging]\",\n    displayName: \"Dragging\"\n  },\n  selected: {\n    cssSelector: \"[data-selected]\",\n    displayName: \"Selected\"\n  },\n  readonly: {\n    cssSelector: \"[data-readonly]\",\n    displayName: \"Read Only\"\n  },\n  disabled: {\n    cssSelector: \"[data-disabled]\",\n    displayName: \"Disabled\"\n  },\n  indeterminate: {\n    cssSelector: \"[data-indeterminate]\",\n    displayName: \"Indeterminate\"\n  },\n  /*\n    NOTE: Placement should be managed as variants, not just props.\n    When `shouldFlip` is true, the placement prop may not represent the final position\n    (e.g., if placement is set to \"bottom\" but lacks space, the popover/tooltip may flip to \"top\").\n    However, data-selectors will consistently indicate the actual placement of the popover/tooltip.\n  */\n  placementLeft: {\n    cssSelector: \"[data-placement=left]\",\n    displayName: \"Placement (Left)\"\n  },\n  placementRight: {\n    cssSelector: \"[data-placement=right]\",\n    displayName: \"Placement (Right)\"\n  },\n  placementTop: {\n    cssSelector: \"[data-placement=top]\",\n    displayName: \"Placement (Top)\"\n  },\n  placementBottom: {\n    cssSelector: \"[data-placement=bottom]\",\n    displayName: \"Placement (Bottom)\"\n  }\n};\nfunction ChangesObserver({\n  children,\n  changes,\n  updateVariant\n}) {\n  React.useEffect(() => {\n    if (updateVariant) {\n      updateVariant(changes);\n    }\n  }, [changes, updateVariant]);\n  return children;\n}\nfunction realWithObservedValues(children, changes, updateVariant) {\n  return /* @__PURE__ */React.createElement(ChangesObserver, {\n    changes,\n    updateVariant\n  }, children);\n}\nfunction pickAriaComponentVariants(keys) {\n  return {\n    variants: Object.fromEntries(keys.map(key => [key, ARIA_COMPONENTS_VARIANTS[key]])),\n    withObservedValues: realWithObservedValues\n  };\n}\nexport { pickAriaComponentVariants as p };","map":{"version":3,"names":["ARIA_COMPONENTS_VARIANTS","hovered","cssSelector","displayName","pressed","focused","focusVisible","dragging","selected","readonly","disabled","indeterminate","placementLeft","placementRight","placementTop","placementBottom","ChangesObserver","children","changes","updateVariant","React","useEffect","realWithObservedValues","createElement","pickAriaComponentVariants","keys","variants","Object","fromEntries","map","key","withObservedValues"],"sources":["C:\\Users\\rewac\\OneDrive\\Documents\\GitHub\\scatch-store.me\\node_modules\\@plasmicpkgs\\react-aria\\src\\variant-utils.tsx"],"sourcesContent":["import { CodeComponentMeta } from \"@plasmicapp/host\";\nimport React from \"react\";\n\nconst ARIA_COMPONENTS_VARIANTS = {\n  hovered: {\n    cssSelector: \"[data-hovered]\",\n    displayName: \"Hovered\",\n  },\n  pressed: {\n    cssSelector: \"[data-pressed]\",\n    displayName: \"Pressed\",\n  },\n  focused: {\n    cssSelector: \"[data-focused]\",\n    displayName: \"Focused\",\n  },\n  focusVisible: {\n    cssSelector: \"[data-focus-visible]\",\n    displayName: \"Focus Visible\",\n  },\n  dragging: {\n    cssSelector: \"[data-dragging]\",\n    displayName: \"Dragging\",\n  },\n  selected: {\n    cssSelector: \"[data-selected]\",\n    displayName: \"Selected\",\n  },\n  readonly: {\n    cssSelector: \"[data-readonly]\",\n    displayName: \"Read Only\",\n  },\n  disabled: {\n    cssSelector: \"[data-disabled]\",\n    displayName: \"Disabled\",\n  },\n  indeterminate: {\n    cssSelector: \"[data-indeterminate]\",\n    displayName: \"Indeterminate\",\n  },\n  /*\n    NOTE: Placement should be managed as variants, not just props.\n    When `shouldFlip` is true, the placement prop may not represent the final position\n    (e.g., if placement is set to \"bottom\" but lacks space, the popover/tooltip may flip to \"top\").\n    However, data-selectors will consistently indicate the actual placement of the popover/tooltip.\n  */\n  placementLeft: {\n    cssSelector: \"[data-placement=left]\",\n    displayName: \"Placement (Left)\",\n  },\n  placementRight: {\n    cssSelector: \"[data-placement=right]\",\n    displayName: \"Placement (Right)\",\n  },\n  placementTop: {\n    cssSelector: \"[data-placement=top]\",\n    displayName: \"Placement (Top)\",\n  },\n  placementBottom: {\n    cssSelector: \"[data-placement=bottom]\",\n    displayName: \"Placement (Bottom)\",\n  },\n};\n\ntype AriaVariant = keyof typeof ARIA_COMPONENTS_VARIANTS;\n\ntype CodeComponentVariantsMeta = NonNullable<\n  CodeComponentMeta<unknown>[\"variants\"]\n>;\n\ntype VariantMeta = CodeComponentVariantsMeta[string];\n\ntype ArrayElement<T> = T extends (infer U)[] ? U : never;\n\nexport type UpdateVariant<T extends AriaVariant[]> =\n  | ((changes: Partial<Record<ArrayElement<T>, boolean>>) => void)\n  | undefined;\n\nexport interface WithVariants<T extends AriaVariant[]> {\n  // Optional callback to update the CC variant state\n  // as it's only provided if the component is the root of a Studio component\n  plasmicUpdateVariant?: UpdateVariant<T>;\n}\n\ntype WithObservedValues<T extends AriaVariant[]> = (\n  children: React.ReactNode,\n  state: Record<ArrayElement<T>, boolean>,\n  updateVariant: UpdateVariant<T>\n) => React.ReactNode;\n\nfunction ChangesObserver<T extends AriaVariant[]>({\n  children,\n  changes,\n  updateVariant,\n}: {\n  children: React.ReactNode;\n  changes: Partial<Record<ArrayElement<T>, boolean>>;\n  updateVariant?: UpdateVariant<T>;\n}) {\n  React.useEffect(() => {\n    if (updateVariant) {\n      updateVariant(changes);\n    }\n  }, [changes, updateVariant]);\n  return children;\n}\n\nfunction realWithObservedValues<T extends AriaVariant[]>(\n  children: React.ReactNode,\n  changes: Partial<Record<ArrayElement<T>, boolean>>,\n  updateVariant?: UpdateVariant<T>\n) {\n  return (\n    <ChangesObserver changes={changes} updateVariant={updateVariant}>\n      {children}\n    </ChangesObserver>\n  );\n}\n\nexport function pickAriaComponentVariants<T extends AriaVariant[]>(\n  keys: T\n): {\n  variants: Record<ArrayElement<T>, VariantMeta>;\n  withObservedValues: WithObservedValues<T>;\n} {\n  return {\n    variants: Object.fromEntries(\n      keys.map((key) => [key, ARIA_COMPONENTS_VARIANTS[key]])\n    ) as Record<ArrayElement<T>, VariantMeta>,\n    withObservedValues: realWithObservedValues<T>,\n  };\n}\n"],"mappings":";AAGA,MAAMA,wBAA2B;EAC/BC,OAAS;IACPC,WAAa;IACbC,WAAa;EAAA,CACf;EACAC,OAAS;IACPF,WAAa;IACbC,WAAa;EAAA,CACf;EACAE,OAAS;IACPH,WAAa;IACbC,WAAa;EAAA,CACf;EACAG,YAAc;IACZJ,WAAa;IACbC,WAAa;EAAA,CACf;EACAI,QAAU;IACRL,WAAa;IACbC,WAAa;EAAA,CACf;EACAK,QAAU;IACRN,WAAa;IACbC,WAAa;EAAA,CACf;EACAM,QAAU;IACRP,WAAa;IACbC,WAAa;EAAA,CACf;EACAO,QAAU;IACRR,WAAa;IACbC,WAAa;EAAA,CACf;EACAQ,aAAe;IACbT,WAAa;IACbC,WAAa;EAAA,CACf;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAOAS,aAAe;IACbV,WAAa;IACbC,WAAa;EAAA,CACf;EACAU,cAAgB;IACdX,WAAa;IACbC,WAAa;EAAA,CACf;EACAW,YAAc;IACZZ,WAAa;IACbC,WAAa;EAAA,CACf;EACAY,eAAiB;IACfb,WAAa;IACbC,WAAa;EAAA;AAEjB;AA4BA,SAASa,eAAyCA,CAAA;EAChDC,QAAA;EACAC,OAAA;EACAC;AACF,CAIG;EACDC,KAAA,CAAMC,SAAA,CAAU,MAAM;IACpB,IAAIF,aAAe;MACjBA,aAAA,CAAcD,OAAO;IAAA;EACvB,CACC,GAACA,OAAS,EAAAC,aAAa,CAAC;EACpB,OAAAF,QAAA;AACT;AAEA,SAASK,uBACPL,QACA,EAAAC,OAAA,EACAC,aACA;EACA,sBACGC,KAAA,CAAAG,aAAA,CAAAP,eAAA;IAAgBE,OAAkB;IAAAC;EAAA,GAChCF,QACH;AAEJ;AAEO,SAASO,0BACdC,IAIA;EACO;IACLC,QAAA,EAAUC,MAAO,CAAAC,WAAA,CACfH,IAAA,CAAKI,GAAA,CAAKC,GAAA,IAAQ,CAACA,GAAK,EAAA9B,wBAAA,CAAyB8B,GAAG,CAAC,CAAC,EACxD;IACAC,kBAAoB,EAAAT;EAAA,CACtB;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
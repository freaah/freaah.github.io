{"ast":null,"code":"import $4ELxY$intlStringsmodulejs from \"./intlStrings.mjs\";\nimport { useId as $4ELxY$useId, useEffectEvent as $4ELxY$useEffectEvent, UPDATE_ACTIVEDESCENDANT as $4ELxY$UPDATE_ACTIVEDESCENDANT, useObjectRef as $4ELxY$useObjectRef, mergeRefs as $4ELxY$mergeRefs, FOCUS_EVENT as $4ELxY$FOCUS_EVENT, CLEAR_FOCUS_EVENT as $4ELxY$CLEAR_FOCUS_EVENT, isCtrlKeyPressed as $4ELxY$isCtrlKeyPressed, useLabels as $4ELxY$useLabels, mergeProps as $4ELxY$mergeProps } from \"@react-aria/utils\";\nimport { useRef as $4ELxY$useRef, useCallback as $4ELxY$useCallback, useMemo as $4ELxY$useMemo, useEffect as $4ELxY$useEffect } from \"react\";\nimport { useLocalizedStringFormatter as $4ELxY$useLocalizedStringFormatter } from \"@react-aria/i18n\";\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $48f6ba390f8c5b59$export$2d6947d4992da88e(props, state) {\n  let {\n    collectionRef: collectionRef,\n    filter: filter\n  } = props;\n  let collectionId = (0, $4ELxY$useId)();\n  let timeout = (0, $4ELxY$useRef)(undefined);\n  let delayNextActiveDescendant = (0, $4ELxY$useRef)(false);\n  let queuedActiveDescendant = (0, $4ELxY$useRef)(null);\n  let lastCollectionNode = (0, $4ELxY$useRef)(null);\n  let updateActiveDescendant = (0, $4ELxY$useEffectEvent)(e => {\n    let {\n      target: target\n    } = e;\n    if (queuedActiveDescendant.current === target.id) return;\n    clearTimeout(timeout.current);\n    e.stopPropagation();\n    if (target !== collectionRef.current) {\n      if (delayNextActiveDescendant.current) {\n        queuedActiveDescendant.current = target.id;\n        timeout.current = setTimeout(() => {\n          state.setFocusedNodeId(target.id);\n          queuedActiveDescendant.current = null;\n        }, 500);\n      } else state.setFocusedNodeId(target.id);\n    } else state.setFocusedNodeId(null);\n    delayNextActiveDescendant.current = false;\n  });\n  let callbackRef = (0, $4ELxY$useCallback)(collectionNode => {\n    var _lastCollectionNode_current;\n    if (collectionNode != null) {\n      var\n      // When typing forward, we want to delay the setting of active descendant to not interrupt the native screen reader announcement\n      // of the letter you just typed. If we recieve another UPDATE_ACTIVEDESCENDANT call then we clear the queued update\n      // We track lastCollectionNode to do proper cleanup since callbackRefs just pass null when unmounting. This also handles\n      // React 19's extra call of the callback ref in strict mode\n      _lastCollectionNode_current1;\n      (_lastCollectionNode_current1 = lastCollectionNode.current) === null || _lastCollectionNode_current1 === void 0 ? void 0 : _lastCollectionNode_current1.removeEventListener((0, $4ELxY$UPDATE_ACTIVEDESCENDANT), updateActiveDescendant);\n      lastCollectionNode.current = collectionNode;\n      collectionNode.addEventListener((0, $4ELxY$UPDATE_ACTIVEDESCENDANT), updateActiveDescendant);\n    } else (_lastCollectionNode_current = lastCollectionNode.current) === null || _lastCollectionNode_current === void 0 ? void 0 : _lastCollectionNode_current.removeEventListener((0, $4ELxY$UPDATE_ACTIVEDESCENDANT), updateActiveDescendant);\n  }, [updateActiveDescendant]);\n  // Make sure to memo so that React doesn't keep registering a new event listeners on every rerender of the wrapped collection\n  let mergedCollectionRef = (0, $4ELxY$useObjectRef)((0, $4ELxY$useMemo)(() => (0, $4ELxY$mergeRefs)(collectionRef, callbackRef), [collectionRef, callbackRef]));\n  let focusFirstItem = (0, $4ELxY$useEffectEvent)(() => {\n    var _collectionRef_current;\n    delayNextActiveDescendant.current = true;\n    (_collectionRef_current = collectionRef.current) === null || _collectionRef_current === void 0 ? void 0 : _collectionRef_current.dispatchEvent(new CustomEvent((0, $4ELxY$FOCUS_EVENT), {\n      cancelable: true,\n      bubbles: true,\n      detail: {\n        focusStrategy: 'first'\n      }\n    }));\n  });\n  let clearVirtualFocus = (0, $4ELxY$useEffectEvent)(() => {\n    var _collectionRef_current;\n    state.setFocusedNodeId(null);\n    let clearFocusEvent = new CustomEvent((0, $4ELxY$CLEAR_FOCUS_EVENT), {\n      cancelable: true,\n      bubbles: true\n    });\n    clearTimeout(timeout.current);\n    delayNextActiveDescendant.current = false;\n    (_collectionRef_current = collectionRef.current) === null || _collectionRef_current === void 0 ? void 0 : _collectionRef_current.dispatchEvent(clearFocusEvent);\n  });\n  // TODO: update to see if we can tell what kind of event (paste vs backspace vs typing) is happening instead\n  let onChange = value => {\n    // Tell wrapped collection to focus the first element in the list when typing forward and to clear focused key when deleting text\n    // for screen reader announcements\n    if (state.inputValue !== value && state.inputValue.length <= value.length) focusFirstItem();else clearVirtualFocus();\n    state.setInputValue(value);\n  };\n  let keyDownTarget = (0, $4ELxY$useRef)(null);\n  // For textfield specific keydown operations\n  let onKeyDown = e => {\n    var _collectionRef_current;\n    keyDownTarget.current = e.target;\n    if (e.nativeEvent.isComposing) return;\n    switch (e.key) {\n      case 'a':\n        if ((0, $4ELxY$isCtrlKeyPressed)(e)) return;\n        break;\n      case 'Escape':\n        // Early return for Escape here so it doesn't leak the Escape event from the simulated collection event below and\n        // close the dialog prematurely. Ideally that should be up to the discretion of the input element hence the check\n        // for isPropagationStopped\n        if (e.isDefaultPrevented()) return;\n        break;\n      case ' ':\n        // Space shouldn't trigger onAction so early return.\n        return;\n      case 'Home':\n      case 'End':\n      case 'PageDown':\n      case 'PageUp':\n      case 'ArrowUp':\n      case 'ArrowDown':\n        {\n          var _collectionRef_current1;\n          if ((e.key === 'Home' || e.key === 'End') && state.focusedNodeId == null && e.shiftKey) return;\n          // Prevent these keys from moving the text cursor in the input\n          e.preventDefault();\n          // Move virtual focus into the wrapped collection\n          let focusCollection = new CustomEvent((0, $4ELxY$FOCUS_EVENT), {\n            cancelable: true,\n            bubbles: true\n          });\n          (_collectionRef_current1 = collectionRef.current) === null || _collectionRef_current1 === void 0 ? void 0 : _collectionRef_current1.dispatchEvent(focusCollection);\n          break;\n        }\n      case 'ArrowLeft':\n      case 'ArrowRight':\n        // TODO: will need to special case this so it doesn't clear the focused key if we are currently\n        // focused on a submenutrigger? May not need to since focus would\n        // But what about wrapped grids where ArrowLeft and ArrowRight should navigate left/right\n        clearVirtualFocus();\n        break;\n    }\n    // Emulate the keyboard events that happen in the input field in the wrapped collection. This is for triggering things like onAction via Enter\n    // or moving focus from one item to another. Stop propagation on the input event if it isn't already stopped so it doesn't leak out. For events\n    // like ESC, the dispatched event below will bubble out of the collection and be stopped if handled by useSelectableCollection, otherwise will bubble\n    // as expected\n    if (!e.isPropagationStopped()) e.stopPropagation();\n    if (state.focusedNodeId == null) (_collectionRef_current = collectionRef.current) === null || _collectionRef_current === void 0 ? void 0 : _collectionRef_current.dispatchEvent(new KeyboardEvent(e.nativeEvent.type, e.nativeEvent));else {\n      let item = document.getElementById(state.focusedNodeId);\n      item === null || item === void 0 ? void 0 : item.dispatchEvent(new KeyboardEvent(e.nativeEvent.type, e.nativeEvent));\n    }\n  };\n  let onKeyUpCapture = (0, $4ELxY$useEffectEvent)(e => {\n    // Dispatch simulated key up events for things like triggering links in listbox\n    // Make sure to stop the propagation of the input keyup event so that the simulated keyup/down pair\n    // is detected by usePress instead of the original keyup originating from the input\n    if (e.target === keyDownTarget.current) {\n      var _collectionRef_current;\n      e.stopImmediatePropagation();\n      if (state.focusedNodeId == null) (_collectionRef_current = collectionRef.current) === null || _collectionRef_current === void 0 ? void 0 : _collectionRef_current.dispatchEvent(new KeyboardEvent(e.type, e));else {\n        let item = document.getElementById(state.focusedNodeId);\n        item === null || item === void 0 ? void 0 : item.dispatchEvent(new KeyboardEvent(e.type, e));\n      }\n    }\n  });\n  (0, $4ELxY$useEffect)(() => {\n    document.addEventListener('keyup', onKeyUpCapture, true);\n    return () => {\n      document.removeEventListener('keyup', onKeyUpCapture, true);\n    };\n  }, [onKeyUpCapture]);\n  let stringFormatter = (0, $4ELxY$useLocalizedStringFormatter)((0, $parcel$interopDefault($4ELxY$intlStringsmodulejs)), '@react-aria/autocomplete');\n  let collectionProps = (0, $4ELxY$useLabels)({\n    id: collectionId,\n    'aria-label': stringFormatter.format('collectionLabel')\n  });\n  let filterFn = (0, $4ELxY$useCallback)(nodeTextValue => {\n    if (filter) return filter(nodeTextValue, state.inputValue);\n    return true;\n  }, [state.inputValue, filter]);\n  var _state_focusedNodeId;\n  return {\n    textFieldProps: {\n      value: state.inputValue,\n      onChange: onChange,\n      onKeyDown: onKeyDown,\n      autoComplete: 'off',\n      'aria-haspopup': 'listbox',\n      'aria-controls': collectionId,\n      // TODO: readd proper logic for completionMode = complete (aria-autocomplete: both)\n      'aria-autocomplete': 'list',\n      'aria-activedescendant': (_state_focusedNodeId = state.focusedNodeId) !== null && _state_focusedNodeId !== void 0 ? _state_focusedNodeId : undefined,\n      // This disable's iOS's autocorrect suggestions, since the autocomplete provides its own suggestions.\n      autoCorrect: 'off',\n      // This disable's the macOS Safari spell check auto corrections.\n      spellCheck: 'false'\n    },\n    collectionProps: (0, $4ELxY$mergeProps)(collectionProps, {\n      // TODO: shouldFocusOnHover? shouldFocusWrap? Should it be up to the wrapped collection?\n      shouldUseVirtualFocus: true,\n      disallowTypeAhead: true\n    }),\n    collectionRef: mergedCollectionRef,\n    filterFn: filter != null ? filterFn : undefined\n  };\n}\nexport { $48f6ba390f8c5b59$export$2d6947d4992da88e as UNSTABLE_useAutocomplete };","map":{"version":3,"names":["$48f6ba390f8c5b59$export$2d6947d4992da88e","props","state","collectionRef","filter","collectionId","$4ELxY$useId","timeout","$4ELxY$useRef","undefined","delayNextActiveDescendant","queuedActiveDescendant","lastCollectionNode","updateActiveDescendant","$4ELxY$useEffectEvent","e","target","current","id","clearTimeout","stopPropagation","setTimeout","setFocusedNodeId","callbackRef","$4ELxY$useCallback","collectionNode","_lastCollectionNode_current","_lastCollectionNode_current1","removeEventListener","$4ELxY$UPDATE_ACTIVEDESCENDANT","addEventListener","mergedCollectionRef","$4ELxY$useObjectRef","$4ELxY$useMemo","$4ELxY$mergeRefs","focusFirstItem","_collectionRef_current","dispatchEvent","CustomEvent","$4ELxY$FOCUS_EVENT","cancelable","bubbles","detail","focusStrategy","clearVirtualFocus","clearFocusEvent","$4ELxY$CLEAR_FOCUS_EVENT","onChange","value","inputValue","length","setInputValue","keyDownTarget","onKeyDown","nativeEvent","isComposing","key","$4ELxY$isCtrlKeyPressed","isDefaultPrevented","_collectionRef_current1","focusedNodeId","shiftKey","preventDefault","focusCollection","isPropagationStopped","KeyboardEvent","type","item","document","getElementById","onKeyUpCapture","stopImmediatePropagation","$4ELxY$useEffect","stringFormatter","$4ELxY$useLocalizedStringFormatter","$parcel$interopDefault","$4ELxY$intlStringsmodulejs","collectionProps","$4ELxY$useLabels","format","filterFn","nodeTextValue","_state_focusedNodeId","textFieldProps","autoComplete","autoCorrect","spellCheck","$4ELxY$mergeProps","shouldUseVirtualFocus","disallowTypeAhead"],"sources":["C:\\Users\\rewac\\OneDrive\\Documents\\GitHub\\scatch-store.me\\node_modules\\@react-aria\\autocomplete\\dist\\packages\\@react-aria\\autocomplete\\src\\useAutocomplete.ts"],"sourcesContent":["/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaLabelingProps, BaseEvent, DOMProps, RefObject} from '@react-types/shared';\nimport {AriaTextFieldProps} from '@react-aria/textfield';\nimport {AutocompleteProps, AutocompleteState} from '@react-stately/autocomplete';\nimport {CLEAR_FOCUS_EVENT, FOCUS_EVENT, isCtrlKeyPressed, mergeProps, mergeRefs, UPDATE_ACTIVEDESCENDANT, useEffectEvent, useId, useLabels, useObjectRef} from '@react-aria/utils';\n// @ts-ignore\nimport intlMessages from '../intl/*.json';\nimport {KeyboardEvent as ReactKeyboardEvent, useCallback, useEffect, useMemo, useRef} from 'react';\nimport {useLocalizedStringFormatter} from '@react-aria/i18n';\n\nexport interface CollectionOptions extends DOMProps, AriaLabelingProps {\n  /** Whether the collection items should use virtual focus instead of being focused directly. */\n  shouldUseVirtualFocus: boolean,\n  /** Whether typeahead is disabled. */\n  disallowTypeAhead: boolean\n}\nexport interface AriaAutocompleteProps extends AutocompleteProps {\n  /**\n   * An optional filter function used to determine if a option should be included in the autocomplete list.\n   * Include this if the items you are providing to your wrapped collection aren't filtered by default.\n   */\n  filter?: (textValue: string, inputValue: string) => boolean\n}\n\nexport interface AriaAutocompleteOptions extends Omit<AriaAutocompleteProps, 'children'> {\n  /** The ref for the wrapped collection element. */\n  collectionRef: RefObject<HTMLElement | null>\n}\n\nexport interface AutocompleteAria {\n  /** Props for the autocomplete textfield/searchfield element. These should be passed to the textfield/searchfield aria hooks respectively. */\n  textFieldProps: AriaTextFieldProps,\n  /** Props for the collection, to be passed to collection's respective aria hook (e.g. useMenu). */\n  collectionProps: CollectionOptions,\n  /** Ref to attach to the wrapped collection. */\n  collectionRef: RefObject<HTMLElement | null>,\n  /** A filter function that returns if the provided collection node should be filtered out of the collection. */\n  filterFn?: (nodeTextValue: string) => boolean\n}\n\n/**\n * Provides the behavior and accessibility implementation for a autocomplete component.\n * A autocomplete combines a text input with a collection, allowing users to filter the collection's contents match a query.\n * @param props - Props for the autocomplete.\n * @param state - State for the autocomplete, as returned by `useAutocompleteState`.\n */\nexport function UNSTABLE_useAutocomplete(props: AriaAutocompleteOptions, state: AutocompleteState): AutocompleteAria {\n  let {\n    collectionRef,\n    filter\n  } = props;\n\n  let collectionId = useId();\n  let timeout = useRef<ReturnType<typeof setTimeout> | undefined>(undefined);\n  let delayNextActiveDescendant = useRef(false);\n  let queuedActiveDescendant = useRef(null);\n  let lastCollectionNode = useRef<HTMLElement>(null);\n\n  let updateActiveDescendant = useEffectEvent((e) => {\n    let {target} = e;\n    if (queuedActiveDescendant.current === target.id) {\n      return;\n    }\n\n    clearTimeout(timeout.current);\n    e.stopPropagation();\n\n    if (target !== collectionRef.current) {\n      if (delayNextActiveDescendant.current) {\n        queuedActiveDescendant.current = target.id;\n        timeout.current = setTimeout(() => {\n          state.setFocusedNodeId(target.id);\n          queuedActiveDescendant.current = null;\n        }, 500);\n      } else {\n        state.setFocusedNodeId(target.id);\n      }\n    } else {\n      state.setFocusedNodeId(null);\n    }\n\n    delayNextActiveDescendant.current = false;\n  });\n\n  let callbackRef = useCallback((collectionNode) => {\n    if (collectionNode != null) {\n      // When typing forward, we want to delay the setting of active descendant to not interrupt the native screen reader announcement\n      // of the letter you just typed. If we recieve another UPDATE_ACTIVEDESCENDANT call then we clear the queued update\n      // We track lastCollectionNode to do proper cleanup since callbackRefs just pass null when unmounting. This also handles\n      // React 19's extra call of the callback ref in strict mode\n      lastCollectionNode.current?.removeEventListener(UPDATE_ACTIVEDESCENDANT, updateActiveDescendant);\n      lastCollectionNode.current = collectionNode;\n      collectionNode.addEventListener(UPDATE_ACTIVEDESCENDANT, updateActiveDescendant);\n    } else {\n      lastCollectionNode.current?.removeEventListener(UPDATE_ACTIVEDESCENDANT, updateActiveDescendant);\n    }\n  }, [updateActiveDescendant]);\n\n  // Make sure to memo so that React doesn't keep registering a new event listeners on every rerender of the wrapped collection\n  let mergedCollectionRef = useObjectRef(useMemo(() => mergeRefs(collectionRef, callbackRef), [collectionRef, callbackRef]));\n\n  let focusFirstItem = useEffectEvent(() => {\n    delayNextActiveDescendant.current = true;\n    collectionRef.current?.dispatchEvent(\n      new CustomEvent(FOCUS_EVENT, {\n        cancelable: true,\n        bubbles: true,\n        detail: {\n          focusStrategy: 'first'\n        }\n      })\n    );\n  });\n\n  let clearVirtualFocus = useEffectEvent(() => {\n    state.setFocusedNodeId(null);\n    let clearFocusEvent = new CustomEvent(CLEAR_FOCUS_EVENT, {\n      cancelable: true,\n      bubbles: true\n    });\n    clearTimeout(timeout.current);\n    delayNextActiveDescendant.current = false;\n    collectionRef.current?.dispatchEvent(clearFocusEvent);\n  });\n\n  // TODO: update to see if we can tell what kind of event (paste vs backspace vs typing) is happening instead\n  let onChange = (value: string) => {\n    // Tell wrapped collection to focus the first element in the list when typing forward and to clear focused key when deleting text\n    // for screen reader announcements\n    if (state.inputValue !== value && state.inputValue.length <= value.length) {\n      focusFirstItem();\n    } else {\n      clearVirtualFocus();\n    }\n\n    state.setInputValue(value);\n  };\n\n  let keyDownTarget = useRef<Element | null>(null);\n  // For textfield specific keydown operations\n  let onKeyDown = (e: BaseEvent<ReactKeyboardEvent<any>>) => {\n    keyDownTarget.current = e.target as Element;\n    if (e.nativeEvent.isComposing) {\n      return;\n    }\n\n    switch (e.key) {\n      case 'a':\n        if (isCtrlKeyPressed(e)) {\n          return;\n        }\n        break;\n      case 'Escape':\n        // Early return for Escape here so it doesn't leak the Escape event from the simulated collection event below and\n        // close the dialog prematurely. Ideally that should be up to the discretion of the input element hence the check\n        // for isPropagationStopped\n        if (e.isDefaultPrevented()) {\n          return;\n        }\n        break;\n      case ' ':\n        // Space shouldn't trigger onAction so early return.\n\n        return;\n      case 'Home':\n      case 'End':\n      case 'PageDown':\n      case 'PageUp':\n      case 'ArrowUp':\n      case 'ArrowDown': {\n        if ((e.key === 'Home' || e.key === 'End') && state.focusedNodeId == null && e.shiftKey) {\n          return;\n        }\n\n        // Prevent these keys from moving the text cursor in the input\n        e.preventDefault();\n        // Move virtual focus into the wrapped collection\n        let focusCollection = new CustomEvent(FOCUS_EVENT, {\n          cancelable: true,\n          bubbles: true\n        });\n\n        collectionRef.current?.dispatchEvent(focusCollection);\n        break;\n      }\n      case 'ArrowLeft':\n      case 'ArrowRight':\n        // TODO: will need to special case this so it doesn't clear the focused key if we are currently\n        // focused on a submenutrigger? May not need to since focus would\n        // But what about wrapped grids where ArrowLeft and ArrowRight should navigate left/right\n        clearVirtualFocus();\n        break;\n    }\n\n    // Emulate the keyboard events that happen in the input field in the wrapped collection. This is for triggering things like onAction via Enter\n    // or moving focus from one item to another. Stop propagation on the input event if it isn't already stopped so it doesn't leak out. For events\n    // like ESC, the dispatched event below will bubble out of the collection and be stopped if handled by useSelectableCollection, otherwise will bubble\n    // as expected\n    if (!e.isPropagationStopped()) {\n      e.stopPropagation();\n    }\n\n    if (state.focusedNodeId == null) {\n      collectionRef.current?.dispatchEvent(\n        new KeyboardEvent(e.nativeEvent.type, e.nativeEvent)\n      );\n    } else {\n      let item = document.getElementById(state.focusedNodeId);\n      item?.dispatchEvent(\n        new KeyboardEvent(e.nativeEvent.type, e.nativeEvent)\n      );\n    }\n  };\n\n  let onKeyUpCapture = useEffectEvent((e) => {\n    // Dispatch simulated key up events for things like triggering links in listbox\n    // Make sure to stop the propagation of the input keyup event so that the simulated keyup/down pair\n    // is detected by usePress instead of the original keyup originating from the input\n    if (e.target === keyDownTarget.current) {\n      e.stopImmediatePropagation();\n      if (state.focusedNodeId == null) {\n        collectionRef.current?.dispatchEvent(\n          new KeyboardEvent(e.type, e)\n        );\n      } else {\n        let item = document.getElementById(state.focusedNodeId);\n        item?.dispatchEvent(\n          new KeyboardEvent(e.type, e)\n        );\n      }\n    }\n  });\n\n  useEffect(() => {\n    document.addEventListener('keyup', onKeyUpCapture, true);\n    return () => {\n      document.removeEventListener('keyup', onKeyUpCapture, true);\n    };\n  }, [onKeyUpCapture]);\n\n  let stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/autocomplete');\n  let collectionProps = useLabels({\n    id: collectionId,\n    'aria-label': stringFormatter.format('collectionLabel')\n  });\n\n  let filterFn = useCallback((nodeTextValue: string) => {\n    if (filter) {\n      return filter(nodeTextValue, state.inputValue);\n    }\n\n    return true;\n  }, [state.inputValue, filter]);\n\n  return {\n    textFieldProps: {\n      value: state.inputValue,\n      onChange,\n      onKeyDown,\n      autoComplete: 'off',\n      'aria-haspopup': 'listbox',\n      'aria-controls': collectionId,\n      // TODO: readd proper logic for completionMode = complete (aria-autocomplete: both)\n      'aria-autocomplete': 'list',\n      'aria-activedescendant': state.focusedNodeId ?? undefined,\n      // This disable's iOS's autocorrect suggestions, since the autocomplete provides its own suggestions.\n      autoCorrect: 'off',\n      // This disable's the macOS Safari spell check auto corrections.\n      spellCheck: 'false'\n    },\n    collectionProps: mergeProps(collectionProps, {\n      // TODO: shouldFocusOnHover? shouldFocusWrap? Should it be up to the wrapped collection?\n      shouldUseVirtualFocus: true,\n      disallowTypeAhead: true\n    }),\n    collectionRef: mergedCollectionRef,\n    filterFn: filter != null ? filterFn : undefined\n  };\n}\n"],"mappings":";;;;;;;AAAA;;;;;;;;;;;;AAyDO,SAASA,0CAAyBC,KAA8B,EAAEC,KAAwB;EAC/F,IAAI;IAAAC,aAAA,EACFA,aAAa;IAAAC,MAAA,EACbA;EAAM,CACP,GAAGH,KAAA;EAEJ,IAAII,YAAA,GAAe,IAAAC,YAAI;EACvB,IAAIC,OAAA,GAAU,IAAAC,aAAK,EAA6CC,SAAA;EAChE,IAAIC,yBAAA,GAA4B,IAAAF,aAAK,EAAE;EACvC,IAAIG,sBAAA,GAAyB,IAAAH,aAAK,EAAE;EACpC,IAAII,kBAAA,GAAqB,IAAAJ,aAAK,EAAe;EAE7C,IAAIK,sBAAA,GAAyB,IAAAC,qBAAa,EAAGC,CAAA;IAC3C,IAAI;MAAAC,MAAA,EAACA;IAAM,CAAC,GAAGD,CAAA;IACf,IAAIJ,sBAAA,CAAuBM,OAAO,KAAKD,MAAA,CAAOE,EAAE,EAC9C;IAGFC,YAAA,CAAaZ,OAAA,CAAQU,OAAO;IAC5BF,CAAA,CAAEK,eAAe;IAEjB,IAAIJ,MAAA,KAAWb,aAAA,CAAcc,OAAO;MAClC,IAAIP,yBAAA,CAA0BO,OAAO,EAAE;QACrCN,sBAAA,CAAuBM,OAAO,GAAGD,MAAA,CAAOE,EAAE;QAC1CX,OAAA,CAAQU,OAAO,GAAGI,UAAA,CAAW;UAC3BnB,KAAA,CAAMoB,gBAAgB,CAACN,MAAA,CAAOE,EAAE;UAChCP,sBAAA,CAAuBM,OAAO,GAAG;QACnC,GAAG;MACL,OACEf,KAAA,CAAMoB,gBAAgB,CAACN,MAAA,CAAOE,EAAE;WAGlChB,KAAA,CAAMoB,gBAAgB,CAAC;IAGzBZ,yBAAA,CAA0BO,OAAO,GAAG;EACtC;EAEA,IAAIM,WAAA,GAAc,IAAAC,kBAAU,EAAGC,cAAA;QAU3BC,2BAAA;IATF,IAAID,cAAA,IAAkB,MAAM;;MAC1B;MACA;MACA;MACA;MACAE,4BAAA;OAAAA,4BAAA,GAAAf,kBAAA,CAAmBK,OAAO,cAA1BU,4BAAA,uBAAAA,4BAAA,CAA4BC,mBAAmB,EAAC,GAAAC,8BAAsB,GAAGhB,sBAAA;MACzED,kBAAA,CAAmBK,OAAO,GAAGQ,cAAA;MAC7BA,cAAA,CAAeK,gBAAgB,EAAC,GAAAD,8BAAsB,GAAGhB,sBAAA;IAC3D,QACEa,2BAAA,GAAAd,kBAAA,CAAmBK,OAAO,cAA1BS,2BAAA,uBAAAA,2BAAA,CAA4BE,mBAAmB,EAAC,GAAAC,8BAAsB,GAAGhB,sBAAA;EAE7E,GAAG,CAACA,sBAAA,CAAuB;EAE3B;EACA,IAAIkB,mBAAA,GAAsB,IAAAC,mBAAW,EAAE,IAAAC,cAAM,EAAE,MAAM,IAAAC,gBAAQ,EAAE/B,aAAA,EAAeoB,WAAA,GAAc,CAACpB,aAAA,EAAeoB,WAAA,CAAY;EAExH,IAAIY,cAAA,GAAiB,IAAArB,qBAAa,EAAE;QAElCsB,sBAAA;IADA1B,yBAAA,CAA0BO,OAAO,GAAG;KACpCmB,sBAAA,GAAAjC,aAAA,CAAcc,OAAO,cAArBmB,sBAAA,uBAAAA,sBAAA,CAAuBC,aAAa,CAClC,IAAIC,WAAA,EAAY,GAAAC,kBAAU,GAAG;MAC3BC,UAAA,EAAY;MACZC,OAAA,EAAS;MACTC,MAAA,EAAQ;QACNC,aAAA,EAAe;MACjB;IACF;EAEJ;EAEA,IAAIC,iBAAA,GAAoB,IAAA9B,qBAAa,EAAE;QAQrCsB,sBAAA;IAPAlC,KAAA,CAAMoB,gBAAgB,CAAC;IACvB,IAAIuB,eAAA,GAAkB,IAAIP,WAAA,EAAY,GAAAQ,wBAAgB,GAAG;MACvDN,UAAA,EAAY;MACZC,OAAA,EAAS;IACX;IACAtB,YAAA,CAAaZ,OAAA,CAAQU,OAAO;IAC5BP,yBAAA,CAA0BO,OAAO,GAAG;KACpCmB,sBAAA,GAAAjC,aAAA,CAAcc,OAAO,cAArBmB,sBAAA,uBAAAA,sBAAA,CAAuBC,aAAa,CAACQ,eAAA;EACvC;EAEA;EACA,IAAIE,QAAA,GAAYC,KAAA;IACd;IACA;IACA,IAAI9C,KAAA,CAAM+C,UAAU,KAAKD,KAAA,IAAS9C,KAAA,CAAM+C,UAAU,CAACC,MAAM,IAAIF,KAAA,CAAME,MAAM,EACvEf,cAAA,QAEAS,iBAAA;IAGF1C,KAAA,CAAMiD,aAAa,CAACH,KAAA;EACtB;EAEA,IAAII,aAAA,GAAgB,IAAA5C,aAAK,EAAkB;EAC3C;EACA,IAAI6C,SAAA,GAAatC,CAAA;QA+DbqB,sBAAA;IA9DFgB,aAAA,CAAcnC,OAAO,GAAGF,CAAA,CAAEC,MAAM;IAChC,IAAID,CAAA,CAAEuC,WAAW,CAACC,WAAW,EAC3B;IAGF,QAAQxC,CAAA,CAAEyC,GAAG;MACX,KAAK;QACH,IAAI,IAAAC,uBAAe,EAAE1C,CAAA,GACnB;QAEF;MACF,KAAK;QACH;QACA;QACA;QACA,IAAIA,CAAA,CAAE2C,kBAAkB,IACtB;QAEF;MACF,KAAK;QACH;QAEA;MACF,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;QAAa;cAahBC,uBAAA;UAZA,IAAI,CAAC5C,CAAA,CAAEyC,GAAG,KAAK,UAAUzC,CAAA,CAAEyC,GAAG,KAAK,KAAI,KAAMtD,KAAA,CAAM0D,aAAa,IAAI,QAAQ7C,CAAA,CAAE8C,QAAQ,EACpF;UAGF;UACA9C,CAAA,CAAE+C,cAAc;UAChB;UACA,IAAIC,eAAA,GAAkB,IAAIzB,WAAA,EAAY,GAAAC,kBAAU,GAAG;YACjDC,UAAA,EAAY;YACZC,OAAA,EAAS;UACX;WAEAkB,uBAAA,GAAAxD,aAAA,CAAcc,OAAO,cAArB0C,uBAAA,uBAAAA,uBAAA,CAAuBtB,aAAa,CAAC0B,eAAA;UACrC;QACF;MACA,KAAK;MACL,KAAK;QACH;QACA;QACA;QACAnB,iBAAA;QACA;IACJ;IAEA;IACA;IACA;IACA;IACA,IAAI,CAAC7B,CAAA,CAAEiD,oBAAoB,IACzBjD,CAAA,CAAEK,eAAe;IAGnB,IAAIlB,KAAA,CAAM0D,aAAa,IAAI,OACzBxB,sBAAA,GAAAjC,aAAA,CAAcc,OAAO,cAArBmB,sBAAA,uBAAAA,sBAAA,CAAuBC,aAAa,CAClC,IAAI4B,aAAA,CAAclD,CAAA,CAAEuC,WAAW,CAACY,IAAI,EAAEnD,CAAA,CAAEuC,WAAW,QAEhD;MACL,IAAIa,IAAA,GAAOC,QAAA,CAASC,cAAc,CAACnE,KAAA,CAAM0D,aAAa;MACtDO,IAAA,aAAAA,IAAA,uBAAAA,IAAA,CAAM9B,aAAa,CACjB,IAAI4B,aAAA,CAAclD,CAAA,CAAEuC,WAAW,CAACY,IAAI,EAAEnD,CAAA,CAAEuC,WAAW;IAEvD;EACF;EAEA,IAAIgB,cAAA,GAAiB,IAAAxD,qBAAa,EAAGC,CAAA;IACnC;IACA;IACA;IACA,IAAIA,CAAA,CAAEC,MAAM,KAAKoC,aAAA,CAAcnC,OAAO,EAAE;UAGpCmB,sBAAA;MAFFrB,CAAA,CAAEwD,wBAAwB;MAC1B,IAAIrE,KAAA,CAAM0D,aAAa,IAAI,OACzBxB,sBAAA,GAAAjC,aAAA,CAAcc,OAAO,cAArBmB,sBAAA,uBAAAA,sBAAA,CAAuBC,aAAa,CAClC,IAAI4B,aAAA,CAAclD,CAAA,CAAEmD,IAAI,EAAEnD,CAAA,QAEvB;QACL,IAAIoD,IAAA,GAAOC,QAAA,CAASC,cAAc,CAACnE,KAAA,CAAM0D,aAAa;QACtDO,IAAA,aAAAA,IAAA,uBAAAA,IAAA,CAAM9B,aAAa,CACjB,IAAI4B,aAAA,CAAclD,CAAA,CAAEmD,IAAI,EAAEnD,CAAA;MAE9B;IACF;EACF;EAEA,IAAAyD,gBAAQ,EAAE;IACRJ,QAAA,CAAStC,gBAAgB,CAAC,SAASwC,cAAA,EAAgB;IACnD,OAAO;MACLF,QAAA,CAASxC,mBAAmB,CAAC,SAAS0C,cAAA,EAAgB;IACxD;EACF,GAAG,CAACA,cAAA,CAAe;EAEnB,IAAIG,eAAA,GAAkB,IAAAC,kCAA0B,GAAE,GAAAC,sBAAA,CAAAC,0BAAA,CAAW,GAAG;EAChE,IAAIC,eAAA,GAAkB,IAAAC,gBAAQ,EAAE;IAC9B5D,EAAA,EAAIb,YAAA;IACJ,cAAcoE,eAAA,CAAgBM,MAAM,CAAC;EACvC;EAEA,IAAIC,QAAA,GAAW,IAAAxD,kBAAU,EAAGyD,aAAA;IAC1B,IAAI7E,MAAA,EACF,OAAOA,MAAA,CAAO6E,aAAA,EAAe/E,KAAA,CAAM+C,UAAU;IAG/C,OAAO;EACT,GAAG,CAAC/C,KAAA,CAAM+C,UAAU,EAAE7C,MAAA,CAAO;MAYA8E,oBAAA;EAV7B,OAAO;IACLC,cAAA,EAAgB;MACdnC,KAAA,EAAO9C,KAAA,CAAM+C,UAAU;gBACvBF,QAAA;iBACAM,SAAA;MACA+B,YAAA,EAAc;MACd,iBAAiB;MACjB,iBAAiB/E,YAAA;MACjB;MACA,qBAAqB;MACrB,yBAAyB,CAAA6E,oBAAA,GAAAhF,KAAA,CAAM0D,aAAa,cAAnBsB,oBAAA,cAAAA,oBAAA,GAAuBzE,SAAA;MAChD;MACA4E,WAAA,EAAa;MACb;MACAC,UAAA,EAAY;IACd;IACAT,eAAA,EAAiB,IAAAU,iBAAS,EAAEV,eAAA,EAAiB;MAC3C;MACAW,qBAAA,EAAuB;MACvBC,iBAAA,EAAmB;IACrB;IACAtF,aAAA,EAAe4B,mBAAA;IACfiD,QAAA,EAAU5E,MAAA,IAAU,OAAO4E,QAAA,GAAWvE;EACxC;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
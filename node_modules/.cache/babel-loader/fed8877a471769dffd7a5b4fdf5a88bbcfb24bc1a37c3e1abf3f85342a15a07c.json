{"ast":null,"code":"import _objectSpread from \"C:/Users/rewac/OneDrive/Documents/GitHub/scatch-store.me/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { useState as $3pPTd$useState } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nfunction $be2ea0343af54212$export$d14e1352e21f4a16(options) {\n  let {\n    initialItems = [],\n    initialSelectedKeys: initialSelectedKeys,\n    getKey = item => {\n      var _item_id;\n      return (_item_id = item.id) !== null && _item_id !== void 0 ? _item_id : item.key;\n    },\n    getChildren = item => item.children\n  } = options;\n  // We only want to compute this on initial render.\n  let [tree, setItems] = (0, $3pPTd$useState)(() => buildTree(initialItems, new Map()));\n  let {\n    items: items,\n    nodeMap: nodeMap\n  } = tree;\n  let [selectedKeys, setSelectedKeys] = (0, $3pPTd$useState)(new Set(initialSelectedKeys || []));\n  function buildTree() {\n    let initialItems = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let map = arguments.length > 1 ? arguments[1] : undefined;\n    let parentKey = arguments.length > 2 ? arguments[2] : undefined;\n    if (initialItems == null) initialItems = [];\n    return {\n      items: initialItems.map(item => {\n        let node = {\n          key: getKey(item),\n          parentKey: parentKey,\n          value: item,\n          children: null\n        };\n        node.children = buildTree(getChildren(item), map, node.key).items;\n        map.set(node.key, node);\n        return node;\n      }),\n      nodeMap: map\n    };\n  }\n  function updateTree(items, key, update, originalMap) {\n    let node = originalMap.get(key);\n    if (!node) return {\n      items: items,\n      nodeMap: originalMap\n    };\n    let map = new Map(originalMap);\n    // Create a new node. If null, then delete the node, otherwise replace.\n    let newNode = update(node);\n    if (newNode == null) deleteNode(node, map);else addNode(newNode, map);\n    // Walk up the tree and update each parent to refer to the new children.\n    while (node && node.parentKey) {\n      let nextParent = map.get(node.parentKey);\n      let copy = {\n        key: nextParent.key,\n        parentKey: nextParent.parentKey,\n        value: nextParent.value,\n        children: null\n      };\n      let children = nextParent.children;\n      if (newNode == null && children) children = children.filter(c => c !== node);\n      var _children_map;\n      copy.children = (_children_map = children === null || children === void 0 ? void 0 : children.map(child => {\n        if (child === node)\n          // newNode cannot be null here due to the above filter.\n          return newNode;\n        return child;\n      })) !== null && _children_map !== void 0 ? _children_map : null;\n      map.set(copy.key, copy);\n      newNode = copy;\n      node = nextParent;\n    }\n    if (newNode == null) items = items.filter(c => c !== node);\n    return {\n      items: items.map(item => {\n        if (item === node)\n          // newNode cannot be null here due to the above filter.\n          return newNode;\n        return item;\n      }),\n      nodeMap: map\n    };\n  }\n  function addNode(node, map) {\n    map.set(node.key, node);\n    if (node.children) for (let child of node.children) addNode(child, map);\n  }\n  function deleteNode(node, map) {\n    map.delete(node.key);\n    if (node.children) for (let child of node.children) deleteNode(child, map);\n  }\n  return {\n    items: items,\n    selectedKeys: selectedKeys,\n    setSelectedKeys: setSelectedKeys,\n    getItem(key) {\n      return nodeMap.get(key);\n    },\n    insert(parentKey, index) {\n      for (var _len = arguments.length, values = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        values[_key - 2] = arguments[_key];\n      }\n      setItems(_ref => {\n        let {\n          items: items,\n          nodeMap: originalMap\n        } = _ref;\n        let {\n          items: newNodes,\n          nodeMap: newMap\n        } = buildTree(values, originalMap, parentKey);\n        // If parentKey is null, insert into the root.\n        if (parentKey == null) return {\n          items: [...items.slice(0, index), ...newNodes, ...items.slice(index)],\n          nodeMap: newMap\n        };\n        // Otherwise, update the parent node and its ancestors.\n        return updateTree(items, parentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [...parentNode.children.slice(0, index), ...newNodes, ...parentNode.children.slice(index)]\n        }), newMap);\n      });\n    },\n    insertBefore(key) {\n      let node = nodeMap.get(key);\n      if (!node) return;\n      let parentNode = nodeMap.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes.indexOf(node);\n      var _parentNode_key;\n      for (var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        values[_key2 - 1] = arguments[_key2];\n      }\n      this.insert((_parentNode_key = parentNode === null || parentNode === void 0 ? void 0 : parentNode.key) !== null && _parentNode_key !== void 0 ? _parentNode_key : null, index, ...values);\n    },\n    insertAfter(key) {\n      let node = nodeMap.get(key);\n      if (!node) return;\n      let parentNode = nodeMap.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes.indexOf(node);\n      var _parentNode_key;\n      for (var _len3 = arguments.length, values = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        values[_key3 - 1] = arguments[_key3];\n      }\n      this.insert((_parentNode_key = parentNode === null || parentNode === void 0 ? void 0 : parentNode.key) !== null && _parentNode_key !== void 0 ? _parentNode_key : null, index + 1, ...values);\n    },\n    prepend(parentKey) {\n      for (var _len4 = arguments.length, values = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        values[_key4 - 1] = arguments[_key4];\n      }\n      this.insert(parentKey, 0, ...values);\n    },\n    append(parentKey) {\n      for (var _len5 = arguments.length, values = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        values[_key5 - 1] = arguments[_key5];\n      }\n      if (parentKey == null) this.insert(null, items.length, ...values);else {\n        let parentNode = nodeMap.get(parentKey);\n        if (!parentNode) return;\n        this.insert(parentKey, parentNode.children.length, ...values);\n      }\n    },\n    remove() {\n      for (var _len6 = arguments.length, keys = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        keys[_key6] = arguments[_key6];\n      }\n      if (keys.length === 0) return;\n      let newItems = items;\n      let prevMap = nodeMap;\n      let newTree;\n      for (let key of keys) {\n        newTree = updateTree(newItems, key, () => null, prevMap);\n        prevMap = newTree.nodeMap;\n        newItems = newTree.items;\n      }\n      setItems(newTree);\n      let selection = new Set(selectedKeys);\n      for (let key of selectedKeys) if (!newTree.nodeMap.has(key)) selection.delete(key);\n      setSelectedKeys(selection);\n    },\n    removeSelectedItems() {\n      this.remove(...selectedKeys);\n    },\n    move(key, toParentKey, index) {\n      setItems(_ref2 => {\n        let {\n          items: items,\n          nodeMap: originalMap\n        } = _ref2;\n        let node = originalMap.get(key);\n        if (!node) return {\n          items: items,\n          nodeMap: originalMap\n        };\n        let {\n          items: newItems,\n          nodeMap: newMap\n        } = updateTree(items, key, () => null, originalMap);\n        const movedNode = _objectSpread(_objectSpread({}, node), {}, {\n          parentKey: toParentKey\n        });\n        // If parentKey is null, insert into the root.\n        if (toParentKey == null) {\n          newMap.set(movedNode.key, movedNode);\n          return {\n            items: [...newItems.slice(0, index), movedNode, ...newItems.slice(index)],\n            nodeMap: newMap\n          };\n        }\n        // Otherwise, update the parent node and its ancestors.\n        return updateTree(newItems, toParentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [...parentNode.children.slice(0, index), movedNode, ...parentNode.children.slice(index)]\n        }), newMap);\n      });\n    },\n    update(oldKey, newValue) {\n      setItems(_ref3 => {\n        let {\n          items: items,\n          nodeMap: originalMap\n        } = _ref3;\n        return updateTree(items, oldKey, oldNode => {\n          let node = {\n            key: oldNode.key,\n            parentKey: oldNode.parentKey,\n            value: newValue,\n            children: null\n          };\n          let tree = buildTree(getChildren(newValue), originalMap, node.key);\n          node.children = tree.items;\n          return node;\n        }, originalMap);\n      });\n    }\n  };\n}\nexport { $be2ea0343af54212$export$d14e1352e21f4a16 as useTreeData };","map":{"version":3,"names":["$be2ea0343af54212$export$d14e1352e21f4a16","options","initialItems","initialSelectedKeys","getKey","item","_item_id","id","key","getChildren","children","tree","setItems","$3pPTd$useState","buildTree","Map","items","nodeMap","selectedKeys","setSelectedKeys","Set","arguments","length","undefined","map","parentKey","node","value","set","updateTree","update","originalMap","get","newNode","deleteNode","addNode","nextParent","copy","filter","c","_children_map","child","delete","getItem","insert","index","_len","values","Array","_key","_ref","newNodes","newMap","slice","parentNode","insertBefore","nodes","indexOf","_parentNode_key","_len2","_key2","insertAfter","_len3","_key3","prepend","_len4","_key4","append","_len5","_key5","remove","_len6","keys","_key6","newItems","prevMap","newTree","selection","has","removeSelectedItems","move","toParentKey","_ref2","movedNode","_objectSpread","oldKey","newValue","_ref3","oldNode"],"sources":["C:\\Users\\rewac\\OneDrive\\Documents\\GitHub\\scatch-store.me\\node_modules\\@react-stately\\data\\dist\\packages\\@react-stately\\data\\src\\useTreeData.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from '@react-types/shared';\nimport {useState} from 'react';\n\nexport interface TreeOptions<T extends object> {\n  /** Initial root items in the tree. */\n  initialItems?: T[],\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: Iterable<Key>,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that returns the children for an item object. */\n  getChildren?: (item: T) => T[]\n}\n\ninterface TreeNode<T extends object> {\n  /** A unique key for the tree node. */\n  key: Key,\n  /** The key of the parent node. */\n  parentKey?: Key | null,\n  /** The value object for the tree node. */\n  value: T,\n  /** Children of the tree node. */\n  children: TreeNode<T>[] | null\n}\n\nexport interface TreeData<T extends object> {\n  /** The root nodes in the tree. */\n  items: TreeNode<T>[],\n\n  /** The keys of the currently selected items in the tree. */\n  selectedKeys: Set<Key>,\n\n  /** Sets the selected keys. */\n  setSelectedKeys(keys: Set<Key>): void,\n\n  /**\n   * Gets a node from the tree by key.\n   * @param key - The key of the item to retrieve.\n   */\n  getItem(key: Key): TreeNode<T> | undefined,\n\n  /**\n   * Inserts an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param index - The index within the parent to insert into.\n   * @param value - The value to insert.\n   */\n  insert(parentKey: Key | null, index: number, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list before the item at the given key.\n   * @param key - The key of the item to insert before.\n   * @param values - The values to insert.\n   */\n  insertBefore(key: Key, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list after the item at the given key.\n   * @param key - The key of the item to insert after.\n   * @param values - The values to insert.\n   */\n  insertAfter(key: Key, ...values: T[]): void,\n\n  /**\n   * Appends an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param value - The value to insert.\n   */\n  append(parentKey: Key | null, ...values: T[]): void,\n\n  /**\n   * Prepends an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param value - The value to insert.\n   */\n  prepend(parentKey: Key | null, ...value: T[]): void,\n\n  /**\n   * Removes an item from the tree by its key.\n   * @param key - The key of the item to remove.\n   */\n  remove(...keys: Key[]): void,\n\n  /**\n   * Removes all items from the tree that are currently\n   * in the set of selected items.\n   */\n  removeSelectedItems(): void,\n\n  /**\n   * Moves an item within the tree.\n   * @param key - The key of the item to move.\n   * @param toParentKey - The key of the new parent to insert into. `null` for the root.\n   * @param index - The index within the new parent to insert at.\n   */\n  move(key: Key, toParentKey: Key | null, index: number): void,\n\n  /**\n   * Updates an item in the tree.\n   * @param key - The key of the item to update.\n   * @param newValue - The new value for the item.\n   */\n  update(key: Key, newValue: T): void\n}\n\n/**\n * Manages state for an immutable tree data structure, and provides convenience methods to\n * update the data over time.\n */\nexport function useTreeData<T extends object>(options: TreeOptions<T>): TreeData<T> {\n  let {\n    initialItems = [],\n    initialSelectedKeys,\n    getKey = (item: any) => item.id ?? item.key,\n    getChildren = (item: any) => item.children\n  } = options;\n\n  // We only want to compute this on initial render.\n  let [tree, setItems] = useState<{items: TreeNode<T>[], nodeMap: Map<Key, TreeNode<T>>}>(() => buildTree(initialItems, new Map()));\n  let {items, nodeMap} = tree;\n\n  let [selectedKeys, setSelectedKeys] = useState(new Set<Key>(initialSelectedKeys || []));\n\n  function buildTree(initialItems: T[] | null = [], map: Map<Key, TreeNode<T>>, parentKey?: Key | null) {\n    if (initialItems == null) {\n      initialItems = [];\n    }\n    return {\n      items: initialItems.map(item => {\n        let node: TreeNode<T> = {\n          key: getKey(item),\n          parentKey: parentKey,\n          value: item,\n          children: null\n        };\n\n        node.children = buildTree(getChildren(item), map, node.key).items;\n        map.set(node.key, node);\n        return node;\n      }),\n      nodeMap: map\n    };\n  }\n\n  function updateTree(items: TreeNode<T>[], key: Key, update: (node: TreeNode<T>) => TreeNode<T> | null, originalMap: Map<Key, TreeNode<T>>) {\n    let node = originalMap.get(key);\n    if (!node) {\n      return {items, nodeMap: originalMap};\n    }\n    let map = new Map<Key, TreeNode<T>>(originalMap);\n\n    // Create a new node. If null, then delete the node, otherwise replace.\n    let newNode = update(node);\n    if (newNode == null) {\n      deleteNode(node, map);\n    } else {\n      addNode(newNode, map);\n    }\n\n    // Walk up the tree and update each parent to refer to the new children.\n    while (node && node.parentKey) {\n      let nextParent = map.get(node.parentKey)!;\n      let copy: TreeNode<T> = {\n        key: nextParent.key,\n        parentKey: nextParent.parentKey,\n        value: nextParent.value,\n        children: null\n      };\n\n      let children = nextParent.children;\n      if (newNode == null && children) {\n        children = children.filter(c => c !== node);\n      }\n\n      copy.children = children?.map(child => {\n        if (child === node) {\n          // newNode cannot be null here due to the above filter.\n          return newNode!;\n        }\n\n        return child;\n      }) ?? null;\n\n      map.set(copy.key, copy);\n\n      newNode = copy;\n      node = nextParent;\n    }\n\n    if (newNode == null) {\n      items = items.filter(c => c !== node);\n    }\n\n    return {\n      items: items.map(item => {\n        if (item === node) {\n          // newNode cannot be null here due to the above filter.\n          return newNode!;\n        }\n\n        return item;\n      }),\n      nodeMap: map\n    };\n  }\n\n  function addNode(node: TreeNode<T>, map: Map<Key, TreeNode<T>>) {\n    map.set(node.key, node);\n    if (node.children) {\n      for (let child of node.children) {\n        addNode(child, map);\n      }\n    }\n  }\n\n  function deleteNode(node: TreeNode<T>, map: Map<Key, TreeNode<T>>) {\n    map.delete(node.key);\n    if (node.children) {\n      for (let child of node.children) {\n        deleteNode(child, map);\n      }\n    }\n  }\n\n  return {\n    items,\n    selectedKeys,\n    setSelectedKeys,\n    getItem(key: Key) {\n      return nodeMap.get(key);\n    },\n    insert(parentKey: Key | null, index: number, ...values: T[]) {\n      setItems(({items, nodeMap: originalMap}) => {\n        let {items: newNodes, nodeMap: newMap} = buildTree(values, originalMap, parentKey);\n\n        // If parentKey is null, insert into the root.\n        if (parentKey == null) {\n          return {\n            items: [\n              ...items.slice(0, index),\n              ...newNodes,\n              ...items.slice(index)\n            ],\n            nodeMap: newMap\n          };\n        }\n\n        // Otherwise, update the parent node and its ancestors.\n        return updateTree(items, parentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [\n            ...parentNode.children!.slice(0, index),\n            ...newNodes,\n            ...parentNode.children!.slice(index)\n          ]\n        }), newMap);\n      });\n    },\n    insertBefore(key: Key, ...values: T[]): void {\n      let node = nodeMap.get(key);\n      if (!node) {\n        return;\n      }\n\n      let parentNode = nodeMap.get(node.parentKey!);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes!.indexOf(node);\n      this.insert(parentNode?.key ?? null, index, ...values);\n    },\n    insertAfter(key: Key, ...values: T[]): void {\n      let node = nodeMap.get(key);\n      if (!node) {\n        return;\n      }\n\n      let parentNode = nodeMap.get(node.parentKey!);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes!.indexOf(node);\n      this.insert(parentNode?.key ?? null, index + 1, ...values);\n    },\n    prepend(parentKey: Key | null, ...values: T[]) {\n      this.insert(parentKey, 0, ...values);\n    },\n    append(parentKey: Key | null, ...values: T[]) {\n      if (parentKey == null) {\n        this.insert(null, items.length, ...values);\n      } else {\n        let parentNode = nodeMap.get(parentKey);\n        if (!parentNode) {\n          return;\n        }\n\n        this.insert(parentKey, parentNode.children!.length, ...values);\n      }\n    },\n    remove(...keys: Key[]) {\n      if (keys.length === 0) {\n        return;\n      }\n\n      let newItems = items;\n      let prevMap = nodeMap;\n      let newTree;\n      for (let key of keys) {\n        newTree = updateTree(newItems, key, () => null, prevMap);\n        prevMap = newTree.nodeMap;\n        newItems = newTree.items;\n      }\n\n      setItems(newTree);\n\n      let selection = new Set(selectedKeys);\n      for (let key of selectedKeys) {\n        if (!newTree.nodeMap.has(key)) {\n          selection.delete(key);\n        }\n      }\n\n      setSelectedKeys(selection);\n    },\n    removeSelectedItems() {\n      this.remove(...selectedKeys);\n    },\n    move(key: Key, toParentKey: Key | null, index: number) {\n      setItems(({items, nodeMap: originalMap}) => {\n        let node = originalMap.get(key);\n        if (!node) {\n          return {items, nodeMap: originalMap};\n        }\n\n        let {items: newItems, nodeMap: newMap} = updateTree(items, key, () => null, originalMap);\n\n\n        const movedNode = {\n          ...node,\n          parentKey: toParentKey\n        };\n\n        // If parentKey is null, insert into the root.\n        if (toParentKey == null) {\n          newMap.set(movedNode.key, movedNode);\n          return {items: [\n            ...newItems.slice(0, index),\n            movedNode,\n            ...newItems.slice(index)\n          ], nodeMap: newMap};\n        }\n\n        // Otherwise, update the parent node and its ancestors.\n        return updateTree(newItems, toParentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [\n            ...parentNode.children!.slice(0, index),\n            movedNode,\n            ...parentNode.children!.slice(index)\n          ]\n        }), newMap);\n      });\n    },\n    update(oldKey: Key, newValue: T) {\n      setItems(({items, nodeMap: originalMap}) => updateTree(items, oldKey, oldNode => {\n        let node: TreeNode<T> = {\n          key: oldNode.key,\n          parentKey: oldNode.parentKey,\n          value: newValue,\n          children: null\n        };\n\n        let tree = buildTree(getChildren(newValue), originalMap, node.key);\n        node.children = tree.items;\n        return node;\n      }, originalMap));\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
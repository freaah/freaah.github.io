{"ast":null,"code":"import { isScrollable as $2wNms$isScrollable, getScrollParent as $2wNms$getScrollParent, isWebKit as $2wNms$isWebKit, isIOS as $2wNms$isIOS } from \"@react-aria/utils\";\nimport { useRef as $2wNms$useRef, useEffect as $2wNms$useEffect, useCallback as $2wNms$useCallback } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nconst $80d9daea3067eff3$var$AUTOSCROLL_AREA_SIZE = 20;\nfunction $80d9daea3067eff3$export$6323452ca4533ed8(ref) {\n  let scrollableRef = (0, $2wNms$useRef)(null);\n  let scrollableX = (0, $2wNms$useRef)(true);\n  let scrollableY = (0, $2wNms$useRef)(true);\n  (0, $2wNms$useEffect)(() => {\n    if (ref.current) {\n      scrollableRef.current = (0, $2wNms$isScrollable)(ref.current) ? ref.current : (0, $2wNms$getScrollParent)(ref.current);\n      let style = window.getComputedStyle(scrollableRef.current);\n      scrollableX.current = /(auto|scroll)/.test(style.overflowX);\n      scrollableY.current = /(auto|scroll)/.test(style.overflowY);\n    }\n  }, [ref]);\n  let state = (0, $2wNms$useRef)({\n    timer: undefined,\n    dx: 0,\n    dy: 0\n  }).current;\n  (0, $2wNms$useEffect)(() => {\n    return () => {\n      if (state.timer) {\n        cancelAnimationFrame(state.timer);\n        state.timer = undefined;\n      }\n    };\n    // state will become a new object, so it's ok to use in the dependency array for unmount\n  }, [state]);\n  let scroll = (0, $2wNms$useCallback)(() => {\n    if (scrollableX.current && scrollableRef.current) scrollableRef.current.scrollLeft += state.dx;\n    if (scrollableY.current && scrollableRef.current) scrollableRef.current.scrollTop += state.dy;\n    if (state.timer) state.timer = requestAnimationFrame(scroll);\n  }, [scrollableRef, state]);\n  return {\n    move(x, y) {\n      // Most browsers auto scroll natively, but WebKit on macOS does not (iOS does ü§∑‚Äç‚ôÇÔ∏è).\n      // https://bugs.webkit.org/show_bug.cgi?id=222636\n      if (!(0, $2wNms$isWebKit)() || (0, $2wNms$isIOS)() || !scrollableRef.current) return;\n      let box = scrollableRef.current.getBoundingClientRect();\n      let left = $80d9daea3067eff3$var$AUTOSCROLL_AREA_SIZE;\n      let top = $80d9daea3067eff3$var$AUTOSCROLL_AREA_SIZE;\n      let bottom = box.height - $80d9daea3067eff3$var$AUTOSCROLL_AREA_SIZE;\n      let right = box.width - $80d9daea3067eff3$var$AUTOSCROLL_AREA_SIZE;\n      if (x < left || x > right || y < top || y > bottom) {\n        if (x < left) state.dx = x - left;else if (x > right) state.dx = x - right;\n        if (y < top) state.dy = y - top;else if (y > bottom) state.dy = y - bottom;\n        if (!state.timer) state.timer = requestAnimationFrame(scroll);\n      } else this.stop();\n    },\n    stop() {\n      if (state.timer) {\n        cancelAnimationFrame(state.timer);\n        state.timer = undefined;\n      }\n    }\n  };\n}\nexport { $80d9daea3067eff3$export$6323452ca4533ed8 as useAutoScroll };","map":{"version":3,"names":["$80d9daea3067eff3$var$AUTOSCROLL_AREA_SIZE","$80d9daea3067eff3$export$6323452ca4533ed8","ref","scrollableRef","$2wNms$useRef","scrollableX","scrollableY","$2wNms$useEffect","current","$2wNms$isScrollable","$2wNms$getScrollParent","style","window","getComputedStyle","test","overflowX","overflowY","state","timer","undefined","dx","dy","cancelAnimationFrame","scroll","$2wNms$useCallback","scrollLeft","scrollTop","requestAnimationFrame","move","x","y","$2wNms$isWebKit","$2wNms$isIOS","box","getBoundingClientRect","left","top","bottom","height","right","width","stop"],"sources":["C:\\Users\\rewac\\OneDrive\\Documents\\GitHub\\scatch-store.me\\node_modules\\@react-aria\\dnd\\dist\\packages\\@react-aria\\dnd\\src\\useAutoScroll.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {getScrollParent, isIOS, isScrollable, isWebKit} from '@react-aria/utils';\nimport {RefObject} from '@react-types/shared';\nimport {useCallback, useEffect, useRef} from 'react';\n\nconst AUTOSCROLL_AREA_SIZE = 20;\n\nexport function useAutoScroll(ref: RefObject<Element | null>) {\n  let scrollableRef = useRef<Element>(null);\n  let scrollableX = useRef(true);\n  let scrollableY = useRef(true);\n  useEffect(() => {\n    if (ref.current) {\n      scrollableRef.current = isScrollable(ref.current) ? ref.current : getScrollParent(ref.current);\n      let style = window.getComputedStyle(scrollableRef.current);\n      scrollableX.current = /(auto|scroll)/.test(style.overflowX);\n      scrollableY.current = /(auto|scroll)/.test(style.overflowY);\n    }\n  }, [ref]);\n\n  let state = useRef<{timer: ReturnType<typeof requestAnimationFrame> | undefined, dx: number, dy: number}>({\n    timer: undefined,\n    dx: 0,\n    dy: 0\n  }).current;\n\n  useEffect(() => {\n    return () => {\n      if (state.timer) {\n        cancelAnimationFrame(state.timer);\n        state.timer = undefined;\n      }\n    };\n  // state will become a new object, so it's ok to use in the dependency array for unmount\n  }, [state]);\n\n  let scroll = useCallback(() => {\n    if (scrollableX.current && scrollableRef.current) {\n      scrollableRef.current.scrollLeft += state.dx;\n    }\n    if (scrollableY.current && scrollableRef.current) {\n      scrollableRef.current.scrollTop += state.dy;\n    }\n\n    if (state.timer) {\n      state.timer = requestAnimationFrame(scroll);\n    }\n  }, [scrollableRef, state]);\n\n  return {\n    move(x, y) {\n      // Most browsers auto scroll natively, but WebKit on macOS does not (iOS does ü§∑‚Äç‚ôÇÔ∏è).\n      // https://bugs.webkit.org/show_bug.cgi?id=222636\n      if (!isWebKit() || isIOS() || !scrollableRef.current) {\n        return;\n      }\n\n      let box = scrollableRef.current.getBoundingClientRect();\n      let left = AUTOSCROLL_AREA_SIZE;\n      let top = AUTOSCROLL_AREA_SIZE;\n      let bottom = box.height - AUTOSCROLL_AREA_SIZE;\n      let right = box.width - AUTOSCROLL_AREA_SIZE;\n      if (x < left || x > right || y < top || y > bottom) {\n        if (x < left) {\n          state.dx = x - left;\n        } else if (x > right) {\n          state.dx = x - right;\n        }\n        if (y < top) {\n          state.dy = y - top;\n        } else if (y > bottom) {\n          state.dy = y - bottom;\n        }\n\n        if (!state.timer) {\n          state.timer = requestAnimationFrame(scroll);\n        }\n      } else {\n        this.stop();\n      }\n    },\n    stop() {\n      if (state.timer) {\n        cancelAnimationFrame(state.timer);\n        state.timer = undefined;\n      }\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
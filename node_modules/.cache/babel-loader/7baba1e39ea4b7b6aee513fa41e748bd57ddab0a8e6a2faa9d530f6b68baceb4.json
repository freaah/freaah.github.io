{"ast":null,"code":"import { useState as $3pPTd$useState } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nfunction $be2ea0343af54212$export$d14e1352e21f4a16(options) {\n  let {\n    initialItems = [],\n    initialSelectedKeys: initialSelectedKeys,\n    getKey = item => {\n      var _item_id;\n      return (_item_id = item.id) !== null && _item_id !== void 0 ? _item_id : item.key;\n    },\n    getChildren = item => item.children\n  } = options;\n  // We only want to compute this on initial render.\n  let [tree, setItems] = (0, $3pPTd$useState)(() => buildTree(initialItems, new Map()));\n  let {\n    items: items,\n    nodeMap: nodeMap\n  } = tree;\n  let [selectedKeys, setSelectedKeys] = (0, $3pPTd$useState)(new Set(initialSelectedKeys || []));\n  function buildTree(initialItems = [], map, parentKey) {\n    if (initialItems == null) initialItems = [];\n    return {\n      items: initialItems.map(item => {\n        let node = {\n          key: getKey(item),\n          parentKey: parentKey,\n          value: item,\n          children: null\n        };\n        node.children = buildTree(getChildren(item), map, node.key).items;\n        map.set(node.key, node);\n        return node;\n      }),\n      nodeMap: map\n    };\n  }\n  function updateTree(items, key, update, originalMap) {\n    let node = originalMap.get(key);\n    if (!node) return {\n      items: items,\n      nodeMap: originalMap\n    };\n    let map = new Map(originalMap);\n    // Create a new node. If null, then delete the node, otherwise replace.\n    let newNode = update(node);\n    if (newNode == null) deleteNode(node, map);else addNode(newNode, map);\n    // Walk up the tree and update each parent to refer to the new children.\n    while (node && node.parentKey) {\n      let nextParent = map.get(node.parentKey);\n      let copy = {\n        key: nextParent.key,\n        parentKey: nextParent.parentKey,\n        value: nextParent.value,\n        children: null\n      };\n      let children = nextParent.children;\n      if (newNode == null && children) children = children.filter(c => c !== node);\n      var _children_map;\n      copy.children = (_children_map = children === null || children === void 0 ? void 0 : children.map(child => {\n        if (child === node)\n          // newNode cannot be null here due to the above filter.\n          return newNode;\n        return child;\n      })) !== null && _children_map !== void 0 ? _children_map : null;\n      map.set(copy.key, copy);\n      newNode = copy;\n      node = nextParent;\n    }\n    if (newNode == null) items = items.filter(c => c !== node);\n    return {\n      items: items.map(item => {\n        if (item === node)\n          // newNode cannot be null here due to the above filter.\n          return newNode;\n        return item;\n      }),\n      nodeMap: map\n    };\n  }\n  function addNode(node, map) {\n    map.set(node.key, node);\n    if (node.children) for (let child of node.children) addNode(child, map);\n  }\n  function deleteNode(node, map) {\n    map.delete(node.key);\n    if (node.children) for (let child of node.children) deleteNode(child, map);\n  }\n  return {\n    items: items,\n    selectedKeys: selectedKeys,\n    setSelectedKeys: setSelectedKeys,\n    getItem(key) {\n      return nodeMap.get(key);\n    },\n    insert(parentKey, index, ...values) {\n      setItems(({\n        items: items,\n        nodeMap: originalMap\n      }) => {\n        let {\n          items: newNodes,\n          nodeMap: newMap\n        } = buildTree(values, originalMap, parentKey);\n        // If parentKey is null, insert into the root.\n        if (parentKey == null) return {\n          items: [...items.slice(0, index), ...newNodes, ...items.slice(index)],\n          nodeMap: newMap\n        };\n        // Otherwise, update the parent node and its ancestors.\n        return updateTree(items, parentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [...parentNode.children.slice(0, index), ...newNodes, ...parentNode.children.slice(index)]\n        }), newMap);\n      });\n    },\n    insertBefore(key, ...values) {\n      let node = nodeMap.get(key);\n      if (!node) return;\n      let parentNode = nodeMap.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes.indexOf(node);\n      var _parentNode_key;\n      this.insert((_parentNode_key = parentNode === null || parentNode === void 0 ? void 0 : parentNode.key) !== null && _parentNode_key !== void 0 ? _parentNode_key : null, index, ...values);\n    },\n    insertAfter(key, ...values) {\n      let node = nodeMap.get(key);\n      if (!node) return;\n      let parentNode = nodeMap.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes.indexOf(node);\n      var _parentNode_key;\n      this.insert((_parentNode_key = parentNode === null || parentNode === void 0 ? void 0 : parentNode.key) !== null && _parentNode_key !== void 0 ? _parentNode_key : null, index + 1, ...values);\n    },\n    prepend(parentKey, ...values) {\n      this.insert(parentKey, 0, ...values);\n    },\n    append(parentKey, ...values) {\n      if (parentKey == null) this.insert(null, items.length, ...values);else {\n        let parentNode = nodeMap.get(parentKey);\n        if (!parentNode) return;\n        this.insert(parentKey, parentNode.children.length, ...values);\n      }\n    },\n    remove(...keys) {\n      if (keys.length === 0) return;\n      let newItems = items;\n      let prevMap = nodeMap;\n      let newTree;\n      for (let key of keys) {\n        newTree = updateTree(newItems, key, () => null, prevMap);\n        prevMap = newTree.nodeMap;\n        newItems = newTree.items;\n      }\n      setItems(newTree);\n      let selection = new Set(selectedKeys);\n      for (let key of selectedKeys) if (!newTree.nodeMap.has(key)) selection.delete(key);\n      setSelectedKeys(selection);\n    },\n    removeSelectedItems() {\n      this.remove(...selectedKeys);\n    },\n    move(key, toParentKey, index) {\n      setItems(({\n        items: items,\n        nodeMap: originalMap\n      }) => {\n        let node = originalMap.get(key);\n        if (!node) return {\n          items: items,\n          nodeMap: originalMap\n        };\n        let {\n          items: newItems,\n          nodeMap: newMap\n        } = updateTree(items, key, () => null, originalMap);\n        const movedNode = {\n          ...node,\n          parentKey: toParentKey\n        };\n        // If parentKey is null, insert into the root.\n        if (toParentKey == null) {\n          newMap.set(movedNode.key, movedNode);\n          return {\n            items: [...newItems.slice(0, index), movedNode, ...newItems.slice(index)],\n            nodeMap: newMap\n          };\n        }\n        // Otherwise, update the parent node and its ancestors.\n        return updateTree(newItems, toParentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [...parentNode.children.slice(0, index), movedNode, ...parentNode.children.slice(index)]\n        }), newMap);\n      });\n    },\n    update(oldKey, newValue) {\n      setItems(({\n        items: items,\n        nodeMap: originalMap\n      }) => updateTree(items, oldKey, oldNode => {\n        let node = {\n          key: oldNode.key,\n          parentKey: oldNode.parentKey,\n          value: newValue,\n          children: null\n        };\n        let tree = buildTree(getChildren(newValue), originalMap, node.key);\n        node.children = tree.items;\n        return node;\n      }, originalMap));\n    }\n  };\n}\nexport { $be2ea0343af54212$export$d14e1352e21f4a16 as useTreeData };","map":{"version":3,"names":["$be2ea0343af54212$export$d14e1352e21f4a16","options","initialItems","initialSelectedKeys","getKey","item","_item_id","id","key","getChildren","children","tree","setItems","$3pPTd$useState","buildTree","Map","items","nodeMap","selectedKeys","setSelectedKeys","Set","map","parentKey","node","value","set","updateTree","update","originalMap","get","newNode","deleteNode","addNode","nextParent","copy","filter","c","_children_map","child","delete","getItem","insert","index","values","newNodes","newMap","slice","parentNode","insertBefore","nodes","indexOf","_parentNode_key","insertAfter","prepend","append","length","remove","keys","newItems","prevMap","newTree","selection","has","removeSelectedItems","move","toParentKey","movedNode","oldKey","newValue","oldNode"],"sources":["C:\\Users\\rewac\\OneDrive\\Documents\\GitHub\\scatch-store.me\\node_modules\\@react-stately\\data\\dist\\packages\\@react-stately\\data\\src\\useTreeData.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from '@react-types/shared';\nimport {useState} from 'react';\n\nexport interface TreeOptions<T extends object> {\n  /** Initial root items in the tree. */\n  initialItems?: T[],\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: Iterable<Key>,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that returns the children for an item object. */\n  getChildren?: (item: T) => T[]\n}\n\ninterface TreeNode<T extends object> {\n  /** A unique key for the tree node. */\n  key: Key,\n  /** The key of the parent node. */\n  parentKey?: Key | null,\n  /** The value object for the tree node. */\n  value: T,\n  /** Children of the tree node. */\n  children: TreeNode<T>[] | null\n}\n\nexport interface TreeData<T extends object> {\n  /** The root nodes in the tree. */\n  items: TreeNode<T>[],\n\n  /** The keys of the currently selected items in the tree. */\n  selectedKeys: Set<Key>,\n\n  /** Sets the selected keys. */\n  setSelectedKeys(keys: Set<Key>): void,\n\n  /**\n   * Gets a node from the tree by key.\n   * @param key - The key of the item to retrieve.\n   */\n  getItem(key: Key): TreeNode<T> | undefined,\n\n  /**\n   * Inserts an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param index - The index within the parent to insert into.\n   * @param value - The value to insert.\n   */\n  insert(parentKey: Key | null, index: number, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list before the item at the given key.\n   * @param key - The key of the item to insert before.\n   * @param values - The values to insert.\n   */\n  insertBefore(key: Key, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list after the item at the given key.\n   * @param key - The key of the item to insert after.\n   * @param values - The values to insert.\n   */\n  insertAfter(key: Key, ...values: T[]): void,\n\n  /**\n   * Appends an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param value - The value to insert.\n   */\n  append(parentKey: Key | null, ...values: T[]): void,\n\n  /**\n   * Prepends an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param value - The value to insert.\n   */\n  prepend(parentKey: Key | null, ...value: T[]): void,\n\n  /**\n   * Removes an item from the tree by its key.\n   * @param key - The key of the item to remove.\n   */\n  remove(...keys: Key[]): void,\n\n  /**\n   * Removes all items from the tree that are currently\n   * in the set of selected items.\n   */\n  removeSelectedItems(): void,\n\n  /**\n   * Moves an item within the tree.\n   * @param key - The key of the item to move.\n   * @param toParentKey - The key of the new parent to insert into. `null` for the root.\n   * @param index - The index within the new parent to insert at.\n   */\n  move(key: Key, toParentKey: Key | null, index: number): void,\n\n  /**\n   * Updates an item in the tree.\n   * @param key - The key of the item to update.\n   * @param newValue - The new value for the item.\n   */\n  update(key: Key, newValue: T): void\n}\n\n/**\n * Manages state for an immutable tree data structure, and provides convenience methods to\n * update the data over time.\n */\nexport function useTreeData<T extends object>(options: TreeOptions<T>): TreeData<T> {\n  let {\n    initialItems = [],\n    initialSelectedKeys,\n    getKey = (item: any) => item.id ?? item.key,\n    getChildren = (item: any) => item.children\n  } = options;\n\n  // We only want to compute this on initial render.\n  let [tree, setItems] = useState<{items: TreeNode<T>[], nodeMap: Map<Key, TreeNode<T>>}>(() => buildTree(initialItems, new Map()));\n  let {items, nodeMap} = tree;\n\n  let [selectedKeys, setSelectedKeys] = useState(new Set<Key>(initialSelectedKeys || []));\n\n  function buildTree(initialItems: T[] | null = [], map: Map<Key, TreeNode<T>>, parentKey?: Key | null) {\n    if (initialItems == null) {\n      initialItems = [];\n    }\n    return {\n      items: initialItems.map(item => {\n        let node: TreeNode<T> = {\n          key: getKey(item),\n          parentKey: parentKey,\n          value: item,\n          children: null\n        };\n\n        node.children = buildTree(getChildren(item), map, node.key).items;\n        map.set(node.key, node);\n        return node;\n      }),\n      nodeMap: map\n    };\n  }\n\n  function updateTree(items: TreeNode<T>[], key: Key, update: (node: TreeNode<T>) => TreeNode<T> | null, originalMap: Map<Key, TreeNode<T>>) {\n    let node = originalMap.get(key);\n    if (!node) {\n      return {items, nodeMap: originalMap};\n    }\n    let map = new Map<Key, TreeNode<T>>(originalMap);\n\n    // Create a new node. If null, then delete the node, otherwise replace.\n    let newNode = update(node);\n    if (newNode == null) {\n      deleteNode(node, map);\n    } else {\n      addNode(newNode, map);\n    }\n\n    // Walk up the tree and update each parent to refer to the new children.\n    while (node && node.parentKey) {\n      let nextParent = map.get(node.parentKey)!;\n      let copy: TreeNode<T> = {\n        key: nextParent.key,\n        parentKey: nextParent.parentKey,\n        value: nextParent.value,\n        children: null\n      };\n\n      let children = nextParent.children;\n      if (newNode == null && children) {\n        children = children.filter(c => c !== node);\n      }\n\n      copy.children = children?.map(child => {\n        if (child === node) {\n          // newNode cannot be null here due to the above filter.\n          return newNode!;\n        }\n\n        return child;\n      }) ?? null;\n\n      map.set(copy.key, copy);\n\n      newNode = copy;\n      node = nextParent;\n    }\n\n    if (newNode == null) {\n      items = items.filter(c => c !== node);\n    }\n\n    return {\n      items: items.map(item => {\n        if (item === node) {\n          // newNode cannot be null here due to the above filter.\n          return newNode!;\n        }\n\n        return item;\n      }),\n      nodeMap: map\n    };\n  }\n\n  function addNode(node: TreeNode<T>, map: Map<Key, TreeNode<T>>) {\n    map.set(node.key, node);\n    if (node.children) {\n      for (let child of node.children) {\n        addNode(child, map);\n      }\n    }\n  }\n\n  function deleteNode(node: TreeNode<T>, map: Map<Key, TreeNode<T>>) {\n    map.delete(node.key);\n    if (node.children) {\n      for (let child of node.children) {\n        deleteNode(child, map);\n      }\n    }\n  }\n\n  return {\n    items,\n    selectedKeys,\n    setSelectedKeys,\n    getItem(key: Key) {\n      return nodeMap.get(key);\n    },\n    insert(parentKey: Key | null, index: number, ...values: T[]) {\n      setItems(({items, nodeMap: originalMap}) => {\n        let {items: newNodes, nodeMap: newMap} = buildTree(values, originalMap, parentKey);\n\n        // If parentKey is null, insert into the root.\n        if (parentKey == null) {\n          return {\n            items: [\n              ...items.slice(0, index),\n              ...newNodes,\n              ...items.slice(index)\n            ],\n            nodeMap: newMap\n          };\n        }\n\n        // Otherwise, update the parent node and its ancestors.\n        return updateTree(items, parentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [\n            ...parentNode.children!.slice(0, index),\n            ...newNodes,\n            ...parentNode.children!.slice(index)\n          ]\n        }), newMap);\n      });\n    },\n    insertBefore(key: Key, ...values: T[]): void {\n      let node = nodeMap.get(key);\n      if (!node) {\n        return;\n      }\n\n      let parentNode = nodeMap.get(node.parentKey!);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes!.indexOf(node);\n      this.insert(parentNode?.key ?? null, index, ...values);\n    },\n    insertAfter(key: Key, ...values: T[]): void {\n      let node = nodeMap.get(key);\n      if (!node) {\n        return;\n      }\n\n      let parentNode = nodeMap.get(node.parentKey!);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes!.indexOf(node);\n      this.insert(parentNode?.key ?? null, index + 1, ...values);\n    },\n    prepend(parentKey: Key | null, ...values: T[]) {\n      this.insert(parentKey, 0, ...values);\n    },\n    append(parentKey: Key | null, ...values: T[]) {\n      if (parentKey == null) {\n        this.insert(null, items.length, ...values);\n      } else {\n        let parentNode = nodeMap.get(parentKey);\n        if (!parentNode) {\n          return;\n        }\n\n        this.insert(parentKey, parentNode.children!.length, ...values);\n      }\n    },\n    remove(...keys: Key[]) {\n      if (keys.length === 0) {\n        return;\n      }\n\n      let newItems = items;\n      let prevMap = nodeMap;\n      let newTree;\n      for (let key of keys) {\n        newTree = updateTree(newItems, key, () => null, prevMap);\n        prevMap = newTree.nodeMap;\n        newItems = newTree.items;\n      }\n\n      setItems(newTree);\n\n      let selection = new Set(selectedKeys);\n      for (let key of selectedKeys) {\n        if (!newTree.nodeMap.has(key)) {\n          selection.delete(key);\n        }\n      }\n\n      setSelectedKeys(selection);\n    },\n    removeSelectedItems() {\n      this.remove(...selectedKeys);\n    },\n    move(key: Key, toParentKey: Key | null, index: number) {\n      setItems(({items, nodeMap: originalMap}) => {\n        let node = originalMap.get(key);\n        if (!node) {\n          return {items, nodeMap: originalMap};\n        }\n\n        let {items: newItems, nodeMap: newMap} = updateTree(items, key, () => null, originalMap);\n\n\n        const movedNode = {\n          ...node,\n          parentKey: toParentKey\n        };\n\n        // If parentKey is null, insert into the root.\n        if (toParentKey == null) {\n          newMap.set(movedNode.key, movedNode);\n          return {items: [\n            ...newItems.slice(0, index),\n            movedNode,\n            ...newItems.slice(index)\n          ], nodeMap: newMap};\n        }\n\n        // Otherwise, update the parent node and its ancestors.\n        return updateTree(newItems, toParentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [\n            ...parentNode.children!.slice(0, index),\n            movedNode,\n            ...parentNode.children!.slice(index)\n          ]\n        }), newMap);\n      });\n    },\n    update(oldKey: Key, newValue: T) {\n      setItems(({items, nodeMap: originalMap}) => updateTree(items, oldKey, oldNode => {\n        let node: TreeNode<T> = {\n          key: oldNode.key,\n          parentKey: oldNode.parentKey,\n          value: newValue,\n          children: null\n        };\n\n        let tree = buildTree(getChildren(newValue), originalMap, node.key);\n        node.children = tree.items;\n        return node;\n      }, originalMap));\n    }\n  };\n}\n"],"mappings":";;AAAA;;;;;;;;;;;AAyHO,SAASA,0CAA8BC,OAAuB;EACnE,IAAI;IACFC,YAAA,GAAe,EAAE;IAAAC,mBAAA,EACjBA,mBAAmB;IACnBC,MAAA,GAAUC,IAAA;UAAcC,QAAA;aAAA,CAAAA,QAAA,GAAAD,IAAA,CAAKE,EAAE,cAAPD,QAAA,cAAAA,QAAA,GAAWD,IAAA,CAAKG,GAAG;;IAC3CC,WAAA,GAAeJ,IAAA,IAAcA,IAAA,CAAKK;EAAQ,CAC3C,GAAGT,OAAA;EAEJ;EACA,IAAI,CAACU,IAAA,EAAMC,QAAA,CAAS,GAAG,IAAAC,eAAO,EAA0D,MAAMC,SAAA,CAAUZ,YAAA,EAAc,IAAIa,GAAA;EAC1H,IAAI;IAAAC,KAAA,EAACA,KAAK;IAAAC,OAAA,EAAEA;EAAO,CAAC,GAAGN,IAAA;EAEvB,IAAI,CAACO,YAAA,EAAcC,eAAA,CAAgB,GAAG,IAAAN,eAAO,EAAE,IAAIO,GAAA,CAASjB,mBAAA,IAAuB,EAAE;EAErF,SAASW,UAAUZ,YAAA,GAA2B,EAAE,EAAEmB,GAA0B,EAAEC,SAAsB;IAClG,IAAIpB,YAAA,IAAgB,MAClBA,YAAA,GAAe,EAAE;IAEnB,OAAO;MACLc,KAAA,EAAOd,YAAA,CAAamB,GAAG,CAAChB,IAAA;QACtB,IAAIkB,IAAA,GAAoB;UACtBf,GAAA,EAAKJ,MAAA,CAAOC,IAAA;UACZiB,SAAA,EAAWA,SAAA;UACXE,KAAA,EAAOnB,IAAA;UACPK,QAAA,EAAU;QACZ;QAEAa,IAAA,CAAKb,QAAQ,GAAGI,SAAA,CAAUL,WAAA,CAAYJ,IAAA,GAAOgB,GAAA,EAAKE,IAAA,CAAKf,GAAG,EAAEQ,KAAK;QACjEK,GAAA,CAAII,GAAG,CAACF,IAAA,CAAKf,GAAG,EAAEe,IAAA;QAClB,OAAOA,IAAA;MACT;MACAN,OAAA,EAASI;IACX;EACF;EAEA,SAASK,WAAWV,KAAoB,EAAER,GAAQ,EAAEmB,MAAiD,EAAEC,WAAkC;IACvI,IAAIL,IAAA,GAAOK,WAAA,CAAYC,GAAG,CAACrB,GAAA;IAC3B,IAAI,CAACe,IAAA,EACH,OAAO;aAACP,KAAA;MAAOC,OAAA,EAASW;IAAW;IAErC,IAAIP,GAAA,GAAM,IAAIN,GAAA,CAAsBa,WAAA;IAEpC;IACA,IAAIE,OAAA,GAAUH,MAAA,CAAOJ,IAAA;IACrB,IAAIO,OAAA,IAAW,MACbC,UAAA,CAAWR,IAAA,EAAMF,GAAA,OAEjBW,OAAA,CAAQF,OAAA,EAAST,GAAA;IAGnB;IACA,OAAOE,IAAA,IAAQA,IAAA,CAAKD,SAAS,EAAE;MAC7B,IAAIW,UAAA,GAAaZ,GAAA,CAAIQ,GAAG,CAACN,IAAA,CAAKD,SAAS;MACvC,IAAIY,IAAA,GAAoB;QACtB1B,GAAA,EAAKyB,UAAA,CAAWzB,GAAG;QACnBc,SAAA,EAAWW,UAAA,CAAWX,SAAS;QAC/BE,KAAA,EAAOS,UAAA,CAAWT,KAAK;QACvBd,QAAA,EAAU;MACZ;MAEA,IAAIA,QAAA,GAAWuB,UAAA,CAAWvB,QAAQ;MAClC,IAAIoB,OAAA,IAAW,QAAQpB,QAAA,EACrBA,QAAA,GAAWA,QAAA,CAASyB,MAAM,CAACC,CAAA,IAAKA,CAAA,KAAMb,IAAA;UAGxBc,aAAA;MAAhBH,IAAA,CAAKxB,QAAQ,GAAG,CAAA2B,aAAA,GAAA3B,QAAA,aAAAA,QAAA,uBAAAA,QAAA,CAAUW,GAAG,CAACiB,KAAA;QAC5B,IAAIA,KAAA,KAAUf,IAAA;UACZ;UACA,OAAOO,OAAA;QAGT,OAAOQ,KAAA;MACT,gBAPgBD,aAAA,cAAAA,aAAA,GAOV;MAENhB,GAAA,CAAII,GAAG,CAACS,IAAA,CAAK1B,GAAG,EAAE0B,IAAA;MAElBJ,OAAA,GAAUI,IAAA;MACVX,IAAA,GAAOU,UAAA;IACT;IAEA,IAAIH,OAAA,IAAW,MACbd,KAAA,GAAQA,KAAA,CAAMmB,MAAM,CAACC,CAAA,IAAKA,CAAA,KAAMb,IAAA;IAGlC,OAAO;MACLP,KAAA,EAAOA,KAAA,CAAMK,GAAG,CAAChB,IAAA;QACf,IAAIA,IAAA,KAASkB,IAAA;UACX;UACA,OAAOO,OAAA;QAGT,OAAOzB,IAAA;MACT;MACAY,OAAA,EAASI;IACX;EACF;EAEA,SAASW,QAAQT,IAAiB,EAAEF,GAA0B;IAC5DA,GAAA,CAAII,GAAG,CAACF,IAAA,CAAKf,GAAG,EAAEe,IAAA;IAClB,IAAIA,IAAA,CAAKb,QAAQ,EACf,KAAK,IAAI4B,KAAA,IAASf,IAAA,CAAKb,QAAQ,EAC7BsB,OAAA,CAAQM,KAAA,EAAOjB,GAAA;EAGrB;EAEA,SAASU,WAAWR,IAAiB,EAAEF,GAA0B;IAC/DA,GAAA,CAAIkB,MAAM,CAAChB,IAAA,CAAKf,GAAG;IACnB,IAAIe,IAAA,CAAKb,QAAQ,EACf,KAAK,IAAI4B,KAAA,IAASf,IAAA,CAAKb,QAAQ,EAC7BqB,UAAA,CAAWO,KAAA,EAAOjB,GAAA;EAGxB;EAEA,OAAO;WACLL,KAAA;kBACAE,YAAA;qBACAC,eAAA;IACAqB,QAAQhC,GAAQ;MACd,OAAOS,OAAA,CAAQY,GAAG,CAACrB,GAAA;IACrB;IACAiC,OAAOnB,SAAqB,EAAEoB,KAAa,EAAE,GAAGC,MAAW;MACzD/B,QAAA,CAAS,CAAC;QAAAI,KAAA,EAACA,KAAK;QAAEC,OAAA,EAASW;MAAW,CAAC;QACrC,IAAI;UAACZ,KAAA,EAAO4B,QAAQ;UAAE3B,OAAA,EAAS4B;QAAM,CAAC,GAAG/B,SAAA,CAAU6B,MAAA,EAAQf,WAAA,EAAaN,SAAA;QAExE;QACA,IAAIA,SAAA,IAAa,MACf,OAAO;UACLN,KAAA,EAAO,C,GACFA,KAAA,CAAM8B,KAAK,CAAC,GAAGJ,KAAA,G,GACfE,QAAA,E,GACA5B,KAAA,CAAM8B,KAAK,CAACJ,KAAA,EAChB;UACDzB,OAAA,EAAS4B;QACX;QAGF;QACA,OAAOnB,UAAA,CAAWV,KAAA,EAAOM,SAAA,EAAWyB,UAAA,KAAe;UACjDvC,GAAA,EAAKuC,UAAA,CAAWvC,GAAG;UACnBc,SAAA,EAAWyB,UAAA,CAAWzB,SAAS;UAC/BE,KAAA,EAAOuB,UAAA,CAAWvB,KAAK;UACvBd,QAAA,EAAU,C,GACLqC,UAAA,CAAWrC,QAAQ,CAAEoC,KAAK,CAAC,GAAGJ,KAAA,G,GAC9BE,QAAA,E,GACAG,UAAA,CAAWrC,QAAQ,CAAEoC,KAAK,CAACJ,KAAA;QAElC,IAAIG,MAAA;MACN;IACF;IACAG,aAAaxC,GAAQ,EAAE,GAAGmC,MAAW;MACnC,IAAIpB,IAAA,GAAON,OAAA,CAAQY,GAAG,CAACrB,GAAA;MACvB,IAAI,CAACe,IAAA,EACH;MAGF,IAAIwB,UAAA,GAAa9B,OAAA,CAAQY,GAAG,CAACN,IAAA,CAAKD,SAAS;MAC3C,IAAI2B,KAAA,GAAQF,UAAA,GAAaA,UAAA,CAAWrC,QAAQ,GAAGM,KAAA;MAC/C,IAAI0B,KAAA,GAAQO,KAAA,CAAOC,OAAO,CAAC3B,IAAA;UACf4B,eAAA;MAAZ,IAAI,CAACV,MAAM,CAAC,CAAAU,eAAA,GAAAJ,UAAA,aAAAA,UAAA,uBAAAA,UAAA,CAAYvC,GAAG,cAAf2C,eAAA,cAAAA,eAAA,GAAmB,MAAMT,KAAA,KAAUC,MAAA;IACjD;IACAS,YAAY5C,GAAQ,EAAE,GAAGmC,MAAW;MAClC,IAAIpB,IAAA,GAAON,OAAA,CAAQY,GAAG,CAACrB,GAAA;MACvB,IAAI,CAACe,IAAA,EACH;MAGF,IAAIwB,UAAA,GAAa9B,OAAA,CAAQY,GAAG,CAACN,IAAA,CAAKD,SAAS;MAC3C,IAAI2B,KAAA,GAAQF,UAAA,GAAaA,UAAA,CAAWrC,QAAQ,GAAGM,KAAA;MAC/C,IAAI0B,KAAA,GAAQO,KAAA,CAAOC,OAAO,CAAC3B,IAAA;UACf4B,eAAA;MAAZ,IAAI,CAACV,MAAM,CAAC,CAAAU,eAAA,GAAAJ,UAAA,aAAAA,UAAA,uBAAAA,UAAA,CAAYvC,GAAG,cAAf2C,eAAA,cAAAA,eAAA,GAAmB,MAAMT,KAAA,GAAQ,MAAMC,MAAA;IACrD;IACAU,QAAQ/B,SAAqB,EAAE,GAAGqB,MAAW;MAC3C,IAAI,CAACF,MAAM,CAACnB,SAAA,EAAW,MAAMqB,MAAA;IAC/B;IACAW,OAAOhC,SAAqB,EAAE,GAAGqB,MAAW;MAC1C,IAAIrB,SAAA,IAAa,MACf,IAAI,CAACmB,MAAM,CAAC,MAAMzB,KAAA,CAAMuC,MAAM,KAAKZ,MAAA,OAC9B;QACL,IAAII,UAAA,GAAa9B,OAAA,CAAQY,GAAG,CAACP,SAAA;QAC7B,IAAI,CAACyB,UAAA,EACH;QAGF,IAAI,CAACN,MAAM,CAACnB,SAAA,EAAWyB,UAAA,CAAWrC,QAAQ,CAAE6C,MAAM,KAAKZ,MAAA;MACzD;IACF;IACAa,OAAO,GAAGC,IAAW;MACnB,IAAIA,IAAA,CAAKF,MAAM,KAAK,GAClB;MAGF,IAAIG,QAAA,GAAW1C,KAAA;MACf,IAAI2C,OAAA,GAAU1C,OAAA;MACd,IAAI2C,OAAA;MACJ,KAAK,IAAIpD,GAAA,IAAOiD,IAAA,EAAM;QACpBG,OAAA,GAAUlC,UAAA,CAAWgC,QAAA,EAAUlD,GAAA,EAAK,MAAM,MAAMmD,OAAA;QAChDA,OAAA,GAAUC,OAAA,CAAQ3C,OAAO;QACzByC,QAAA,GAAWE,OAAA,CAAQ5C,KAAK;MAC1B;MAEAJ,QAAA,CAASgD,OAAA;MAET,IAAIC,SAAA,GAAY,IAAIzC,GAAA,CAAIF,YAAA;MACxB,KAAK,IAAIV,GAAA,IAAOU,YAAA,EACd,IAAI,CAAC0C,OAAA,CAAQ3C,OAAO,CAAC6C,GAAG,CAACtD,GAAA,GACvBqD,SAAA,CAAUtB,MAAM,CAAC/B,GAAA;MAIrBW,eAAA,CAAgB0C,SAAA;IAClB;IACAE,oBAAA;MACE,IAAI,CAACP,MAAM,IAAItC,YAAA;IACjB;IACA8C,KAAKxD,GAAQ,EAAEyD,WAAuB,EAAEvB,KAAa;MACnD9B,QAAA,CAAS,CAAC;QAAAI,KAAA,EAACA,KAAK;QAAEC,OAAA,EAASW;MAAW,CAAC;QACrC,IAAIL,IAAA,GAAOK,WAAA,CAAYC,GAAG,CAACrB,GAAA;QAC3B,IAAI,CAACe,IAAA,EACH,OAAO;iBAACP,KAAA;UAAOC,OAAA,EAASW;QAAW;QAGrC,IAAI;UAACZ,KAAA,EAAO0C,QAAQ;UAAEzC,OAAA,EAAS4B;QAAM,CAAC,GAAGnB,UAAA,CAAWV,KAAA,EAAOR,GAAA,EAAK,MAAM,MAAMoB,WAAA;QAG5E,MAAMsC,SAAA,GAAY;UAChB,GAAG3C,IAAI;UACPD,SAAA,EAAW2C;QACb;QAEA;QACA,IAAIA,WAAA,IAAe,MAAM;UACvBpB,MAAA,CAAOpB,GAAG,CAACyC,SAAA,CAAU1D,GAAG,EAAE0D,SAAA;UAC1B,OAAO;YAAClD,KAAA,EAAO,C,GACV0C,QAAA,CAASZ,KAAK,CAAC,GAAGJ,KAAA,GACrBwB,SAAA,E,GACGR,QAAA,CAASZ,KAAK,CAACJ,KAAA,EACnB;YAAEzB,OAAA,EAAS4B;UAAM;QACpB;QAEA;QACA,OAAOnB,UAAA,CAAWgC,QAAA,EAAUO,WAAA,EAAalB,UAAA,KAAe;UACtDvC,GAAA,EAAKuC,UAAA,CAAWvC,GAAG;UACnBc,SAAA,EAAWyB,UAAA,CAAWzB,SAAS;UAC/BE,KAAA,EAAOuB,UAAA,CAAWvB,KAAK;UACvBd,QAAA,EAAU,C,GACLqC,UAAA,CAAWrC,QAAQ,CAAEoC,KAAK,CAAC,GAAGJ,KAAA,GACjCwB,SAAA,E,GACGnB,UAAA,CAAWrC,QAAQ,CAAEoC,KAAK,CAACJ,KAAA;QAElC,IAAIG,MAAA;MACN;IACF;IACAlB,OAAOwC,MAAW,EAAEC,QAAW;MAC7BxD,QAAA,CAAS,CAAC;QAAAI,KAAA,EAACA,KAAK;QAAEC,OAAA,EAASW;MAAW,CAAC,KAAKF,UAAA,CAAWV,KAAA,EAAOmD,MAAA,EAAQE,OAAA;QACpE,IAAI9C,IAAA,GAAoB;UACtBf,GAAA,EAAK6D,OAAA,CAAQ7D,GAAG;UAChBc,SAAA,EAAW+C,OAAA,CAAQ/C,SAAS;UAC5BE,KAAA,EAAO4C,QAAA;UACP1D,QAAA,EAAU;QACZ;QAEA,IAAIC,IAAA,GAAOG,SAAA,CAAUL,WAAA,CAAY2D,QAAA,GAAWxC,WAAA,EAAaL,IAAA,CAAKf,GAAG;QACjEe,IAAA,CAAKb,QAAQ,GAAGC,IAAA,CAAKK,KAAK;QAC1B,OAAOO,IAAA;MACT,GAAGK,WAAA;IACL;EACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _objectSpread from \"C:/Users/rewac/OneDrive/Documents/GitHub/scatch-store.me/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport $8t1z9$intlStringsmodulejs from \"./intlStrings.mjs\";\nimport { useColorAreaGradient as $40297c24c53588e6$export$dd62420467d245ca } from \"./useColorAreaGradient.mjs\";\nimport { useGlobalListeners as $8t1z9$useGlobalListeners, focusWithoutScrolling as $8t1z9$focusWithoutScrolling, useFormReset as $8t1z9$useFormReset, mergeProps as $8t1z9$mergeProps, isIOS as $8t1z9$isIOS, isAndroid as $8t1z9$isAndroid, useLabels as $8t1z9$useLabels } from \"@react-aria/utils\";\nimport { useState as $8t1z9$useState, useCallback as $8t1z9$useCallback, useRef as $8t1z9$useRef } from \"react\";\nimport { useKeyboard as $8t1z9$useKeyboard, useMove as $8t1z9$useMove, useFocusWithin as $8t1z9$useFocusWithin, useFocus as $8t1z9$useFocus } from \"@react-aria/interactions\";\nimport { useLocalizedStringFormatter as $8t1z9$useLocalizedStringFormatter, useLocale as $8t1z9$useLocale } from \"@react-aria/i18n\";\nimport { useVisuallyHidden as $8t1z9$useVisuallyHidden } from \"@react-aria/visually-hidden\";\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $60bd7d6e45dcddfa$export$2f92a7a615a014f6(props, state) {\n  let {\n    isDisabled: isDisabled,\n    inputXRef: inputXRef,\n    inputYRef: inputYRef,\n    containerRef: containerRef,\n    'aria-label': ariaLabel,\n    xName: xName,\n    yName: yName\n  } = props;\n  let stringFormatter = (0, $8t1z9$useLocalizedStringFormatter)((0, $parcel$interopDefault($8t1z9$intlStringsmodulejs)), '@react-aria/color');\n  let {\n    addGlobalListener: addGlobalListener,\n    removeGlobalListener: removeGlobalListener\n  } = (0, $8t1z9$useGlobalListeners)();\n  let {\n    direction: direction,\n    locale: locale\n  } = (0, $8t1z9$useLocale)();\n  let [focusedInput, setFocusedInput] = (0, $8t1z9$useState)(null);\n  let focusInput = (0, $8t1z9$useCallback)(function () {\n    let inputRef = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : inputXRef;\n    if (inputRef.current) (0, $8t1z9$focusWithoutScrolling)(inputRef.current);\n  }, [inputXRef]);\n  (0, $8t1z9$useFormReset)(inputXRef, [state.xValue, state.yValue], _ref => {\n    let [x, y] = _ref;\n    let newColor = state.value.withChannelValue(state.channels.xChannel, x).withChannelValue(state.channels.yChannel, y);\n    state.setValue(newColor);\n  });\n  let [valueChangedViaKeyboard, setValueChangedViaKeyboard] = (0, $8t1z9$useState)(false);\n  let [valueChangedViaInputChangeEvent, setValueChangedViaInputChangeEvent] = (0, $8t1z9$useState)(false);\n  let {\n    xChannel: xChannel,\n    yChannel: yChannel,\n    zChannel: zChannel\n  } = state.channels;\n  let xChannelStep = state.xChannelStep;\n  let yChannelStep = state.yChannelStep;\n  let currentPosition = (0, $8t1z9$useRef)(null);\n  let {\n    keyboardProps: keyboardProps\n  } = (0, $8t1z9$useKeyboard)({\n    onKeyDown(e) {\n      // these are the cases that useMove doesn't handle\n      if (!/^(PageUp|PageDown|Home|End)$/.test(e.key)) {\n        e.continuePropagation();\n        return;\n      }\n      // same handling as useMove, don't need to stop propagation, useKeyboard will do that for us\n      e.preventDefault();\n      // remember to set this and unset it so that onChangeEnd is fired\n      state.setDragging(true);\n      setValueChangedViaKeyboard(true);\n      let dir;\n      switch (e.key) {\n        case 'PageUp':\n          state.incrementY(state.yChannelPageStep);\n          dir = 'y';\n          break;\n        case 'PageDown':\n          state.decrementY(state.yChannelPageStep);\n          dir = 'y';\n          break;\n        case 'Home':\n          direction === 'rtl' ? state.incrementX(state.xChannelPageStep) : state.decrementX(state.xChannelPageStep);\n          dir = 'x';\n          break;\n        case 'End':\n          direction === 'rtl' ? state.decrementX(state.xChannelPageStep) : state.incrementX(state.xChannelPageStep);\n          dir = 'x';\n          break;\n      }\n      state.setDragging(false);\n      if (dir) {\n        let input = dir === 'x' ? inputXRef : inputYRef;\n        focusInput(input);\n        setFocusedInput(dir);\n      }\n    }\n  });\n  let moveHandler = {\n    onMoveStart() {\n      currentPosition.current = null;\n      state.setDragging(true);\n    },\n    onMove(_ref2) {\n      let {\n        deltaX: deltaX,\n        deltaY: deltaY,\n        pointerType: pointerType,\n        shiftKey: shiftKey\n      } = _ref2;\n      var _containerRef_current;\n      let {\n        incrementX: incrementX,\n        decrementX: decrementX,\n        incrementY: incrementY,\n        decrementY: decrementY,\n        xChannelPageStep: xChannelPageStep,\n        xChannelStep: xChannelStep,\n        yChannelPageStep: yChannelPageStep,\n        yChannelStep: yChannelStep,\n        getThumbPosition: getThumbPosition,\n        setColorFromPoint: setColorFromPoint\n      } = state;\n      if (currentPosition.current == null) currentPosition.current = getThumbPosition();\n      let {\n        width: width,\n        height: height\n      } = ((_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 ? void 0 : _containerRef_current.getBoundingClientRect()) || {\n        width: 0,\n        height: 0\n      };\n      let valueChanged = deltaX !== 0 || deltaY !== 0;\n      if (pointerType === 'keyboard') {\n        let deltaXValue = shiftKey && xChannelPageStep > xChannelStep ? xChannelPageStep : xChannelStep;\n        let deltaYValue = shiftKey && yChannelPageStep > yChannelStep ? yChannelPageStep : yChannelStep;\n        if (deltaX > 0 && direction === 'ltr' || deltaX < 0 && direction === 'rtl') incrementX(deltaXValue);else if (deltaX < 0 && direction === 'ltr' || deltaX > 0 && direction === 'rtl') decrementX(deltaXValue);else if (deltaY > 0) decrementY(deltaYValue);else if (deltaY < 0) incrementY(deltaYValue);\n        setValueChangedViaKeyboard(valueChanged);\n        // set the focused input based on which axis has the greater delta\n        focusedInput = valueChanged && Math.abs(deltaY) > Math.abs(deltaX) ? 'y' : 'x';\n        setFocusedInput(focusedInput);\n      } else {\n        currentPosition.current.x += (direction === 'rtl' ? -1 : 1) * deltaX / width;\n        currentPosition.current.y += deltaY / height;\n        setColorFromPoint(currentPosition.current.x, currentPosition.current.y);\n      }\n    },\n    onMoveEnd() {\n      isOnColorArea.current = false;\n      state.setDragging(false);\n      let input = focusedInput === 'x' ? inputXRef : inputYRef;\n      focusInput(input);\n    }\n  };\n  let {\n    moveProps: movePropsThumb\n  } = (0, $8t1z9$useMove)(moveHandler);\n  let {\n    focusWithinProps: focusWithinProps\n  } = (0, $8t1z9$useFocusWithin)({\n    onFocusWithinChange: focusWithin => {\n      if (!focusWithin) {\n        setValueChangedViaKeyboard(false);\n        setValueChangedViaInputChangeEvent(false);\n      }\n    }\n  });\n  let currentPointer = (0, $8t1z9$useRef)(undefined);\n  let isOnColorArea = (0, $8t1z9$useRef)(false);\n  let {\n    moveProps: movePropsContainer\n  } = (0, $8t1z9$useMove)({\n    onMoveStart() {\n      if (isOnColorArea.current) moveHandler.onMoveStart();\n    },\n    onMove(e) {\n      if (isOnColorArea.current) moveHandler.onMove(e);\n    },\n    onMoveEnd() {\n      if (isOnColorArea.current) moveHandler.onMoveEnd();\n    }\n  });\n  let onThumbDown = id => {\n    if (!state.isDragging) {\n      currentPointer.current = id;\n      setValueChangedViaKeyboard(false);\n      focusInput();\n      state.setDragging(true);\n      if (typeof PointerEvent !== 'undefined') addGlobalListener(window, 'pointerup', onThumbUp, false);else {\n        addGlobalListener(window, 'mouseup', onThumbUp, false);\n        addGlobalListener(window, 'touchend', onThumbUp, false);\n      }\n    }\n  };\n  let onThumbUp = e => {\n    var _e_changedTouches;\n    var _e_pointerId;\n    let id = (_e_pointerId = e.pointerId) !== null && _e_pointerId !== void 0 ? _e_pointerId : (_e_changedTouches = e.changedTouches) === null || _e_changedTouches === void 0 ? void 0 : _e_changedTouches[0].identifier;\n    if (id === currentPointer.current) {\n      setValueChangedViaKeyboard(false);\n      focusInput();\n      state.setDragging(false);\n      currentPointer.current = undefined;\n      isOnColorArea.current = false;\n      if (typeof PointerEvent !== 'undefined') removeGlobalListener(window, 'pointerup', onThumbUp, false);else {\n        removeGlobalListener(window, 'mouseup', onThumbUp, false);\n        removeGlobalListener(window, 'touchend', onThumbUp, false);\n      }\n    }\n  };\n  let onColorAreaDown = (colorArea, id, clientX, clientY) => {\n    let rect = colorArea.getBoundingClientRect();\n    let {\n      width: width,\n      height: height\n    } = rect;\n    let x = (clientX - rect.x) / width;\n    let y = (clientY - rect.y) / height;\n    if (direction === 'rtl') x = 1 - x;\n    if (x >= 0 && x <= 1 && y >= 0 && y <= 1 && !state.isDragging && currentPointer.current === undefined) {\n      isOnColorArea.current = true;\n      setValueChangedViaKeyboard(false);\n      currentPointer.current = id;\n      state.setColorFromPoint(x, y);\n      focusInput();\n      state.setDragging(true);\n      if (typeof PointerEvent !== 'undefined') addGlobalListener(window, 'pointerup', onColorAreaUp, false);else {\n        addGlobalListener(window, 'mouseup', onColorAreaUp, false);\n        addGlobalListener(window, 'touchend', onColorAreaUp, false);\n      }\n    }\n  };\n  let onColorAreaUp = e => {\n    var _e_changedTouches;\n    var _e_pointerId;\n    let id = (_e_pointerId = e.pointerId) !== null && _e_pointerId !== void 0 ? _e_pointerId : (_e_changedTouches = e.changedTouches) === null || _e_changedTouches === void 0 ? void 0 : _e_changedTouches[0].identifier;\n    if (isOnColorArea.current && id === currentPointer.current) {\n      isOnColorArea.current = false;\n      setValueChangedViaKeyboard(false);\n      currentPointer.current = undefined;\n      state.setDragging(false);\n      focusInput();\n      if (typeof PointerEvent !== 'undefined') removeGlobalListener(window, 'pointerup', onColorAreaUp, false);else {\n        removeGlobalListener(window, 'mouseup', onColorAreaUp, false);\n        removeGlobalListener(window, 'touchend', onColorAreaUp, false);\n      }\n    }\n  };\n  let colorAreaInteractions = isDisabled ? {} : (0, $8t1z9$mergeProps)(_objectSpread({}, typeof PointerEvent !== 'undefined' ? {\n    onPointerDown: e => {\n      if (e.pointerType === 'mouse' && (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey)) return;\n      onColorAreaDown(e.currentTarget, e.pointerId, e.clientX, e.clientY);\n    }\n  } : {\n    onMouseDown: e => {\n      if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) return;\n      onColorAreaDown(e.currentTarget, undefined, e.clientX, e.clientY);\n    },\n    onTouchStart: e => {\n      onColorAreaDown(e.currentTarget, e.changedTouches[0].identifier, e.changedTouches[0].clientX, e.changedTouches[0].clientY);\n    }\n  }), movePropsContainer);\n  let thumbInteractions = isDisabled ? {} : (0, $8t1z9$mergeProps)(_objectSpread({}, typeof PointerEvent !== 'undefined' ? {\n    onPointerDown: e => {\n      if (e.pointerType === 'mouse' && (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey)) return;\n      onThumbDown(e.pointerId);\n    }\n  } : {\n    onMouseDown: e => {\n      if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) return;\n      onThumbDown(undefined);\n    },\n    onTouchStart: e => {\n      onThumbDown(e.changedTouches[0].identifier);\n    }\n  }), focusWithinProps, keyboardProps, movePropsThumb);\n  let {\n    focusProps: xInputFocusProps\n  } = (0, $8t1z9$useFocus)({\n    onFocus: () => {\n      setFocusedInput('x');\n    }\n  });\n  let {\n    focusProps: yInputFocusProps\n  } = (0, $8t1z9$useFocus)({\n    onFocus: () => {\n      setFocusedInput('y');\n    }\n  });\n  const onChange = e => {\n    const {\n      target: target\n    } = e;\n    setValueChangedViaInputChangeEvent(true);\n    if (target === inputXRef.current) state.setXValue(parseFloat(target.value));else if (target === inputYRef.current) state.setYValue(parseFloat(target.value));\n  };\n  let isMobile = (0, $8t1z9$isIOS)() || (0, $8t1z9$isAndroid)();\n  let value = state.getDisplayColor();\n  const getAriaValueTextForChannel = (0, $8t1z9$useCallback)(channel => {\n    const isAfterInput = valueChangedViaInputChangeEvent || valueChangedViaKeyboard;\n    return \"\".concat(isAfterInput ? stringFormatter.format('colorNameAndValue', {\n      name: value.getChannelName(channel, locale),\n      value: value.formatChannelValue(channel, locale)\n    }) : [stringFormatter.format('colorNameAndValue', {\n      name: value.getChannelName(channel, locale),\n      value: value.formatChannelValue(channel, locale)\n    }), stringFormatter.format('colorNameAndValue', {\n      name: value.getChannelName(channel === yChannel ? xChannel : yChannel, locale),\n      value: value.formatChannelValue(channel === yChannel ? xChannel : yChannel, locale)\n    }), stringFormatter.format('colorNameAndValue', {\n      name: value.getChannelName(zChannel, locale),\n      value: value.formatChannelValue(zChannel, locale)\n    })].join(', '), \", \").concat(value.getColorName(locale));\n  }, [locale, value, stringFormatter, valueChangedViaInputChangeEvent, valueChangedViaKeyboard, xChannel, yChannel, zChannel]);\n  let colorPickerLabel = stringFormatter.format('colorPicker');\n  let xInputLabellingProps = (0, $8t1z9$useLabels)(_objectSpread(_objectSpread({}, props), {}, {\n    'aria-label': ariaLabel ? stringFormatter.format('colorInputLabel', {\n      label: ariaLabel,\n      channelLabel: colorPickerLabel\n    }) : colorPickerLabel\n  }));\n  let yInputLabellingProps = (0, $8t1z9$useLabels)(_objectSpread(_objectSpread({}, props), {}, {\n    'aria-label': ariaLabel ? stringFormatter.format('colorInputLabel', {\n      label: ariaLabel,\n      channelLabel: colorPickerLabel\n    }) : colorPickerLabel\n  }));\n  let colorAreaLabellingProps = (0, $8t1z9$useLabels)(_objectSpread(_objectSpread({}, props), {}, {\n    'aria-label': ariaLabel ? \"\".concat(ariaLabel, \", \").concat(colorPickerLabel) : undefined\n  }), isMobile ? colorPickerLabel : undefined);\n  let ariaRoleDescription = stringFormatter.format('twoDimensionalSlider');\n  let {\n    visuallyHiddenProps: visuallyHiddenProps\n  } = (0, $8t1z9$useVisuallyHidden)({\n    style: {\n      opacity: '0.0001',\n      width: '100%',\n      height: '100%',\n      pointerEvents: 'none'\n    }\n  });\n  let {\n    colorAreaStyleProps: colorAreaStyleProps,\n    thumbStyleProps: thumbStyleProps\n  } = (0, $40297c24c53588e6$export$dd62420467d245ca)({\n    direction: direction,\n    state: state,\n    xChannel: xChannel,\n    yChannel: yChannel,\n    zChannel: zChannel\n  });\n  return {\n    colorAreaProps: _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, colorAreaLabellingProps), colorAreaInteractions), colorAreaStyleProps), {}, {\n      role: 'group'\n    }),\n    thumbProps: _objectSpread(_objectSpread(_objectSpread({}, thumbInteractions), thumbStyleProps), {}, {\n      role: 'presentation'\n    }),\n    xInputProps: _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, xInputLabellingProps), visuallyHiddenProps), xInputFocusProps), {}, {\n      type: 'range',\n      min: state.value.getChannelRange(xChannel).minValue,\n      max: state.value.getChannelRange(xChannel).maxValue,\n      step: xChannelStep,\n      'aria-roledescription': ariaRoleDescription,\n      'aria-valuetext': getAriaValueTextForChannel(xChannel),\n      'aria-orientation': 'horizontal',\n      'aria-describedby': props['aria-describedby'],\n      'aria-details': props['aria-details'],\n      disabled: isDisabled,\n      value: state.value.getChannelValue(xChannel),\n      name: xName,\n      tabIndex: isMobile || !focusedInput || focusedInput === 'x' ? undefined : -1,\n      /*\n      So that only a single \"2d slider\" control shows up when listing form elements for screen readers,\n      add aria-hidden=\"true\" to the unfocused control when the value has not changed via the keyboard,\n      but remove aria-hidden to reveal the input for each channel when the value has changed with the keyboard.\n      */\n      'aria-hidden': isMobile || !focusedInput || focusedInput === 'x' || valueChangedViaKeyboard ? undefined : 'true',\n      onChange: onChange\n    }),\n    yInputProps: _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, yInputLabellingProps), visuallyHiddenProps), yInputFocusProps), {}, {\n      type: 'range',\n      min: state.value.getChannelRange(yChannel).minValue,\n      max: state.value.getChannelRange(yChannel).maxValue,\n      step: yChannelStep,\n      'aria-roledescription': ariaRoleDescription,\n      'aria-valuetext': getAriaValueTextForChannel(yChannel),\n      'aria-orientation': 'vertical',\n      'aria-describedby': props['aria-describedby'],\n      'aria-details': props['aria-details'],\n      disabled: isDisabled,\n      value: state.value.getChannelValue(yChannel),\n      name: yName,\n      tabIndex: isMobile || focusedInput === 'y' ? undefined : -1,\n      /*\n      So that only a single \"2d slider\" control shows up when listing form elements for screen readers,\n      add aria-hidden=\"true\" to the unfocused input when the value has not changed via the keyboard,\n      but remove aria-hidden to reveal the input for each channel when the value has changed with the keyboard.\n      */\n      'aria-hidden': isMobile || focusedInput === 'y' || valueChangedViaKeyboard ? undefined : 'true',\n      onChange: onChange\n    })\n  };\n}\nexport { $60bd7d6e45dcddfa$export$2f92a7a615a014f6 as useColorArea };","map":{"version":3,"names":["$60bd7d6e45dcddfa$export$2f92a7a615a014f6","props","state","isDisabled","inputXRef","inputYRef","containerRef","ariaLabel","xName","yName","stringFormatter","$8t1z9$useLocalizedStringFormatter","$parcel$interopDefault","$8t1z9$intlStringsmodulejs","addGlobalListener","removeGlobalListener","$8t1z9$useGlobalListeners","direction","locale","$8t1z9$useLocale","focusedInput","setFocusedInput","$8t1z9$useState","focusInput","$8t1z9$useCallback","inputRef","arguments","length","undefined","current","$8t1z9$focusWithoutScrolling","$8t1z9$useFormReset","xValue","yValue","_ref","x","y","newColor","value","withChannelValue","channels","xChannel","yChannel","setValue","valueChangedViaKeyboard","setValueChangedViaKeyboard","valueChangedViaInputChangeEvent","setValueChangedViaInputChangeEvent","zChannel","xChannelStep","yChannelStep","currentPosition","$8t1z9$useRef","keyboardProps","$8t1z9$useKeyboard","onKeyDown","e","test","key","continuePropagation","preventDefault","setDragging","dir","incrementY","yChannelPageStep","decrementY","incrementX","xChannelPageStep","decrementX","input","moveHandler","onMoveStart","onMove","_ref2","deltaX","deltaY","pointerType","shiftKey","_containerRef_current","getThumbPosition","setColorFromPoint","width","height","getBoundingClientRect","valueChanged","deltaXValue","deltaYValue","Math","abs","onMoveEnd","isOnColorArea","moveProps","movePropsThumb","$8t1z9$useMove","focusWithinProps","$8t1z9$useFocusWithin","onFocusWithinChange","focusWithin","currentPointer","movePropsContainer","onThumbDown","id","isDragging","PointerEvent","window","onThumbUp","_e_changedTouches","_e_pointerId","pointerId","changedTouches","identifier","onColorAreaDown","colorArea","clientX","clientY","rect","onColorAreaUp","colorAreaInteractions","$8t1z9$mergeProps","_objectSpread","onPointerDown","button","altKey","ctrlKey","metaKey","currentTarget","onMouseDown","onTouchStart","thumbInteractions","focusProps","xInputFocusProps","$8t1z9$useFocus","onFocus","yInputFocusProps","onChange","target","setXValue","parseFloat","setYValue","isMobile","$8t1z9$isIOS","$8t1z9$isAndroid","getDisplayColor","getAriaValueTextForChannel","channel","isAfterInput","concat","format","name","getChannelName","formatChannelValue","join","getColorName","colorPickerLabel","xInputLabellingProps","$8t1z9$useLabels","label","channelLabel","yInputLabellingProps","colorAreaLabellingProps","ariaRoleDescription","visuallyHiddenProps","$8t1z9$useVisuallyHidden","style","opacity","pointerEvents","colorAreaStyleProps","thumbStyleProps","$40297c24c53588e6$export$dd62420467d245ca","colorAreaProps","role","thumbProps","xInputProps","type","min","getChannelRange","minValue","max","maxValue","step","disabled","getChannelValue","tabIndex","yInputProps"],"sources":["C:\\Users\\rewac\\OneDrive\\Documents\\GitHub\\scatch-store.me\\node_modules\\@react-aria\\color\\dist\\packages\\@react-aria\\color\\src\\useColorArea.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaColorAreaProps, ColorChannel} from '@react-types/color';\nimport {ColorAreaState} from '@react-stately/color';\nimport {DOMAttributes, RefObject} from '@react-types/shared';\nimport {focusWithoutScrolling, isAndroid, isIOS, mergeProps, useFormReset, useGlobalListeners, useLabels} from '@react-aria/utils';\n// @ts-ignore\nimport intlMessages from '../intl/*.json';\nimport React, {ChangeEvent, InputHTMLAttributes, useCallback, useRef, useState} from 'react';\nimport {useColorAreaGradient} from './useColorAreaGradient';\nimport {useFocus, useFocusWithin, useKeyboard, useMove} from '@react-aria/interactions';\nimport {useLocale, useLocalizedStringFormatter} from '@react-aria/i18n';\nimport {useVisuallyHidden} from '@react-aria/visually-hidden';\n\nexport interface ColorAreaAria {\n  /** Props for the color area container element. */\n  colorAreaProps: DOMAttributes,\n  /** Props for the thumb element. */\n  thumbProps: DOMAttributes,\n  /** Props for the visually hidden horizontal range input element. */\n  xInputProps: InputHTMLAttributes<HTMLInputElement>,\n  /** Props for the visually hidden vertical range input element. */\n  yInputProps: InputHTMLAttributes<HTMLInputElement>\n}\n\nexport interface AriaColorAreaOptions extends AriaColorAreaProps {\n  /** A ref to the input that represents the x axis of the color area. */\n  inputXRef: RefObject<HTMLInputElement | null>,\n  /** A ref to the input that represents the y axis of the color area. */\n  inputYRef: RefObject<HTMLInputElement | null>,\n  /** A ref to the color area containing element. */\n  containerRef: RefObject<Element | null>\n}\n\n/**\n * Provides the behavior and accessibility implementation for a color area component.\n * Color area allows users to adjust two channels of an RGB, HSL or HSB color value against a two-dimensional gradient background.\n */\nexport function useColorArea(props: AriaColorAreaOptions, state: ColorAreaState): ColorAreaAria {\n  let {\n    isDisabled,\n    inputXRef,\n    inputYRef,\n    containerRef,\n    'aria-label': ariaLabel,\n    xName,\n    yName\n  } = props;\n  let stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/color');\n\n  let {addGlobalListener, removeGlobalListener} = useGlobalListeners();\n\n  let {direction, locale} = useLocale();\n\n  let [focusedInput, setFocusedInput] = useState<'x' | 'y' | null>(null);\n  let focusInput = useCallback((inputRef:RefObject<HTMLInputElement | null> = inputXRef) => {\n    if (inputRef.current) {\n      focusWithoutScrolling(inputRef.current);\n    }\n  }, [inputXRef]);\n\n  useFormReset(inputXRef, [state.xValue, state.yValue], ([x, y]) => {\n    let newColor = state.value\n      .withChannelValue(state.channels.xChannel, x)\n      .withChannelValue(state.channels.yChannel, y);\n    state.setValue(newColor);\n  });\n\n  let [valueChangedViaKeyboard, setValueChangedViaKeyboard] = useState(false);\n  let [valueChangedViaInputChangeEvent, setValueChangedViaInputChangeEvent] = useState(false);\n  let {xChannel, yChannel, zChannel} = state.channels;\n  let xChannelStep = state.xChannelStep;\n  let yChannelStep = state.yChannelStep;\n\n  let currentPosition = useRef<{x: number, y: number} | null>(null);\n\n  let {keyboardProps} = useKeyboard({\n    onKeyDown(e) {\n      // these are the cases that useMove doesn't handle\n      if (!/^(PageUp|PageDown|Home|End)$/.test(e.key)) {\n        e.continuePropagation();\n        return;\n      }\n      // same handling as useMove, don't need to stop propagation, useKeyboard will do that for us\n      e.preventDefault();\n      // remember to set this and unset it so that onChangeEnd is fired\n      state.setDragging(true);\n      setValueChangedViaKeyboard(true);\n      let dir;\n      switch (e.key) {\n        case 'PageUp':\n          state.incrementY(state.yChannelPageStep);\n          dir = 'y';\n          break;\n        case 'PageDown':\n          state.decrementY(state.yChannelPageStep);\n          dir = 'y';\n          break;\n        case 'Home':\n          direction === 'rtl' ? state.incrementX(state.xChannelPageStep) : state.decrementX(state.xChannelPageStep);\n          dir = 'x';\n          break;\n        case 'End':\n          direction === 'rtl' ? state.decrementX(state.xChannelPageStep) : state.incrementX(state.xChannelPageStep);\n          dir = 'x';\n          break;\n      }\n      state.setDragging(false);\n      if (dir) {\n        let input = dir === 'x' ? inputXRef : inputYRef;\n        focusInput(input);\n        setFocusedInput(dir);\n      }\n    }\n  });\n\n  let moveHandler = {\n    onMoveStart() {\n      currentPosition.current = null;\n      state.setDragging(true);\n    },\n    onMove({deltaX, deltaY, pointerType, shiftKey}) {\n      let {\n        incrementX,\n        decrementX,\n        incrementY,\n        decrementY,\n        xChannelPageStep,\n        xChannelStep,\n        yChannelPageStep,\n        yChannelStep,\n        getThumbPosition,\n        setColorFromPoint\n      } = state;\n      if (currentPosition.current == null) {\n        currentPosition.current = getThumbPosition();\n      }\n      let {width, height} = containerRef.current?.getBoundingClientRect() || {width: 0, height: 0};\n      let valueChanged = deltaX !== 0 || deltaY !== 0;\n      if (pointerType === 'keyboard') {\n        let deltaXValue = shiftKey && xChannelPageStep > xChannelStep ? xChannelPageStep : xChannelStep;\n        let deltaYValue = shiftKey && yChannelPageStep > yChannelStep ? yChannelPageStep : yChannelStep;\n        if ((deltaX > 0 && direction === 'ltr') || (deltaX < 0 && direction === 'rtl')) {\n          incrementX(deltaXValue);\n        } else if ((deltaX < 0 && direction === 'ltr') || (deltaX > 0 && direction === 'rtl')) {\n          decrementX(deltaXValue);\n        } else if (deltaY > 0) {\n          decrementY(deltaYValue);\n        } else if (deltaY < 0) {\n          incrementY(deltaYValue);\n        }\n        setValueChangedViaKeyboard(valueChanged);\n        // set the focused input based on which axis has the greater delta\n        focusedInput = valueChanged && Math.abs(deltaY) > Math.abs(deltaX) ? 'y' : 'x';\n        setFocusedInput(focusedInput);\n      } else {\n        currentPosition.current.x += (direction === 'rtl' ? -1 : 1) * deltaX / width ;\n        currentPosition.current.y += deltaY / height;\n        setColorFromPoint(currentPosition.current.x, currentPosition.current.y);\n      }\n    },\n    onMoveEnd() {\n      isOnColorArea.current = false;\n      state.setDragging(false);\n      let input = focusedInput === 'x' ? inputXRef : inputYRef;\n      focusInput(input);\n    }\n  };\n  let {moveProps: movePropsThumb} = useMove(moveHandler);\n\n  let {focusWithinProps} = useFocusWithin({\n    onFocusWithinChange: (focusWithin:boolean) => {\n      if (!focusWithin) {\n        setValueChangedViaKeyboard(false);\n        setValueChangedViaInputChangeEvent(false);\n      }\n    }\n  });\n\n  let currentPointer = useRef<number | null | undefined>(undefined);\n  let isOnColorArea = useRef<boolean>(false);\n  let {moveProps: movePropsContainer} = useMove({\n    onMoveStart() {\n      if (isOnColorArea.current) {\n        moveHandler.onMoveStart();\n      }\n    },\n    onMove(e) {\n      if (isOnColorArea.current) {\n        moveHandler.onMove(e);\n      }\n    },\n    onMoveEnd() {\n      if (isOnColorArea.current) {\n        moveHandler.onMoveEnd();\n      }\n    }\n  });\n\n  let onThumbDown = (id: number | null | undefined) => {\n    if (!state.isDragging) {\n      currentPointer.current = id;\n      setValueChangedViaKeyboard(false);\n      focusInput();\n      state.setDragging(true);\n      if (typeof PointerEvent !== 'undefined') {\n        addGlobalListener(window, 'pointerup', onThumbUp, false);\n      } else {\n        addGlobalListener(window, 'mouseup', onThumbUp, false);\n        addGlobalListener(window, 'touchend', onThumbUp, false);\n      }\n    }\n  };\n\n  let onThumbUp = (e) => {\n    let id = e.pointerId ?? e.changedTouches?.[0].identifier;\n    if (id === currentPointer.current) {\n      setValueChangedViaKeyboard(false);\n      focusInput();\n      state.setDragging(false);\n      currentPointer.current = undefined;\n      isOnColorArea.current = false;\n\n      if (typeof PointerEvent !== 'undefined') {\n        removeGlobalListener(window, 'pointerup', onThumbUp, false);\n      } else {\n        removeGlobalListener(window, 'mouseup', onThumbUp, false);\n        removeGlobalListener(window, 'touchend', onThumbUp, false);\n      }\n    }\n  };\n\n  let onColorAreaDown = (colorArea: Element, id: number | null | undefined, clientX: number, clientY: number) => {\n    let rect = colorArea.getBoundingClientRect();\n    let {width, height} = rect;\n    let x = (clientX - rect.x) / width;\n    let y = (clientY - rect.y) / height;\n    if (direction === 'rtl') {\n      x = 1 - x;\n    }\n    if (x >= 0 && x <= 1 && y >= 0 && y <= 1 && !state.isDragging && currentPointer.current === undefined) {\n      isOnColorArea.current = true;\n      setValueChangedViaKeyboard(false);\n      currentPointer.current = id;\n      state.setColorFromPoint(x, y);\n\n      focusInput();\n      state.setDragging(true);\n\n      if (typeof PointerEvent !== 'undefined') {\n        addGlobalListener(window, 'pointerup', onColorAreaUp, false);\n      } else {\n        addGlobalListener(window, 'mouseup', onColorAreaUp, false);\n        addGlobalListener(window, 'touchend', onColorAreaUp, false);\n      }\n    }\n  };\n\n  let onColorAreaUp = (e) => {\n    let id = e.pointerId ?? e.changedTouches?.[0].identifier;\n    if (isOnColorArea.current && id === currentPointer.current) {\n      isOnColorArea.current = false;\n      setValueChangedViaKeyboard(false);\n      currentPointer.current = undefined;\n      state.setDragging(false);\n      focusInput();\n\n      if (typeof PointerEvent !== 'undefined') {\n        removeGlobalListener(window, 'pointerup', onColorAreaUp, false);\n      } else {\n        removeGlobalListener(window, 'mouseup', onColorAreaUp, false);\n        removeGlobalListener(window, 'touchend', onColorAreaUp, false);\n      }\n    }\n  };\n\n  let colorAreaInteractions = isDisabled ? {} : mergeProps({\n    ...(typeof PointerEvent !== 'undefined' ? {\n      onPointerDown: (e: React.PointerEvent) => {\n        if (e.pointerType === 'mouse' && (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey)) {\n          return;\n        }\n        onColorAreaDown(e.currentTarget, e.pointerId, e.clientX, e.clientY);\n      }} : {\n        onMouseDown: (e: React.MouseEvent) => {\n          if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n            return;\n          }\n          onColorAreaDown(e.currentTarget, undefined, e.clientX, e.clientY);\n        },\n        onTouchStart: (e: React.TouchEvent) => {\n          onColorAreaDown(e.currentTarget, e.changedTouches[0].identifier, e.changedTouches[0].clientX, e.changedTouches[0].clientY);\n        }\n      })\n  }, movePropsContainer);\n\n  let thumbInteractions = isDisabled ? {} : mergeProps({\n    ...(typeof PointerEvent !== 'undefined' ? {\n      onPointerDown: (e: React.PointerEvent) => {\n        if (e.pointerType === 'mouse' && (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey)) {\n          return;\n        }\n        onThumbDown(e.pointerId);\n      }} : {\n        onMouseDown: (e: React.MouseEvent) => {\n          if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n            return;\n          }\n          onThumbDown(undefined);\n        },\n        onTouchStart: (e: React.TouchEvent) => {\n          onThumbDown(e.changedTouches[0].identifier);\n        }\n      })\n  }, focusWithinProps, keyboardProps, movePropsThumb);\n\n  let {focusProps: xInputFocusProps} = useFocus({\n    onFocus: () => {\n      setFocusedInput('x');\n    }\n  });\n\n  let {focusProps: yInputFocusProps} = useFocus({\n    onFocus: () => {\n      setFocusedInput('y');\n    }\n  });\n\n  const onChange = (e: ChangeEvent<HTMLInputElement>) => {\n    const {target} = e;\n    setValueChangedViaInputChangeEvent(true);\n    if (target === inputXRef.current) {\n      state.setXValue(parseFloat(target.value));\n    } else if (target === inputYRef.current) {\n      state.setYValue(parseFloat(target.value));\n    }\n  };\n\n  let isMobile = isIOS() || isAndroid();\n\n  let value = state.getDisplayColor();\n  const getAriaValueTextForChannel = useCallback((channel:ColorChannel) => {\n    const isAfterInput = valueChangedViaInputChangeEvent || valueChangedViaKeyboard;\n    return `${\n      isAfterInput ?\n      stringFormatter.format('colorNameAndValue', {name: value.getChannelName(channel, locale), value: value.formatChannelValue(channel, locale)})\n      :\n      [\n        stringFormatter.format('colorNameAndValue', {name: value.getChannelName(channel, locale), value: value.formatChannelValue(channel, locale)}),\n        stringFormatter.format('colorNameAndValue', {name: value.getChannelName(channel === yChannel ? xChannel : yChannel, locale), value: value.formatChannelValue(channel === yChannel ? xChannel : yChannel, locale)}),\n        stringFormatter.format('colorNameAndValue', {name: value.getChannelName(zChannel, locale), value: value.formatChannelValue(zChannel, locale)})\n      ].join(', ')\n    }, ${value.getColorName(locale)}`;\n  }, [locale, value, stringFormatter, valueChangedViaInputChangeEvent, valueChangedViaKeyboard, xChannel, yChannel, zChannel]);\n\n  let colorPickerLabel = stringFormatter.format('colorPicker');\n\n  let xInputLabellingProps = useLabels({\n    ...props,\n    'aria-label': ariaLabel ? stringFormatter.format('colorInputLabel', {label: ariaLabel, channelLabel: colorPickerLabel}) : colorPickerLabel\n  });\n\n  let yInputLabellingProps = useLabels({\n    ...props,\n    'aria-label': ariaLabel ? stringFormatter.format('colorInputLabel', {label: ariaLabel, channelLabel: colorPickerLabel}) : colorPickerLabel\n  });\n\n  let colorAreaLabellingProps = useLabels(\n    {\n      ...props,\n      'aria-label': ariaLabel ? `${ariaLabel}, ${colorPickerLabel}` : undefined\n    },\n    isMobile ? colorPickerLabel : undefined\n  );\n\n  let ariaRoleDescription = stringFormatter.format('twoDimensionalSlider');\n\n  let {visuallyHiddenProps} = useVisuallyHidden({style: {\n    opacity: '0.0001',\n    width: '100%',\n    height: '100%',\n    pointerEvents: 'none'\n  }});\n\n  let {\n    colorAreaStyleProps,\n    thumbStyleProps\n  } = useColorAreaGradient({\n    direction,\n    state,\n    xChannel,\n    yChannel,\n    zChannel\n  });\n\n  return {\n    colorAreaProps: {\n      ...colorAreaLabellingProps,\n      ...colorAreaInteractions,\n      ...colorAreaStyleProps,\n      role: 'group'\n    },\n    thumbProps: {\n      ...thumbInteractions,\n      ...thumbStyleProps,\n      role: 'presentation'\n    },\n    xInputProps: {\n      ...xInputLabellingProps,\n      ...visuallyHiddenProps,\n      ...xInputFocusProps,\n      type: 'range',\n      min: state.value.getChannelRange(xChannel).minValue,\n      max: state.value.getChannelRange(xChannel).maxValue,\n      step: xChannelStep,\n      'aria-roledescription': ariaRoleDescription,\n      'aria-valuetext': getAriaValueTextForChannel(xChannel),\n      'aria-orientation': 'horizontal',\n      'aria-describedby': props['aria-describedby'],\n      'aria-details': props['aria-details'],\n      disabled: isDisabled,\n      value: state.value.getChannelValue(xChannel),\n      name: xName,\n      tabIndex: (isMobile || !focusedInput || focusedInput === 'x' ? undefined : -1),\n      /*\n        So that only a single \"2d slider\" control shows up when listing form elements for screen readers,\n        add aria-hidden=\"true\" to the unfocused control when the value has not changed via the keyboard,\n        but remove aria-hidden to reveal the input for each channel when the value has changed with the keyboard.\n      */\n      'aria-hidden': (isMobile || !focusedInput || focusedInput === 'x' || valueChangedViaKeyboard ? undefined : 'true'),\n      onChange\n    },\n    yInputProps: {\n      ...yInputLabellingProps,\n      ...visuallyHiddenProps,\n      ...yInputFocusProps,\n      type: 'range',\n      min: state.value.getChannelRange(yChannel).minValue,\n      max: state.value.getChannelRange(yChannel).maxValue,\n      step: yChannelStep,\n      'aria-roledescription': ariaRoleDescription,\n      'aria-valuetext': getAriaValueTextForChannel(yChannel),\n      'aria-orientation': 'vertical',\n      'aria-describedby': props['aria-describedby'],\n      'aria-details': props['aria-details'],\n      disabled: isDisabled,\n      value: state.value.getChannelValue(yChannel),\n      name: yName,\n      tabIndex: (isMobile || focusedInput === 'y' ? undefined : -1),\n      /*\n        So that only a single \"2d slider\" control shows up when listing form elements for screen readers,\n        add aria-hidden=\"true\" to the unfocused input when the value has not changed via the keyboard,\n        but remove aria-hidden to reveal the input for each channel when the value has changed with the keyboard.\n      */\n      'aria-hidden': (isMobile || focusedInput === 'y' || valueChangedViaKeyboard ? undefined : 'true'),\n      onChange\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */class $23b9f4fcf0fe224b$export$d68d59712b04d9d1 {\n  get childNodes() {\n    throw new Error('childNodes is not supported');\n  }\n  clone() {\n    let node = new $23b9f4fcf0fe224b$export$d68d59712b04d9d1(this.type, this.key);\n    node.value = this.value;\n    node.level = this.level;\n    node.hasChildNodes = this.hasChildNodes;\n    node.rendered = this.rendered;\n    node.textValue = this.textValue;\n    node['aria-label'] = this['aria-label'];\n    node.index = this.index;\n    node.parentKey = this.parentKey;\n    node.prevKey = this.prevKey;\n    node.nextKey = this.nextKey;\n    node.firstChildKey = this.firstChildKey;\n    node.lastChildKey = this.lastChildKey;\n    node.props = this.props;\n    node.render = this.render;\n    return node;\n  }\n  constructor(type, key) {\n    this.value = null;\n    this.level = 0;\n    this.hasChildNodes = false;\n    this.rendered = null;\n    this.textValue = '';\n    this['aria-label'] = undefined;\n    this.index = 0;\n    this.parentKey = null;\n    this.prevKey = null;\n    this.nextKey = null;\n    this.firstChildKey = null;\n    this.lastChildKey = null;\n    this.props = {};\n    this.type = type;\n    this.key = key;\n  }\n}\nclass $23b9f4fcf0fe224b$export$408d25a4e12db025 {\n  get size() {\n    return this.keyMap.size;\n  }\n  getKeys() {\n    return this.keyMap.keys();\n  }\n  *[Symbol.iterator]() {\n    let node = this.firstKey != null ? this.keyMap.get(this.firstKey) : undefined;\n    while (node) {\n      yield node;\n      node = node.nextKey != null ? this.keyMap.get(node.nextKey) : undefined;\n    }\n  }\n  getChildren(key) {\n    let keyMap = this.keyMap;\n    return {\n      *[Symbol.iterator]() {\n        let parent = keyMap.get(key);\n        let node = (parent === null || parent === void 0 ? void 0 : parent.firstChildKey) != null ? keyMap.get(parent.firstChildKey) : null;\n        while (node) {\n          yield node;\n          node = node.nextKey != null ? keyMap.get(node.nextKey) : undefined;\n        }\n      }\n    };\n  }\n  getKeyBefore(key) {\n    let node = this.keyMap.get(key);\n    if (!node) return null;\n    if (node.prevKey != null) {\n      node = this.keyMap.get(node.prevKey);\n      while (node && node.type !== 'item' && node.lastChildKey != null) node = this.keyMap.get(node.lastChildKey);\n      var _node_key;\n      return (_node_key = node === null || node === void 0 ? void 0 : node.key) !== null && _node_key !== void 0 ? _node_key : null;\n    }\n    return node.parentKey;\n  }\n  getKeyAfter(key) {\n    let node = this.keyMap.get(key);\n    if (!node) return null;\n    if (node.type !== 'item' && node.firstChildKey != null) return node.firstChildKey;\n    while (node) {\n      if (node.nextKey != null) return node.nextKey;\n      if (node.parentKey != null) node = this.keyMap.get(node.parentKey);else return null;\n    }\n    return null;\n  }\n  getFirstKey() {\n    return this.firstKey;\n  }\n  getLastKey() {\n    let node = this.lastKey != null ? this.keyMap.get(this.lastKey) : null;\n    while ((node === null || node === void 0 ? void 0 : node.lastChildKey) != null) node = this.keyMap.get(node.lastChildKey);\n    var _node_key;\n    return (_node_key = node === null || node === void 0 ? void 0 : node.key) !== null && _node_key !== void 0 ? _node_key : null;\n  }\n  getItem(key) {\n    var _this_keyMap_get;\n    return (_this_keyMap_get = this.keyMap.get(key)) !== null && _this_keyMap_get !== void 0 ? _this_keyMap_get : null;\n  }\n  at() {\n    throw new Error('Not implemented');\n  }\n  clone() {\n    // We need to clone using this.constructor so that subclasses have the right prototype.\n    // TypeScript isn't happy about this yet.\n    // https://github.com/microsoft/TypeScript/issues/3841\n    let Constructor = this.constructor;\n    let collection = new Constructor();\n    collection.keyMap = new Map(this.keyMap);\n    collection.firstKey = this.firstKey;\n    collection.lastKey = this.lastKey;\n    return collection;\n  }\n  addNode(node) {\n    if (this.frozen) throw new Error('Cannot add a node to a frozen collection');\n    this.keyMap.set(node.key, node);\n  }\n  removeNode(key) {\n    if (this.frozen) throw new Error('Cannot remove a node to a frozen collection');\n    this.keyMap.delete(key);\n  }\n  commit(firstKey, lastKey) {\n    let isSSR = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (this.frozen) throw new Error('Cannot commit a frozen collection');\n    this.firstKey = firstKey;\n    this.lastKey = lastKey;\n    this.frozen = !isSSR;\n  }\n  // TODO: this is pretty specific to menu, will need to check if it is generic enough\n  // Will need to handle varying levels I assume but will revisit after I get searchable menu working for base menu\n  // TODO: an alternative is to simply walk the collection and add all item nodes that match the filter and any sections/separators we encounter\n  // to an array, then walk that new array and fix all the next/Prev keys while adding them to the new collection\n  filter(filterFn) {\n    let newCollection = new $23b9f4fcf0fe224b$export$408d25a4e12db025();\n    // This tracks the absolute last node we've visited in the collection when filtering, used for setting up the filteredCollection's lastKey and\n    // for updating the next/prevKey for every non-filtered node.\n    let lastNode = null;\n    for (let node of this) {\n      if (node.type === 'section' && node.hasChildNodes) {\n        let clonedSection = node.clone();\n        let lastChildInSection = null;\n        for (let child of this.getChildren(node.key)) if (filterFn(child.textValue) || child.type === 'header') {\n          let clonedChild = child.clone();\n          // eslint-disable-next-line max-depth\n          if (lastChildInSection == null) clonedSection.firstChildKey = clonedChild.key;\n          // eslint-disable-next-line max-depth\n          if (newCollection.firstKey == null) newCollection.firstKey = clonedSection.key;\n          // eslint-disable-next-line max-depth\n          if (lastChildInSection && lastChildInSection.parentKey === clonedChild.parentKey) {\n            lastChildInSection.nextKey = clonedChild.key;\n            clonedChild.prevKey = lastChildInSection.key;\n          } else clonedChild.prevKey = null;\n          clonedChild.nextKey = null;\n          newCollection.addNode(clonedChild);\n          lastChildInSection = clonedChild;\n        }\n        // Add newly filtered section to collection if it has any valid child nodes, otherwise remove it and its header if any\n        if (lastChildInSection) {\n          if (lastChildInSection.type !== 'header') {\n            clonedSection.lastChildKey = lastChildInSection.key;\n            // If the old prev section was filtered out, will need to attach to whatever came before\n            // eslint-disable-next-line max-depth\n            if (lastNode == null) clonedSection.prevKey = null;else if (lastNode.type === 'section' || lastNode.type === 'separator') {\n              lastNode.nextKey = clonedSection.key;\n              clonedSection.prevKey = lastNode.key;\n            }\n            clonedSection.nextKey = null;\n            lastNode = clonedSection;\n            newCollection.addNode(clonedSection);\n          } else {\n            if (newCollection.firstKey === clonedSection.key) newCollection.firstKey = null;\n            newCollection.removeNode(lastChildInSection.key);\n          }\n        }\n      } else if (node.type === 'separator') {\n        // will need to check if previous section key exists, if it does then we add the separator to the collection.\n        // After the full collection is created we'll need to remove it it is the last node in the section (aka no following section after the separator)\n        let clonedSeparator = node.clone();\n        clonedSeparator.nextKey = null;\n        if ((lastNode === null || lastNode === void 0 ? void 0 : lastNode.type) === 'section') {\n          lastNode.nextKey = clonedSeparator.key;\n          clonedSeparator.prevKey = lastNode.key;\n          lastNode = clonedSeparator;\n          newCollection.addNode(clonedSeparator);\n        }\n      } else if (filterFn(node.textValue)) {\n        let clonedNode = node.clone();\n        if (newCollection.firstKey == null) newCollection.firstKey = clonedNode.key;\n        if (lastNode != null && lastNode.type !== 'section' && lastNode.type !== 'separator' && lastNode.parentKey === clonedNode.parentKey) {\n          lastNode.nextKey = clonedNode.key;\n          clonedNode.prevKey = lastNode.key;\n        } else clonedNode.prevKey = null;\n        clonedNode.nextKey = null;\n        newCollection.addNode(clonedNode);\n        lastNode = clonedNode;\n      }\n    }\n    if ((lastNode === null || lastNode === void 0 ? void 0 : lastNode.type) === 'separator' && lastNode.nextKey === null) {\n      let lastSection;\n      if (lastNode.prevKey != null) {\n        lastSection = newCollection.getItem(lastNode.prevKey);\n        lastSection.nextKey = null;\n      }\n      newCollection.removeNode(lastNode.key);\n      lastNode = lastSection;\n    }\n    newCollection.lastKey = (lastNode === null || lastNode === void 0 ? void 0 : lastNode.key) || null;\n    return newCollection;\n  }\n  constructor() {\n    this.keyMap = new Map();\n    this.firstKey = null;\n    this.lastKey = null;\n    this.frozen = false;\n  }\n}\nexport { $23b9f4fcf0fe224b$export$d68d59712b04d9d1 as CollectionNode, $23b9f4fcf0fe224b$export$408d25a4e12db025 as BaseCollection };","map":{"version":3,"names":["$23b9f4fcf0fe224b$export$d68d59712b04d9d1","childNodes","Error","clone","node","type","key","value","level","hasChildNodes","rendered","textValue","index","parentKey","prevKey","nextKey","firstChildKey","lastChildKey","props","render","constructor","undefined","$23b9f4fcf0fe224b$export$408d25a4e12db025","size","keyMap","getKeys","keys","Symbol","iterator","firstKey","get","getChildren","parent","getKeyBefore","_node_key","getKeyAfter","getFirstKey","getLastKey","lastKey","getItem","_this_keyMap_get","at","Constructor","collection","Map","addNode","frozen","set","removeNode","delete","commit","isSSR","arguments","length","filter","filterFn","newCollection","lastNode","clonedSection","lastChildInSection","child","clonedChild","clonedSeparator","clonedNode","lastSection"],"sources":["C:\\Users\\rewac\\OneDrive\\Documents\\GitHub\\scatch-store.me\\node_modules\\@react-aria\\collections\\dist\\packages\\@react-aria\\collections\\src\\BaseCollection.ts"],"sourcesContent":["/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection as ICollection, Key, Node} from '@react-types/shared';\nimport {ReactElement, ReactNode} from 'react';\n\nexport type Mutable<T> = {\n  -readonly[P in keyof T]: T[P]\n}\n\n/** An immutable object representing a Node in a Collection. */\nexport class CollectionNode<T> implements Node<T> {\n  readonly type: string;\n  readonly key: Key;\n  readonly value: T | null = null;\n  readonly level: number = 0;\n  readonly hasChildNodes: boolean = false;\n  readonly rendered: ReactNode = null;\n  readonly textValue: string = '';\n  readonly 'aria-label'?: string = undefined;\n  readonly index: number = 0;\n  readonly parentKey: Key | null = null;\n  readonly prevKey: Key | null = null;\n  readonly nextKey: Key | null = null;\n  readonly firstChildKey: Key | null = null;\n  readonly lastChildKey: Key | null = null;\n  readonly props: any = {};\n  readonly render?: (node: Node<any>) => ReactElement;\n\n  constructor(type: string, key: Key) {\n    this.type = type;\n    this.key = key;\n  }\n\n  get childNodes(): Iterable<Node<T>> {\n    throw new Error('childNodes is not supported');\n  }\n\n  clone(): CollectionNode<T> {\n    let node: Mutable<CollectionNode<T>> = new CollectionNode(this.type, this.key);\n    node.value = this.value;\n    node.level = this.level;\n    node.hasChildNodes = this.hasChildNodes;\n    node.rendered = this.rendered;\n    node.textValue = this.textValue;\n    node['aria-label'] = this['aria-label'];\n    node.index = this.index;\n    node.parentKey = this.parentKey;\n    node.prevKey = this.prevKey;\n    node.nextKey = this.nextKey;\n    node.firstChildKey = this.firstChildKey;\n    node.lastChildKey = this.lastChildKey;\n    node.props = this.props;\n    node.render = this.render;\n    return node;\n  }\n}\n\n/**\n * An immutable Collection implementation. Updates are only allowed\n * when it is not marked as frozen. This can be subclassed to implement\n * custom collection behaviors.\n */\nexport class BaseCollection<T> implements ICollection<Node<T>> {\n  private keyMap: Map<Key, CollectionNode<T>> = new Map();\n  private firstKey: Key | null = null;\n  private lastKey: Key | null = null;\n  private frozen = false;\n\n  get size() {\n    return this.keyMap.size;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  *[Symbol.iterator]() {\n    let node: Node<T> | undefined = this.firstKey != null ? this.keyMap.get(this.firstKey) : undefined;\n    while (node) {\n      yield node;\n      node = node.nextKey != null ? this.keyMap.get(node.nextKey) : undefined;\n    }\n  }\n\n  getChildren(key: Key): Iterable<Node<T>> {\n    let keyMap = this.keyMap;\n    return {\n      *[Symbol.iterator]() {\n        let parent = keyMap.get(key);\n        let node = parent?.firstChildKey != null ? keyMap.get(parent.firstChildKey) : null;\n        while (node) {\n          yield node as Node<T>;\n          node = node.nextKey != null ? keyMap.get(node.nextKey) : undefined;\n        }\n      }\n    };\n  }\n\n  getKeyBefore(key: Key) {\n    let node = this.keyMap.get(key);\n    if (!node) {\n      return null;\n    }\n\n    if (node.prevKey != null) {\n      node = this.keyMap.get(node.prevKey);\n\n      while (node && node.type !== 'item' && node.lastChildKey != null) {\n        node = this.keyMap.get(node.lastChildKey);\n      }\n\n      return node?.key ?? null;\n    }\n\n    return node.parentKey;\n  }\n\n  getKeyAfter(key: Key) {\n    let node = this.keyMap.get(key);\n    if (!node) {\n      return null;\n    }\n\n    if (node.type !== 'item' && node.firstChildKey != null) {\n      return node.firstChildKey;\n    }\n\n    while (node) {\n      if (node.nextKey != null) {\n        return node.nextKey;\n      }\n\n      if (node.parentKey != null) {\n        node = this.keyMap.get(node.parentKey);\n      } else {\n        return null;\n      }\n    }\n\n    return null;\n  }\n\n  getFirstKey() {\n    return this.firstKey;\n  }\n\n  getLastKey() {\n    let node = this.lastKey != null ? this.keyMap.get(this.lastKey) : null;\n    while (node?.lastChildKey != null) {\n      node = this.keyMap.get(node.lastChildKey);\n    }\n\n    return node?.key ?? null;\n  }\n\n  getItem(key: Key): Node<T> | null {\n    return this.keyMap.get(key) ?? null;\n  }\n\n  at(): Node<T> {\n    throw new Error('Not implemented');\n  }\n\n  clone(): this {\n    // We need to clone using this.constructor so that subclasses have the right prototype.\n    // TypeScript isn't happy about this yet.\n    // https://github.com/microsoft/TypeScript/issues/3841\n    let Constructor: any = this.constructor;\n    let collection: this = new Constructor();\n    collection.keyMap = new Map(this.keyMap);\n    collection.firstKey = this.firstKey;\n    collection.lastKey = this.lastKey;\n    return collection;\n  }\n\n  addNode(node: CollectionNode<T>) {\n    if (this.frozen) {\n      throw new Error('Cannot add a node to a frozen collection');\n    }\n\n    this.keyMap.set(node.key, node);\n  }\n\n  removeNode(key: Key) {\n    if (this.frozen) {\n      throw new Error('Cannot remove a node to a frozen collection');\n    }\n\n    this.keyMap.delete(key);\n  }\n\n  commit(firstKey: Key | null, lastKey: Key | null, isSSR = false) {\n    if (this.frozen) {\n      throw new Error('Cannot commit a frozen collection');\n    }\n\n    this.firstKey = firstKey;\n    this.lastKey = lastKey;\n    this.frozen = !isSSR;\n  }\n\n  // TODO: this is pretty specific to menu, will need to check if it is generic enough\n  // Will need to handle varying levels I assume but will revisit after I get searchable menu working for base menu\n  // TODO: an alternative is to simply walk the collection and add all item nodes that match the filter and any sections/separators we encounter\n  // to an array, then walk that new array and fix all the next/Prev keys while adding them to the new collection\n  filter(filterFn: (nodeValue: string) => boolean): BaseCollection<T> {\n    let newCollection = new BaseCollection<T>();\n    // This tracks the absolute last node we've visited in the collection when filtering, used for setting up the filteredCollection's lastKey and\n    // for updating the next/prevKey for every non-filtered node.\n    let lastNode: Mutable<CollectionNode<T>> | null = null;\n\n    for (let node of this) {\n      if (node.type === 'section' && node.hasChildNodes) {\n        let clonedSection: Mutable<CollectionNode<T>> = (node as CollectionNode<T>).clone();\n        let lastChildInSection: Mutable<CollectionNode<T>> | null = null;\n        for (let child of this.getChildren(node.key)) {\n          if (filterFn(child.textValue) || child.type === 'header') {\n            let clonedChild: Mutable<CollectionNode<T>> = (child as CollectionNode<T>).clone();\n            // eslint-disable-next-line max-depth\n            if (lastChildInSection == null) {\n              clonedSection.firstChildKey = clonedChild.key;\n            }\n\n            // eslint-disable-next-line max-depth\n            if (newCollection.firstKey == null) {\n              newCollection.firstKey = clonedSection.key;\n            }\n\n            // eslint-disable-next-line max-depth\n            if (lastChildInSection && lastChildInSection.parentKey === clonedChild.parentKey) {\n              lastChildInSection.nextKey = clonedChild.key;\n              clonedChild.prevKey = lastChildInSection.key;\n            } else {\n              clonedChild.prevKey = null;\n            }\n\n            clonedChild.nextKey = null;\n            newCollection.addNode(clonedChild);\n            lastChildInSection = clonedChild;\n          }\n        }\n\n        // Add newly filtered section to collection if it has any valid child nodes, otherwise remove it and its header if any\n        if (lastChildInSection) {\n          if (lastChildInSection.type !== 'header') {\n            clonedSection.lastChildKey = lastChildInSection.key;\n\n            // If the old prev section was filtered out, will need to attach to whatever came before\n            // eslint-disable-next-line max-depth\n            if (lastNode == null) {\n              clonedSection.prevKey = null;\n            } else if (lastNode.type === 'section' || lastNode.type === 'separator') {\n              lastNode.nextKey = clonedSection.key;\n              clonedSection.prevKey = lastNode.key;\n            }\n            clonedSection.nextKey = null;\n            lastNode = clonedSection;\n            newCollection.addNode(clonedSection);\n          } else {\n            if (newCollection.firstKey === clonedSection.key) {\n              newCollection.firstKey = null;\n            }\n            newCollection.removeNode(lastChildInSection.key);\n          }\n        }\n      } else if (node.type === 'separator') {\n        // will need to check if previous section key exists, if it does then we add the separator to the collection.\n        // After the full collection is created we'll need to remove it it is the last node in the section (aka no following section after the separator)\n        let clonedSeparator: Mutable<CollectionNode<T>> = (node as CollectionNode<T>).clone();\n        clonedSeparator.nextKey = null;\n        if (lastNode?.type === 'section') {\n          lastNode.nextKey = clonedSeparator.key;\n          clonedSeparator.prevKey = lastNode.key;\n          lastNode = clonedSeparator;\n          newCollection.addNode(clonedSeparator);\n        }\n      } else if (filterFn(node.textValue)) {\n        let clonedNode: Mutable<CollectionNode<T>> = (node as CollectionNode<T>).clone();\n        if (newCollection.firstKey == null) {\n          newCollection.firstKey = clonedNode.key;\n        }\n\n        if (lastNode != null && (lastNode.type !== 'section' && lastNode.type !== 'separator') && lastNode.parentKey === clonedNode.parentKey) {\n          lastNode.nextKey = clonedNode.key;\n          clonedNode.prevKey = lastNode.key;\n        } else {\n          clonedNode.prevKey = null;\n        }\n\n        clonedNode.nextKey = null;\n        newCollection.addNode(clonedNode);\n        lastNode = clonedNode;\n      }\n    }\n\n    if (lastNode?.type === 'separator' && lastNode.nextKey === null) {\n      let lastSection;\n      if (lastNode.prevKey != null) {\n        lastSection = newCollection.getItem(lastNode.prevKey) as Mutable<CollectionNode<T>>;\n        lastSection.nextKey = null;\n      }\n      newCollection.removeNode(lastNode.key);\n      lastNode = lastSection;\n    }\n\n    newCollection.lastKey = lastNode?.key || null;\n\n    return newCollection;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
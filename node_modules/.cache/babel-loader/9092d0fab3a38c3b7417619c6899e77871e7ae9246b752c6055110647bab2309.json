{"ast":null,"code":"import _objectSpread from \"C:/Users/rewac/OneDrive/Documents/GitHub/scatch-store.me/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { getChildNodes as $img26$getChildNodes } from \"@react-stately/collections\";\nimport { Rect as $img26$Rect, Size as $img26$Size, LayoutInfo as $img26$LayoutInfo, Point as $img26$Point, Layout as $img26$Layout } from \"@react-stately/virtualizer\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nconst $61ef60fc9b1041f4$var$DEFAULT_HEIGHT = 48;\nclass $61ef60fc9b1041f4$export$cacbb3924155d68e extends (0, $img26$Layout) {\n  // Backward compatibility for subclassing.\n  get collection() {\n    return this.virtualizer.collection;\n  }\n  getLayoutInfo(key) {\n    var _this_layoutNodes_get;\n    this.ensureLayoutInfo(key);\n    return ((_this_layoutNodes_get = this.layoutNodes.get(key)) === null || _this_layoutNodes_get === void 0 ? void 0 : _this_layoutNodes_get.layoutInfo) || null;\n  }\n  getVisibleLayoutInfos(rect) {\n    // Adjust rect to keep number of visible rows consistent.\n    // (only if height > 1 for getDropTargetFromPoint)\n    if (rect.height > 1) {\n      var _this_rowHeight, _ref;\n      let rowHeight = (_ref = (_this_rowHeight = this.rowHeight) !== null && _this_rowHeight !== void 0 ? _this_rowHeight : this.estimatedRowHeight) !== null && _ref !== void 0 ? _ref : $61ef60fc9b1041f4$var$DEFAULT_HEIGHT;\n      rect.y = Math.floor(rect.y / rowHeight) * rowHeight;\n      rect.height = Math.ceil(rect.height / rowHeight) * rowHeight;\n    }\n    // If layout hasn't yet been done for the requested rect, union the\n    // new rect with the existing valid rect, and recompute.\n    this.layoutIfNeeded(rect);\n    let res = [];\n    let addNodes = nodes => {\n      for (let node of nodes) if (this.isVisible(node, rect)) {\n        res.push(node.layoutInfo);\n        if (node.children) addNodes(node.children);\n      }\n    };\n    addNodes(this.rootNodes);\n    return res;\n  }\n  layoutIfNeeded(rect) {\n    if (!this.lastCollection) return;\n    if (!this.requestedRect.containsRect(rect)) {\n      this.requestedRect = this.requestedRect.union(rect);\n      this.rootNodes = this.buildCollection();\n    }\n    // Ensure all of the persisted keys are available.\n    for (let key of this.virtualizer.persistedKeys) {\n      if (this.ensureLayoutInfo(key)) return;\n    }\n  }\n  ensureLayoutInfo(key) {\n    // If the layout info wasn't found, it might be outside the bounds of the area that we've\n    // computed layout for so far. This can happen when accessing a random key, e.g pressing Home/End.\n    // Compute the full layout and try again.\n    if (!this.layoutNodes.has(key) && this.requestedRect.area < this.contentSize.area && this.lastCollection) {\n      this.requestedRect = new (0, $img26$Rect)(0, 0, Infinity, Infinity);\n      this.rootNodes = this.buildCollection();\n      this.requestedRect = new (0, $img26$Rect)(0, 0, this.contentSize.width, this.contentSize.height);\n      return true;\n    }\n    return false;\n  }\n  isVisible(node, rect) {\n    return node.layoutInfo.rect.intersects(rect) || node.layoutInfo.isSticky || node.layoutInfo.type === 'header' || this.virtualizer.isPersistedKey(node.layoutInfo.key);\n  }\n  shouldInvalidateEverything(invalidationContext) {\n    // Invalidate cache if the size of the collection changed.\n    // In this case, we need to recalculate the entire layout.\n    return invalidationContext.sizeChanged || false;\n  }\n  update(invalidationContext) {\n    let collection = this.virtualizer.collection;\n    // Reset valid rect if we will have to invalidate everything.\n    // Otherwise we can reuse cached layout infos outside the current visible rect.\n    this.invalidateEverything = this.shouldInvalidateEverything(invalidationContext);\n    if (this.invalidateEverything) {\n      this.requestedRect = this.virtualizer.visibleRect.copy();\n      this.layoutNodes.clear();\n    }\n    this.rootNodes = this.buildCollection();\n    // Remove deleted layout nodes\n    if (this.lastCollection && collection !== this.lastCollection) {\n      for (let key of this.lastCollection.getKeys()) if (!collection.getItem(key)) {\n        let layoutNode = this.layoutNodes.get(key);\n        if (layoutNode) this.layoutNodes.delete(key);\n      }\n    }\n    this.lastWidth = this.virtualizer.visibleRect.width;\n    this.lastCollection = collection;\n    this.invalidateEverything = false;\n    this.validRect = this.requestedRect.copy();\n  }\n  buildCollection() {\n    let y = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let collection = this.virtualizer.collection;\n    let skipped = 0;\n    let nodes = [];\n    for (let node of collection) {\n      var _this_rowHeight, _ref;\n      let rowHeight = (_ref = (_this_rowHeight = this.rowHeight) !== null && _this_rowHeight !== void 0 ? _this_rowHeight : this.estimatedRowHeight) !== null && _ref !== void 0 ? _ref : $61ef60fc9b1041f4$var$DEFAULT_HEIGHT;\n      // Skip rows before the valid rectangle unless they are already cached.\n      if (node.type === 'item' && y + rowHeight < this.requestedRect.y && !this.isValid(node, y)) {\n        y += rowHeight;\n        skipped++;\n        continue;\n      }\n      let layoutNode = this.buildChild(node, 0, y, null);\n      y = layoutNode.layoutInfo.rect.maxY;\n      nodes.push(layoutNode);\n      if (node.type === 'item' && y > this.requestedRect.maxY) {\n        y += (collection.size - (nodes.length + skipped)) * rowHeight;\n        break;\n      }\n    }\n    this.contentSize = new (0, $img26$Size)(this.virtualizer.visibleRect.width, y);\n    return nodes;\n  }\n  isValid(node, y) {\n    let cached = this.layoutNodes.get(node.key);\n    return !this.invalidateEverything && cached && cached.node === node && y === cached.layoutInfo.rect.y && cached.layoutInfo.rect.intersects(this.validRect) && cached.validRect.containsRect(cached.layoutInfo.rect.intersection(this.requestedRect));\n  }\n  buildChild(node, x, y, parentKey) {\n    if (this.isValid(node, y)) return this.layoutNodes.get(node.key);\n    let layoutNode = this.buildNode(node, x, y);\n    layoutNode.layoutInfo.parentKey = parentKey !== null && parentKey !== void 0 ? parentKey : null;\n    this.layoutNodes.set(node.key, layoutNode);\n    return layoutNode;\n  }\n  buildNode(node, x, y) {\n    switch (node.type) {\n      case 'section':\n        return this.buildSection(node, x, y);\n      case 'item':\n        return this.buildItem(node, x, y);\n      case 'header':\n        return this.buildSectionHeader(node, x, y);\n      case 'loader':\n        return this.buildLoader(node, x, y);\n      default:\n        throw new Error('Unsupported node type: ' + node.type);\n    }\n  }\n  buildLoader(node, x, y) {\n    let rect = new (0, $img26$Rect)(x, y, 0, 0);\n    let layoutInfo = new (0, $img26$LayoutInfo)('loader', node.key, rect);\n    rect.width = this.virtualizer.contentSize.width;\n    rect.height = this.loaderHeight || this.rowHeight || this.estimatedRowHeight || $61ef60fc9b1041f4$var$DEFAULT_HEIGHT;\n    return {\n      layoutInfo: layoutInfo,\n      validRect: rect.intersection(this.requestedRect)\n    };\n  }\n  buildSection(node, x, y) {\n    let collection = this.virtualizer.collection;\n    let width = this.virtualizer.visibleRect.width;\n    let rect = new (0, $img26$Rect)(0, y, width, 0);\n    let layoutInfo = new (0, $img26$LayoutInfo)(node.type, node.key, rect);\n    let startY = y;\n    let skipped = 0;\n    let children = [];\n    for (let child of (0, $img26$getChildNodes)(node, collection)) {\n      var _this_rowHeight, _ref;\n      let rowHeight = (_ref = (_this_rowHeight = this.rowHeight) !== null && _this_rowHeight !== void 0 ? _this_rowHeight : this.estimatedRowHeight) !== null && _ref !== void 0 ? _ref : $61ef60fc9b1041f4$var$DEFAULT_HEIGHT;\n      // Skip rows before the valid rectangle unless they are already cached.\n      if (y + rowHeight < this.requestedRect.y && !this.isValid(node, y)) {\n        y += rowHeight;\n        skipped++;\n        continue;\n      }\n      let layoutNode = this.buildChild(child, x, y, layoutInfo.key);\n      y = layoutNode.layoutInfo.rect.maxY;\n      children.push(layoutNode);\n      if (y > this.requestedRect.maxY) {\n        // Estimate the remaining height for rows that we don't need to layout right now.\n        y += ([...(0, $img26$getChildNodes)(node, collection)].length - (children.length + skipped)) * rowHeight;\n        break;\n      }\n    }\n    rect.height = y - startY;\n    return {\n      layoutInfo: layoutInfo,\n      children: children,\n      validRect: layoutInfo.rect.intersection(this.requestedRect),\n      node: node\n    };\n  }\n  buildSectionHeader(node, x, y) {\n    let width = this.virtualizer.visibleRect.width;\n    let rectHeight = this.headingHeight;\n    let isEstimated = false;\n    // If no explicit height is available, use an estimated height.\n    if (rectHeight == null) {\n      // If a previous version of this layout info exists, reuse its height.\n      // Mark as estimated if the size of the overall virtualizer changed,\n      // or the content of the item changed.\n      let previousLayoutNode = this.layoutNodes.get(node.key);\n      let previousLayoutInfo = previousLayoutNode === null || previousLayoutNode === void 0 ? void 0 : previousLayoutNode.layoutInfo;\n      if (previousLayoutInfo) {\n        let curNode = this.virtualizer.collection.getItem(node.key);\n        let lastNode = this.lastCollection ? this.lastCollection.getItem(node.key) : null;\n        rectHeight = previousLayoutInfo.rect.height;\n        isEstimated = width !== this.lastWidth || curNode !== lastNode || previousLayoutInfo.estimatedSize;\n      } else {\n        rectHeight = node.rendered ? this.estimatedHeadingHeight : 0;\n        isEstimated = true;\n      }\n    }\n    if (rectHeight == null) rectHeight = $61ef60fc9b1041f4$var$DEFAULT_HEIGHT;\n    let headerRect = new (0, $img26$Rect)(0, y, width, rectHeight);\n    let header = new (0, $img26$LayoutInfo)('header', node.key, headerRect);\n    header.estimatedSize = isEstimated;\n    return {\n      layoutInfo: header,\n      children: [],\n      validRect: header.rect.intersection(this.requestedRect),\n      node: node\n    };\n  }\n  buildItem(node, x, y) {\n    let width = this.virtualizer.visibleRect.width;\n    let rectHeight = this.rowHeight;\n    let isEstimated = false;\n    // If no explicit height is available, use an estimated height.\n    if (rectHeight == null) {\n      // If a previous version of this layout info exists, reuse its height.\n      // Mark as estimated if the size of the overall virtualizer changed,\n      // or the content of the item changed.\n      let previousLayoutNode = this.layoutNodes.get(node.key);\n      if (previousLayoutNode) {\n        rectHeight = previousLayoutNode.layoutInfo.rect.height;\n        isEstimated = width !== this.lastWidth || node !== previousLayoutNode.node || previousLayoutNode.layoutInfo.estimatedSize;\n      } else {\n        rectHeight = this.estimatedRowHeight;\n        isEstimated = true;\n      }\n    }\n    if (rectHeight == null) rectHeight = $61ef60fc9b1041f4$var$DEFAULT_HEIGHT;\n    let rect = new (0, $img26$Rect)(x, y, width - x, rectHeight);\n    let layoutInfo = new (0, $img26$LayoutInfo)(node.type, node.key, rect);\n    layoutInfo.estimatedSize = isEstimated;\n    return {\n      layoutInfo: layoutInfo,\n      children: [],\n      validRect: layoutInfo.rect,\n      node: node\n    };\n  }\n  updateItemSize(key, size) {\n    let layoutNode = this.layoutNodes.get(key);\n    // If no layoutInfo, item has been deleted/removed.\n    if (!layoutNode) return false;\n    let collection = this.virtualizer.collection;\n    let layoutInfo = layoutNode.layoutInfo;\n    layoutInfo.estimatedSize = false;\n    if (layoutInfo.rect.height !== size.height) {\n      // Copy layout info rather than mutating so that later caches are invalidated.\n      let newLayoutInfo = layoutInfo.copy();\n      newLayoutInfo.rect.height = size.height;\n      layoutNode.layoutInfo = newLayoutInfo;\n      // Items after this layoutInfo will need to be repositioned to account for the new height.\n      // Adjust the validRect so that only items above remain valid.\n      this.validRect.height = Math.min(this.validRect.height, layoutInfo.rect.y - this.validRect.y);\n      // The requestedRect also needs to be adjusted to account for the height difference.\n      this.requestedRect.height += newLayoutInfo.rect.height - layoutInfo.rect.height;\n      // Invalidate layout for this layout node and all parents\n      this.updateLayoutNode(key, layoutInfo, newLayoutInfo);\n      let node = layoutInfo.parentKey != null ? collection.getItem(layoutInfo.parentKey) : null;\n      while (node) {\n        this.updateLayoutNode(node.key, layoutInfo, newLayoutInfo);\n        node = node.parentKey != null ? collection.getItem(node.parentKey) : null;\n      }\n      return true;\n    }\n    return false;\n  }\n  updateLayoutNode(key, oldLayoutInfo, newLayoutInfo) {\n    let n = this.layoutNodes.get(key);\n    if (n) {\n      // Invalidate by intersecting the validRect of this node with the overall validRect.\n      n.validRect = n.validRect.intersection(this.validRect);\n      // Replace layout info in LayoutNode\n      if (n.layoutInfo === oldLayoutInfo) n.layoutInfo = newLayoutInfo;\n    }\n  }\n  getContentSize() {\n    return this.contentSize;\n  }\n  getDropTargetFromPoint(x, y, isValidDropTarget) {\n    x += this.virtualizer.visibleRect.x;\n    y += this.virtualizer.visibleRect.y;\n    let key = this.virtualizer.keyAtPoint(new (0, $img26$Point)(x, y));\n    if (key == null || this.virtualizer.collection.size === 0) return {\n      type: 'root'\n    };\n    let layoutInfo = this.getLayoutInfo(key);\n    if (!layoutInfo) return null;\n    let rect = layoutInfo.rect;\n    let target = {\n      type: 'item',\n      key: layoutInfo.key,\n      dropPosition: 'on'\n    };\n    // If dropping on the item isn't accepted, try the target before or after depending on the y position.\n    // Otherwise, if dropping on the item is accepted, still try the before/after positions if within 10px\n    // of the top or bottom of the item.\n    if (!isValidDropTarget(target)) {\n      if (y <= rect.y + rect.height / 2 && isValidDropTarget(_objectSpread(_objectSpread({}, target), {}, {\n        dropPosition: 'before'\n      }))) target.dropPosition = 'before';else if (isValidDropTarget(_objectSpread(_objectSpread({}, target), {}, {\n        dropPosition: 'after'\n      }))) target.dropPosition = 'after';\n    } else if (y <= rect.y + 10 && isValidDropTarget(_objectSpread(_objectSpread({}, target), {}, {\n      dropPosition: 'before'\n    }))) target.dropPosition = 'before';else if (y >= rect.maxY - 10 && isValidDropTarget(_objectSpread(_objectSpread({}, target), {}, {\n      dropPosition: 'after'\n    }))) target.dropPosition = 'after';\n    return target;\n  }\n  getDropTargetLayoutInfo(target) {\n    let layoutInfo = this.getLayoutInfo(target.key);\n    let rect;\n    if (target.dropPosition === 'before') rect = new (0, $img26$Rect)(layoutInfo.rect.x, layoutInfo.rect.y - this.dropIndicatorThickness / 2, layoutInfo.rect.width, this.dropIndicatorThickness);else if (target.dropPosition === 'after') rect = new (0, $img26$Rect)(layoutInfo.rect.x, layoutInfo.rect.maxY - this.dropIndicatorThickness / 2, layoutInfo.rect.width, this.dropIndicatorThickness);else rect = layoutInfo.rect;\n    return new (0, $img26$LayoutInfo)('dropIndicator', target.key + ':' + target.dropPosition, rect);\n  }\n  /**\n  * Creates a new ListLayout with options. See the list of properties below for a description\n  * of the options that can be provided.\n  */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    var _options_rowHeight;\n    this.rowHeight = (_options_rowHeight = options.rowHeight) !== null && _options_rowHeight !== void 0 ? _options_rowHeight : null;\n    var _options_estimatedRowHeight;\n    this.estimatedRowHeight = (_options_estimatedRowHeight = options.estimatedRowHeight) !== null && _options_estimatedRowHeight !== void 0 ? _options_estimatedRowHeight : null;\n    var _options_headingHeight;\n    this.headingHeight = (_options_headingHeight = options.headingHeight) !== null && _options_headingHeight !== void 0 ? _options_headingHeight : null;\n    var _options_estimatedHeadingHeight;\n    this.estimatedHeadingHeight = (_options_estimatedHeadingHeight = options.estimatedHeadingHeight) !== null && _options_estimatedHeadingHeight !== void 0 ? _options_estimatedHeadingHeight : null;\n    var _options_loaderHeight;\n    this.loaderHeight = (_options_loaderHeight = options.loaderHeight) !== null && _options_loaderHeight !== void 0 ? _options_loaderHeight : null;\n    this.dropIndicatorThickness = options.dropIndicatorThickness || 2;\n    this.layoutNodes = new Map();\n    this.rootNodes = [];\n    this.lastWidth = 0;\n    this.lastCollection = null;\n    this.invalidateEverything = false;\n    this.validRect = new (0, $img26$Rect)();\n    this.requestedRect = new (0, $img26$Rect)();\n    this.contentSize = new (0, $img26$Size)();\n  }\n}\nexport { $61ef60fc9b1041f4$export$cacbb3924155d68e as ListLayout };","map":{"version":3,"names":["$61ef60fc9b1041f4$var$DEFAULT_HEIGHT","$61ef60fc9b1041f4$export$cacbb3924155d68e","$img26$Layout","collection","virtualizer","getLayoutInfo","key","_this_layoutNodes_get","ensureLayoutInfo","layoutNodes","get","layoutInfo","getVisibleLayoutInfos","rect","height","_this_rowHeight","_ref","rowHeight","estimatedRowHeight","y","Math","floor","ceil","layoutIfNeeded","res","addNodes","nodes","node","isVisible","push","children","rootNodes","lastCollection","requestedRect","containsRect","union","buildCollection","persistedKeys","has","area","contentSize","$img26$Rect","Infinity","width","intersects","isSticky","type","isPersistedKey","shouldInvalidateEverything","invalidationContext","sizeChanged","update","invalidateEverything","visibleRect","copy","clear","getKeys","getItem","layoutNode","delete","lastWidth","validRect","arguments","length","undefined","skipped","isValid","buildChild","maxY","size","$img26$Size","cached","intersection","x","parentKey","buildNode","set","buildSection","buildItem","buildSectionHeader","buildLoader","Error","$img26$LayoutInfo","loaderHeight","startY","child","$img26$getChildNodes","rectHeight","headingHeight","isEstimated","previousLayoutNode","previousLayoutInfo","curNode","lastNode","estimatedSize","rendered","estimatedHeadingHeight","headerRect","header","updateItemSize","newLayoutInfo","min","updateLayoutNode","oldLayoutInfo","n","getContentSize","getDropTargetFromPoint","isValidDropTarget","keyAtPoint","$img26$Point","target","dropPosition","_objectSpread","getDropTargetLayoutInfo","dropIndicatorThickness","constructor","options","_options_rowHeight","_options_estimatedRowHeight","_options_headingHeight","_options_estimatedHeadingHeight","_options_loaderHeight","Map"],"sources":["C:\\Users\\rewac\\OneDrive\\Documents\\GitHub\\scatch-store.me\\node_modules\\@react-stately\\layout\\dist\\packages\\@react-stately\\layout\\src\\ListLayout.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, DropTarget, DropTargetDelegate, ItemDropTarget, Key, Node} from '@react-types/shared';\nimport {getChildNodes} from '@react-stately/collections';\nimport {InvalidationContext, Layout, LayoutInfo, Point, Rect, Size} from '@react-stately/virtualizer';\n\nexport interface ListLayoutOptions {\n  /** The fixed height of a row in px. */\n  rowHeight?: number,\n  /** The estimated height of a row, when row heights are variable. */\n  estimatedRowHeight?: number,\n  /** The fixed height of a section header in px. */\n  headingHeight?: number,\n  /** The estimated height of a section header, when the height is variable. */\n  estimatedHeadingHeight?: number,\n  /** The fixed height of a loader element in px. This loader is specifically for\n   * \"load more\" elements rendered when loading more rows at the root level or inside nested row/sections.\n   */\n  loaderHeight?: number,\n  /** The thickness of the drop indicator. */\n  dropIndicatorThickness?: number\n}\n\n// A wrapper around LayoutInfo that supports hierarchy\nexport interface LayoutNode {\n  node?: Node<unknown>,\n  layoutInfo: LayoutInfo,\n  children?: LayoutNode[],\n  validRect: Rect,\n  index?: number\n}\n\nconst DEFAULT_HEIGHT = 48;\n\n/**\n * The ListLayout class is an implementation of a virtualizer {@link Layout}.\n * To configure a ListLayout, you can use the properties to define the\n * layouts and/or use the method for defining indentation.\n * The {@link ListKeyboardDelegate} extends the existing virtualizer\n * delegate with an additional method to do this (it uses the same delegate object as\n * the virtualizer itself).\n */\nexport class ListLayout<T, O = any> extends Layout<Node<T>, O> implements DropTargetDelegate {\n  protected rowHeight: number | null;\n  protected estimatedRowHeight: number | null;\n  protected headingHeight: number | null;\n  protected estimatedHeadingHeight: number | null;\n  protected loaderHeight: number | null;\n  protected dropIndicatorThickness: number;\n  protected layoutNodes: Map<Key, LayoutNode>;\n  protected contentSize: Size;\n  protected lastCollection: Collection<Node<T>> | null;\n  private lastWidth: number;\n  protected rootNodes: LayoutNode[];\n  private invalidateEverything: boolean;\n  /** The rectangle containing currently valid layout infos. */\n  protected validRect: Rect;\n  /** The rectangle of requested layout infos so far. */\n  protected requestedRect: Rect;\n\n  /**\n   * Creates a new ListLayout with options. See the list of properties below for a description\n   * of the options that can be provided.\n   */\n  constructor(options: ListLayoutOptions = {}) {\n    super();\n    this.rowHeight = options.rowHeight ?? null;\n    this.estimatedRowHeight = options.estimatedRowHeight ?? null;\n    this.headingHeight = options.headingHeight ?? null;\n    this.estimatedHeadingHeight = options.estimatedHeadingHeight ?? null;\n    this.loaderHeight = options.loaderHeight ?? null;\n    this.dropIndicatorThickness = options.dropIndicatorThickness || 2;\n    this.layoutNodes = new Map();\n    this.rootNodes = [];\n    this.lastWidth = 0;\n    this.lastCollection = null;\n    this.invalidateEverything = false;\n    this.validRect = new Rect();\n    this.requestedRect = new Rect();\n    this.contentSize = new Size();\n  }\n\n  // Backward compatibility for subclassing.\n  protected get collection(): Collection<Node<T>> {\n    return this.virtualizer!.collection;\n  }\n\n  getLayoutInfo(key: Key) {\n    this.ensureLayoutInfo(key);\n    return this.layoutNodes.get(key)?.layoutInfo || null;\n  }\n\n  getVisibleLayoutInfos(rect: Rect) {\n    // Adjust rect to keep number of visible rows consistent.\n    // (only if height > 1 for getDropTargetFromPoint)\n    if (rect.height > 1) {\n      let rowHeight = this.rowHeight ?? this.estimatedRowHeight ?? DEFAULT_HEIGHT;\n      rect.y = Math.floor(rect.y / rowHeight) * rowHeight;\n      rect.height = Math.ceil(rect.height / rowHeight) * rowHeight;\n    }\n\n    // If layout hasn't yet been done for the requested rect, union the\n    // new rect with the existing valid rect, and recompute.\n    this.layoutIfNeeded(rect);\n\n    let res: LayoutInfo[] = [];\n\n    let addNodes = (nodes: LayoutNode[]) => {\n      for (let node of nodes) {\n        if (this.isVisible(node, rect)) {\n          res.push(node.layoutInfo);\n\n          if (node.children) {\n            addNodes(node.children);\n          }\n        }\n      }\n    };\n\n    addNodes(this.rootNodes);\n    return res;\n  }\n\n  protected layoutIfNeeded(rect: Rect) {\n    if (!this.lastCollection) {\n      return;\n    }\n\n    if (!this.requestedRect.containsRect(rect)) {\n      this.requestedRect = this.requestedRect.union(rect);\n      this.rootNodes = this.buildCollection();\n    }\n    \n    // Ensure all of the persisted keys are available.\n    for (let key of this.virtualizer!.persistedKeys) {\n      if (this.ensureLayoutInfo(key)) {\n        return;\n      }\n    }\n  }\n\n  private ensureLayoutInfo(key: Key) {\n    // If the layout info wasn't found, it might be outside the bounds of the area that we've\n    // computed layout for so far. This can happen when accessing a random key, e.g pressing Home/End.\n    // Compute the full layout and try again.\n    if (!this.layoutNodes.has(key) && this.requestedRect.area < this.contentSize.area && this.lastCollection) {\n      this.requestedRect = new Rect(0, 0, Infinity, Infinity);\n      this.rootNodes = this.buildCollection();\n      this.requestedRect = new Rect(0, 0, this.contentSize.width, this.contentSize.height);\n      return true;\n    }\n\n    return false;\n  }\n\n  protected isVisible(node: LayoutNode, rect: Rect) {\n    return node.layoutInfo.rect.intersects(rect) || node.layoutInfo.isSticky || node.layoutInfo.type === 'header' || this.virtualizer!.isPersistedKey(node.layoutInfo.key);\n  }\n\n  protected shouldInvalidateEverything(invalidationContext: InvalidationContext<O>) {\n    // Invalidate cache if the size of the collection changed.\n    // In this case, we need to recalculate the entire layout.\n    return invalidationContext.sizeChanged || false;\n  }\n\n  update(invalidationContext: InvalidationContext<O>) {\n    let collection = this.virtualizer!.collection;\n\n    // Reset valid rect if we will have to invalidate everything.\n    // Otherwise we can reuse cached layout infos outside the current visible rect.\n    this.invalidateEverything = this.shouldInvalidateEverything(invalidationContext);\n    if (this.invalidateEverything) {\n      this.requestedRect = this.virtualizer!.visibleRect.copy();\n      this.layoutNodes.clear();\n    }\n\n    this.rootNodes = this.buildCollection();\n\n    // Remove deleted layout nodes\n    if (this.lastCollection && collection !== this.lastCollection) {\n      for (let key of this.lastCollection.getKeys()) {\n        if (!collection.getItem(key)) {\n          let layoutNode = this.layoutNodes.get(key);\n          if (layoutNode) {\n            this.layoutNodes.delete(key);\n          }\n        }\n      }\n    }\n\n    this.lastWidth = this.virtualizer!.visibleRect.width;\n    this.lastCollection = collection;\n    this.invalidateEverything = false;\n    this.validRect = this.requestedRect.copy();\n  }\n\n  protected buildCollection(y = 0): LayoutNode[] {\n    let collection = this.virtualizer!.collection;\n    let skipped = 0;\n    let nodes: LayoutNode[] = [];\n    for (let node of collection) {\n      let rowHeight = this.rowHeight ?? this.estimatedRowHeight ?? DEFAULT_HEIGHT;\n\n      // Skip rows before the valid rectangle unless they are already cached.\n      if (node.type === 'item' && y + rowHeight < this.requestedRect.y && !this.isValid(node, y)) {\n        y += rowHeight;\n        skipped++;\n        continue;\n      }\n\n      let layoutNode = this.buildChild(node, 0, y, null);\n      y = layoutNode.layoutInfo.rect.maxY;\n      nodes.push(layoutNode);\n\n      if (node.type === 'item' && y > this.requestedRect.maxY) {\n        y += (collection.size - (nodes.length + skipped)) * rowHeight;\n        break;\n      }\n    }\n\n    this.contentSize = new Size(this.virtualizer!.visibleRect.width, y);\n    return nodes;\n  }\n\n  protected isValid(node: Node<T>, y: number) {\n    let cached = this.layoutNodes.get(node.key);\n    return (\n      !this.invalidateEverything &&\n      cached &&\n      cached.node === node &&\n      y === cached.layoutInfo.rect.y &&\n      cached.layoutInfo.rect.intersects(this.validRect) &&\n      cached.validRect.containsRect(cached.layoutInfo.rect.intersection(this.requestedRect))\n    );\n  }\n\n  protected buildChild(node: Node<T>, x: number, y: number, parentKey: Key | null): LayoutNode {\n    if (this.isValid(node, y)) {\n      return this.layoutNodes.get(node.key)!;\n    }\n\n    let layoutNode = this.buildNode(node, x, y);\n\n    layoutNode.layoutInfo.parentKey = parentKey ?? null;\n    this.layoutNodes.set(node.key, layoutNode);\n    return layoutNode;\n  }\n\n  protected buildNode(node: Node<T>, x: number, y: number): LayoutNode {\n    switch (node.type) {\n      case 'section':\n        return this.buildSection(node, x, y);\n      case 'item':\n        return this.buildItem(node, x, y);\n      case 'header':\n        return this.buildSectionHeader(node, x, y);\n      case 'loader':\n        return this.buildLoader(node, x, y);\n      default:\n        throw new Error('Unsupported node type: ' + node.type);\n    }\n  }\n\n  protected buildLoader(node: Node<T>, x: number, y: number): LayoutNode {\n    let rect = new Rect(x, y, 0, 0);\n    let layoutInfo = new LayoutInfo('loader', node.key, rect);\n    rect.width = this.virtualizer!.contentSize.width;\n    rect.height = this.loaderHeight || this.rowHeight || this.estimatedRowHeight || DEFAULT_HEIGHT;\n\n    return {\n      layoutInfo,\n      validRect: rect.intersection(this.requestedRect)\n    };\n  }\n\n  protected buildSection(node: Node<T>, x: number, y: number): LayoutNode {\n    let collection = this.virtualizer!.collection;\n    let width = this.virtualizer!.visibleRect.width;\n    let rect = new Rect(0, y, width, 0);\n    let layoutInfo = new LayoutInfo(node.type, node.key, rect);\n\n    let startY = y;\n    let skipped = 0;\n    let children: LayoutNode[] = [];\n    for (let child of getChildNodes(node, collection)) {\n      let rowHeight = (this.rowHeight ?? this.estimatedRowHeight ?? DEFAULT_HEIGHT);\n\n      // Skip rows before the valid rectangle unless they are already cached.\n      if (y + rowHeight < this.requestedRect.y && !this.isValid(node, y)) {\n        y += rowHeight;\n        skipped++;\n        continue;\n      }\n\n      let layoutNode = this.buildChild(child, x, y, layoutInfo.key);\n      y = layoutNode.layoutInfo.rect.maxY;\n      children.push(layoutNode);\n\n      if (y > this.requestedRect.maxY) {\n        // Estimate the remaining height for rows that we don't need to layout right now.\n        y += ([...getChildNodes(node, collection)].length - (children.length + skipped)) * rowHeight;\n        break;\n      }\n    }\n\n    rect.height = y - startY;\n\n    return {\n      layoutInfo,\n      children,\n      validRect: layoutInfo.rect.intersection(this.requestedRect),\n      node\n    };\n  }\n\n  protected buildSectionHeader(node: Node<T>, x: number, y: number): LayoutNode {\n    let width = this.virtualizer!.visibleRect.width;\n    let rectHeight = this.headingHeight;\n    let isEstimated = false;\n\n    // If no explicit height is available, use an estimated height.\n    if (rectHeight == null) {\n      // If a previous version of this layout info exists, reuse its height.\n      // Mark as estimated if the size of the overall virtualizer changed,\n      // or the content of the item changed.\n      let previousLayoutNode = this.layoutNodes.get(node.key);\n      let previousLayoutInfo = previousLayoutNode?.layoutInfo;\n      if (previousLayoutInfo) {\n        let curNode = this.virtualizer!.collection.getItem(node.key);\n        let lastNode = this.lastCollection ? this.lastCollection.getItem(node.key) : null;\n        rectHeight = previousLayoutInfo.rect.height;\n        isEstimated = width !== this.lastWidth || curNode !== lastNode || previousLayoutInfo.estimatedSize;\n      } else {\n        rectHeight = (node.rendered ? this.estimatedHeadingHeight : 0);\n        isEstimated = true;\n      }\n    }\n\n    if (rectHeight == null) {\n      rectHeight = DEFAULT_HEIGHT;\n    }\n\n    let headerRect = new Rect(0, y, width, rectHeight);\n    let header = new LayoutInfo('header', node.key, headerRect);\n    header.estimatedSize = isEstimated;\n    return {\n      layoutInfo: header,\n      children: [],\n      validRect: header.rect.intersection(this.requestedRect),\n      node\n    };\n  }\n\n  protected buildItem(node: Node<T>, x: number, y: number): LayoutNode {\n    let width = this.virtualizer!.visibleRect.width;\n    let rectHeight = this.rowHeight;\n    let isEstimated = false;\n\n    // If no explicit height is available, use an estimated height.\n    if (rectHeight == null) {\n      // If a previous version of this layout info exists, reuse its height.\n      // Mark as estimated if the size of the overall virtualizer changed,\n      // or the content of the item changed.\n      let previousLayoutNode = this.layoutNodes.get(node.key);\n      if (previousLayoutNode) {\n        rectHeight = previousLayoutNode.layoutInfo.rect.height;\n        isEstimated = width !== this.lastWidth || node !== previousLayoutNode.node || previousLayoutNode.layoutInfo.estimatedSize;\n      } else {\n        rectHeight = this.estimatedRowHeight;\n        isEstimated = true;\n      }\n    }\n\n    if (rectHeight == null) {\n      rectHeight = DEFAULT_HEIGHT;\n    }\n\n    let rect = new Rect(x, y, width - x, rectHeight);\n    let layoutInfo = new LayoutInfo(node.type, node.key, rect);\n    layoutInfo.estimatedSize = isEstimated;\n    return {\n      layoutInfo,\n      children: [],\n      validRect: layoutInfo.rect,\n      node\n    };\n  }\n\n  updateItemSize(key: Key, size: Size) {\n    let layoutNode = this.layoutNodes.get(key);\n    // If no layoutInfo, item has been deleted/removed.\n    if (!layoutNode) {\n      return false;\n    }\n\n    let collection = this.virtualizer!.collection;\n    let layoutInfo = layoutNode.layoutInfo;\n    layoutInfo.estimatedSize = false;\n    if (layoutInfo.rect.height !== size.height) {\n      // Copy layout info rather than mutating so that later caches are invalidated.\n      let newLayoutInfo = layoutInfo.copy();\n      newLayoutInfo.rect.height = size.height;\n      layoutNode.layoutInfo = newLayoutInfo;\n\n      // Items after this layoutInfo will need to be repositioned to account for the new height.\n      // Adjust the validRect so that only items above remain valid.\n      this.validRect.height = Math.min(this.validRect.height, layoutInfo.rect.y - this.validRect.y);\n\n      // The requestedRect also needs to be adjusted to account for the height difference.\n      this.requestedRect.height += newLayoutInfo.rect.height - layoutInfo.rect.height;\n\n      // Invalidate layout for this layout node and all parents\n      this.updateLayoutNode(key, layoutInfo, newLayoutInfo);\n\n      let node = layoutInfo.parentKey != null ? collection.getItem(layoutInfo.parentKey) : null;\n      while (node) {\n        this.updateLayoutNode(node.key, layoutInfo, newLayoutInfo);\n        node = node.parentKey != null ? collection.getItem(node.parentKey) : null;\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  private updateLayoutNode(key: Key, oldLayoutInfo: LayoutInfo, newLayoutInfo: LayoutInfo) {\n    let n = this.layoutNodes.get(key);\n    if (n) {\n      // Invalidate by intersecting the validRect of this node with the overall validRect.\n      n.validRect = n.validRect.intersection(this.validRect);\n\n      // Replace layout info in LayoutNode\n      if (n.layoutInfo === oldLayoutInfo) {\n        n.layoutInfo = newLayoutInfo;\n      }\n    }\n  }\n\n  getContentSize() {\n    return this.contentSize;\n  }\n\n  getDropTargetFromPoint(x: number, y: number, isValidDropTarget: (target: DropTarget) => boolean): DropTarget | null {\n    x += this.virtualizer!.visibleRect.x;\n    y += this.virtualizer!.visibleRect.y;\n\n    let key = this.virtualizer!.keyAtPoint(new Point(x, y));\n    if (key == null || this.virtualizer!.collection.size === 0) {\n      return {type: 'root'};\n    }\n\n    let layoutInfo = this.getLayoutInfo(key);\n    if (!layoutInfo) {\n      return null;\n    }\n\n    let rect = layoutInfo.rect;\n    let target: DropTarget = {\n      type: 'item',\n      key: layoutInfo.key,\n      dropPosition: 'on'\n    };\n\n    // If dropping on the item isn't accepted, try the target before or after depending on the y position.\n    // Otherwise, if dropping on the item is accepted, still try the before/after positions if within 10px\n    // of the top or bottom of the item.\n    if (!isValidDropTarget(target)) {\n      if (y <= rect.y + rect.height / 2 && isValidDropTarget({...target, dropPosition: 'before'})) {\n        target.dropPosition = 'before';\n      } else if (isValidDropTarget({...target, dropPosition: 'after'})) {\n        target.dropPosition = 'after';\n      }\n    } else if (y <= rect.y + 10 && isValidDropTarget({...target, dropPosition: 'before'})) {\n      target.dropPosition = 'before';\n    } else if (y >= rect.maxY - 10 && isValidDropTarget({...target, dropPosition: 'after'})) {\n      target.dropPosition = 'after';\n    }\n\n    return target;\n  }\n\n  getDropTargetLayoutInfo(target: ItemDropTarget): LayoutInfo {\n    let layoutInfo = this.getLayoutInfo(target.key)!;\n    let rect: Rect;\n    if (target.dropPosition === 'before') {\n      rect = new Rect(layoutInfo.rect.x, layoutInfo.rect.y - this.dropIndicatorThickness / 2, layoutInfo.rect.width, this.dropIndicatorThickness);\n    } else if (target.dropPosition === 'after') {\n      rect = new Rect(layoutInfo.rect.x, layoutInfo.rect.maxY - this.dropIndicatorThickness / 2, layoutInfo.rect.width, this.dropIndicatorThickness);\n    } else {\n      rect = layoutInfo.rect;\n    }\n\n    return new LayoutInfo('dropIndicator', target.key + ':' + target.dropPosition, rect);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _objectSpread from \"C:/Users/rewac/OneDrive/Documents/GitHub/scatch-store.me/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { ListLayout as $61ef60fc9b1041f4$export$cacbb3924155d68e } from \"./ListLayout.mjs\";\nimport { getChildNodes as $bmsJv$getChildNodes } from \"@react-stately/collections\";\nimport { Size as $bmsJv$Size, Rect as $bmsJv$Rect, LayoutInfo as $bmsJv$LayoutInfo, Point as $bmsJv$Point } from \"@react-stately/virtualizer\";\nimport { TableColumnLayout as $bmsJv$TableColumnLayout } from \"@react-stately/table\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nconst $a152112e902709bf$var$DEFAULT_ROW_HEIGHT = 48;\nclass $a152112e902709bf$export$62444c3c724b1b20 extends (0, $61ef60fc9b1041f4$export$cacbb3924155d68e) {\n  // Backward compatibility for subclassing.\n  get collection() {\n    return this.virtualizer.collection;\n  }\n  columnsChanged(newCollection, oldCollection) {\n    return !oldCollection || newCollection.columns !== oldCollection.columns && newCollection.columns.length !== oldCollection.columns.length || newCollection.columns.some((c, i) => c.key !== oldCollection.columns[i].key || c.props.width !== oldCollection.columns[i].props.width || c.props.minWidth !== oldCollection.columns[i].props.minWidth || c.props.maxWidth !== oldCollection.columns[i].props.maxWidth);\n  }\n  update(invalidationContext) {\n    var _invalidationContext_layoutOptions;\n    let newCollection = this.virtualizer.collection;\n    // If columnWidths were provided via layoutOptions, update those.\n    // Otherwise, calculate column widths ourselves.\n    if ((_invalidationContext_layoutOptions = invalidationContext.layoutOptions) === null || _invalidationContext_layoutOptions === void 0 ? void 0 : _invalidationContext_layoutOptions.columnWidths) {\n      if (invalidationContext.layoutOptions.columnWidths !== this.columnWidths) {\n        this.columnWidths = invalidationContext.layoutOptions.columnWidths;\n        invalidationContext.sizeChanged = true;\n      }\n    } else if (invalidationContext.sizeChanged || this.columnsChanged(newCollection, this.lastCollection)) {\n      let columnLayout = new (0, $bmsJv$TableColumnLayout)({});\n      this.columnWidths = columnLayout.buildColumnWidths(this.virtualizer.visibleRect.width, newCollection, new Map());\n      invalidationContext.sizeChanged = true;\n    }\n    super.update(invalidationContext);\n  }\n  buildCollection() {\n    this.stickyColumnIndices = [];\n    let collection = this.virtualizer.collection;\n    for (let column of collection.columns)\n    // The selection cell and any other sticky columns always need to be visible.\n    // In addition, row headers need to be in the DOM for accessibility labeling.\n    if (this.isStickyColumn(column) || collection.rowHeaderColumnKeys.has(column.key)) this.stickyColumnIndices.push(column.index);\n    let header = this.buildTableHeader();\n    this.layoutNodes.set(header.layoutInfo.key, header);\n    let body = this.buildBody(header.layoutInfo.rect.height);\n    this.lastPersistedKeys = null;\n    body.layoutInfo.rect.width = Math.max(header.layoutInfo.rect.width, body.layoutInfo.rect.width);\n    this.contentSize = new (0, $bmsJv$Size)(body.layoutInfo.rect.width, body.layoutInfo.rect.maxY);\n    return [header, body];\n  }\n  buildTableHeader() {\n    var _collection_head;\n    let collection = this.virtualizer.collection;\n    let rect = new (0, $bmsJv$Rect)(0, 0, 0, 0);\n    var _collection_head_key;\n    let layoutInfo = new (0, $bmsJv$LayoutInfo)('header', (_collection_head_key = (_collection_head = collection.head) === null || _collection_head === void 0 ? void 0 : _collection_head.key) !== null && _collection_head_key !== void 0 ? _collection_head_key : 'header', rect);\n    layoutInfo.isSticky = true;\n    layoutInfo.zIndex = 1;\n    let y = 0;\n    let width = 0;\n    let children = [];\n    for (let headerRow of collection.headerRows) {\n      let layoutNode = this.buildChild(headerRow, 0, y, layoutInfo.key);\n      layoutNode.layoutInfo.parentKey = layoutInfo.key;\n      y = layoutNode.layoutInfo.rect.maxY;\n      width = Math.max(width, layoutNode.layoutInfo.rect.width);\n      layoutNode.index = children.length;\n      children.push(layoutNode);\n    }\n    rect.width = width;\n    rect.height = y;\n    return {\n      layoutInfo: layoutInfo,\n      children: children,\n      validRect: layoutInfo.rect,\n      node: collection.head\n    };\n  }\n  buildHeaderRow(headerRow, x, y) {\n    let rect = new (0, $bmsJv$Rect)(0, y, 0, 0);\n    let row = new (0, $bmsJv$LayoutInfo)('headerrow', headerRow.key, rect);\n    let height = 0;\n    let columns = [];\n    for (let cell of (0, $bmsJv$getChildNodes)(headerRow, this.virtualizer.collection)) {\n      let layoutNode = this.buildChild(cell, x, y, row.key);\n      layoutNode.layoutInfo.parentKey = row.key;\n      x = layoutNode.layoutInfo.rect.maxX;\n      height = Math.max(height, layoutNode.layoutInfo.rect.height);\n      layoutNode.index = columns.length;\n      columns.push(layoutNode);\n    }\n    for (let [i, layout] of columns.entries()) layout.layoutInfo.zIndex = columns.length - i + 1;\n    this.setChildHeights(columns, height);\n    rect.height = height;\n    rect.width = x;\n    return {\n      layoutInfo: row,\n      children: columns,\n      validRect: rect,\n      node: headerRow\n    };\n  }\n  setChildHeights(children, height) {\n    for (let child of children) if (child.layoutInfo.rect.height !== height) {\n      // Need to copy the layout info before we mutate it.\n      child.layoutInfo = child.layoutInfo.copy();\n      child.layoutInfo.rect.height = height;\n    }\n  }\n  // used to get the column widths when rendering to the DOM\n  getRenderedColumnWidth(node) {\n    let collection = this.virtualizer.collection;\n    var _node_colspan;\n    let colspan = (_node_colspan = node.colspan) !== null && _node_colspan !== void 0 ? _node_colspan : 1;\n    var _node_colIndex;\n    let colIndex = (_node_colIndex = node.colIndex) !== null && _node_colIndex !== void 0 ? _node_colIndex : node.index;\n    let width = 0;\n    for (let i = colIndex; i < colIndex + colspan; i++) {\n      let column = collection.columns[i];\n      var _this_columnWidths_get;\n      if ((column === null || column === void 0 ? void 0 : column.key) != null) width += (_this_columnWidths_get = this.columnWidths.get(column.key)) !== null && _this_columnWidths_get !== void 0 ? _this_columnWidths_get : 0;\n    }\n    return width;\n  }\n  getEstimatedHeight(node, width, height, estimatedHeight) {\n    let isEstimated = false;\n    // If no explicit height is available, use an estimated height.\n    if (height == null) {\n      // If a previous version of this layout info exists, reuse its height.\n      // Mark as estimated if the size of the overall collection view changed,\n      // or the content of the item changed.\n      let previousLayoutNode = this.layoutNodes.get(node.key);\n      if (previousLayoutNode) {\n        height = previousLayoutNode.layoutInfo.rect.height;\n        isEstimated = node !== previousLayoutNode.node || width !== previousLayoutNode.layoutInfo.rect.width || previousLayoutNode.layoutInfo.estimatedSize;\n      } else {\n        height = estimatedHeight !== null && estimatedHeight !== void 0 ? estimatedHeight : $a152112e902709bf$var$DEFAULT_ROW_HEIGHT;\n        isEstimated = true;\n      }\n    }\n    return {\n      height: height,\n      isEstimated: isEstimated\n    };\n  }\n  getEstimatedRowHeight() {\n    var _this_rowHeight, _ref;\n    return (_ref = (_this_rowHeight = this.rowHeight) !== null && _this_rowHeight !== void 0 ? _this_rowHeight : this.estimatedRowHeight) !== null && _ref !== void 0 ? _ref : $a152112e902709bf$var$DEFAULT_ROW_HEIGHT;\n  }\n  buildColumn(node, x, y) {\n    let width = this.getRenderedColumnWidth(node);\n    var _this_headingHeight, _this_estimatedHeadingHeight;\n    let {\n      height: height,\n      isEstimated: isEstimated\n    } = this.getEstimatedHeight(node, width, (_this_headingHeight = this.headingHeight) !== null && _this_headingHeight !== void 0 ? _this_headingHeight : this.rowHeight, (_this_estimatedHeadingHeight = this.estimatedHeadingHeight) !== null && _this_estimatedHeadingHeight !== void 0 ? _this_estimatedHeadingHeight : this.estimatedRowHeight);\n    let rect = new (0, $bmsJv$Rect)(x, y, width, height);\n    let layoutInfo = new (0, $bmsJv$LayoutInfo)(node.type, node.key, rect);\n    layoutInfo.isSticky = this.isStickyColumn(node);\n    layoutInfo.zIndex = layoutInfo.isSticky ? 2 : 1;\n    layoutInfo.estimatedSize = isEstimated;\n    return {\n      layoutInfo: layoutInfo,\n      children: [],\n      validRect: layoutInfo.rect,\n      node: node\n    };\n  }\n  // For subclasses.\n  // eslint-disable-next-line\n  isStickyColumn(node) {\n    return false;\n  }\n  buildBody(y) {\n    let collection = this.virtualizer.collection;\n    let rect = new (0, $bmsJv$Rect)(0, y, 0, 0);\n    let layoutInfo = new (0, $bmsJv$LayoutInfo)('rowgroup', collection.body.key, rect);\n    let startY = y;\n    let skipped = 0;\n    let width = 0;\n    let children = [];\n    let rowHeight = this.getEstimatedRowHeight();\n    for (let node of (0, $bmsJv$getChildNodes)(collection.body, collection)) {\n      // Skip rows before the valid rectangle unless they are already cached.\n      if (y + rowHeight < this.requestedRect.y && !this.isValid(node, y)) {\n        y += rowHeight;\n        skipped++;\n        continue;\n      }\n      let layoutNode = this.buildChild(node, 0, y, layoutInfo.key);\n      layoutNode.layoutInfo.parentKey = layoutInfo.key;\n      layoutNode.index = children.length;\n      y = layoutNode.layoutInfo.rect.maxY;\n      width = Math.max(width, layoutNode.layoutInfo.rect.width);\n      children.push(layoutNode);\n      if (y > this.requestedRect.maxY) {\n        // Estimate the remaining height for rows that we don't need to layout right now.\n        y += (collection.size - (skipped + children.length)) * rowHeight;\n        break;\n      }\n    }\n    if (children.length === 0) y = this.virtualizer.visibleRect.maxY;\n    rect.width = width;\n    rect.height = y - startY;\n    return {\n      layoutInfo: layoutInfo,\n      children: children,\n      validRect: layoutInfo.rect.intersection(this.requestedRect),\n      node: collection.body\n    };\n  }\n  buildNode(node, x, y) {\n    switch (node.type) {\n      case 'headerrow':\n        return this.buildHeaderRow(node, x, y);\n      case 'item':\n        return this.buildRow(node, x, y);\n      case 'column':\n      case 'placeholder':\n        return this.buildColumn(node, x, y);\n      case 'cell':\n        return this.buildCell(node, x, y);\n      case 'loader':\n        return this.buildLoader(node, x, y);\n      default:\n        throw new Error('Unknown node type ' + node.type);\n    }\n  }\n  buildRow(node, x, y) {\n    var _collection_head;\n    let collection = this.virtualizer.collection;\n    let rect = new (0, $bmsJv$Rect)(x, y, 0, 0);\n    let layoutInfo = new (0, $bmsJv$LayoutInfo)('row', node.key, rect);\n    let children = [];\n    let height = 0;\n    for (let child of (0, $bmsJv$getChildNodes)(node, collection)) if (child.type === 'cell') {\n      if (x > this.requestedRect.maxX) {\n        // Adjust existing cached layoutInfo to ensure that it is out of view.\n        // This can happen due to column resizing.\n        let layoutNode = this.layoutNodes.get(child.key);\n        if (layoutNode) {\n          layoutNode.layoutInfo.rect.x = x;\n          x += layoutNode.layoutInfo.rect.width;\n        } else break;\n      } else {\n        let layoutNode = this.buildChild(child, x, y, layoutInfo.key);\n        x = layoutNode.layoutInfo.rect.maxX;\n        height = Math.max(height, layoutNode.layoutInfo.rect.height);\n        layoutNode.index = children.length;\n        children.push(layoutNode);\n      }\n    }\n    this.setChildHeights(children, height);\n    var _collection_head_key;\n    rect.width = this.layoutNodes.get((_collection_head_key = (_collection_head = collection.head) === null || _collection_head === void 0 ? void 0 : _collection_head.key) !== null && _collection_head_key !== void 0 ? _collection_head_key : 'header').layoutInfo.rect.width;\n    rect.height = height;\n    return {\n      layoutInfo: layoutInfo,\n      children: children,\n      validRect: rect.intersection(this.requestedRect),\n      node: node\n    };\n  }\n  buildCell(node, x, y) {\n    let width = this.getRenderedColumnWidth(node);\n    let {\n      height: height,\n      isEstimated: isEstimated\n    } = this.getEstimatedHeight(node, width, this.rowHeight, this.estimatedRowHeight);\n    let rect = new (0, $bmsJv$Rect)(x, y, width, height);\n    let layoutInfo = new (0, $bmsJv$LayoutInfo)(node.type, node.key, rect);\n    layoutInfo.isSticky = this.isStickyColumn(node);\n    layoutInfo.zIndex = layoutInfo.isSticky ? 2 : 1;\n    layoutInfo.estimatedSize = isEstimated;\n    return {\n      layoutInfo: layoutInfo,\n      children: [],\n      validRect: rect,\n      node: node\n    };\n  }\n  getVisibleLayoutInfos(rect) {\n    // Adjust rect to keep number of visible rows consistent.\n    // (only if height > 1 for getDropTargetFromPoint)\n    if (rect.height > 1) {\n      let rowHeight = this.getEstimatedRowHeight();\n      rect.y = Math.floor(rect.y / rowHeight) * rowHeight;\n      rect.height = Math.ceil(rect.height / rowHeight) * rowHeight;\n    }\n    // If layout hasn't yet been done for the requested rect, union the\n    // new rect with the existing valid rect, and recompute.\n    this.layoutIfNeeded(rect);\n    let res = [];\n    this.buildPersistedIndices();\n    for (let node of this.rootNodes) {\n      res.push(node.layoutInfo);\n      this.addVisibleLayoutInfos(res, node, rect);\n    }\n    return res;\n  }\n  addVisibleLayoutInfos(res, node, rect) {\n    if (!node.children || node.children.length === 0) return;\n    switch (node.layoutInfo.type) {\n      case 'header':\n        for (let child of node.children) {\n          res.push(child.layoutInfo);\n          this.addVisibleLayoutInfos(res, child, rect);\n        }\n        break;\n      case 'rowgroup':\n        {\n          let firstVisibleRow = this.binarySearch(node.children, rect.topLeft, 'y');\n          let lastVisibleRow = this.binarySearch(node.children, rect.bottomRight, 'y');\n          // Add persisted rows before the visible rows.\n          let persistedRowIndices = this.persistedIndices.get(node.layoutInfo.key);\n          let persistIndex = 0;\n          while (persistedRowIndices && persistIndex < persistedRowIndices.length && persistedRowIndices[persistIndex] < firstVisibleRow) {\n            let idx = persistedRowIndices[persistIndex];\n            if (idx < node.children.length) {\n              res.push(node.children[idx].layoutInfo);\n              this.addVisibleLayoutInfos(res, node.children[idx], rect);\n            }\n            persistIndex++;\n          }\n          for (let i = firstVisibleRow; i <= lastVisibleRow; i++) {\n            // Skip persisted rows that overlap with visible cells.\n            while (persistedRowIndices && persistIndex < persistedRowIndices.length && persistedRowIndices[persistIndex] < i) persistIndex++;\n            res.push(node.children[i].layoutInfo);\n            this.addVisibleLayoutInfos(res, node.children[i], rect);\n          }\n          // Add persisted rows after the visible rows.\n          while (persistedRowIndices && persistIndex < persistedRowIndices.length) {\n            let idx = persistedRowIndices[persistIndex++];\n            if (idx < node.children.length) {\n              res.push(node.children[idx].layoutInfo);\n              this.addVisibleLayoutInfos(res, node.children[idx], rect);\n            }\n          }\n          break;\n        }\n      case 'headerrow':\n      case 'row':\n        {\n          let firstVisibleCell = this.binarySearch(node.children, rect.topLeft, 'x');\n          let lastVisibleCell = this.binarySearch(node.children, rect.topRight, 'x');\n          let stickyIndex = 0;\n          // Add persisted/sticky cells before the visible cells.\n          let persistedCellIndices = this.persistedIndices.get(node.layoutInfo.key) || this.stickyColumnIndices;\n          while (stickyIndex < persistedCellIndices.length && persistedCellIndices[stickyIndex] < firstVisibleCell) {\n            let idx = persistedCellIndices[stickyIndex];\n            if (idx < node.children.length) res.push(node.children[idx].layoutInfo);\n            stickyIndex++;\n          }\n          for (let i = firstVisibleCell; i <= lastVisibleCell; i++) {\n            // Skip sticky cells that overlap with visible cells.\n            while (stickyIndex < persistedCellIndices.length && persistedCellIndices[stickyIndex] < i) stickyIndex++;\n            res.push(node.children[i].layoutInfo);\n          }\n          // Add any remaining sticky cells after the visible cells.\n          while (stickyIndex < persistedCellIndices.length) {\n            let idx = persistedCellIndices[stickyIndex++];\n            if (idx < node.children.length) res.push(node.children[idx].layoutInfo);\n          }\n          break;\n        }\n      default:\n        throw new Error('Unknown node type ' + node.layoutInfo.type);\n    }\n  }\n  binarySearch(items, point, axis) {\n    let low = 0;\n    let high = items.length - 1;\n    while (low <= high) {\n      let mid = low + high >> 1;\n      let item = items[mid];\n      if (axis === 'x' && item.layoutInfo.rect.maxX <= point.x || axis === 'y' && item.layoutInfo.rect.maxY <= point.y) low = mid + 1;else if (axis === 'x' && item.layoutInfo.rect.x > point.x || axis === 'y' && item.layoutInfo.rect.y > point.y) high = mid - 1;else return mid;\n    }\n    return Math.max(0, Math.min(items.length - 1, low));\n  }\n  buildPersistedIndices() {\n    if (this.virtualizer.persistedKeys === this.lastPersistedKeys) return;\n    this.lastPersistedKeys = this.virtualizer.persistedKeys;\n    this.persistedIndices.clear();\n    // Build a map of parentKey => indices of children to persist.\n    for (let key of this.virtualizer.persistedKeys) {\n      var _this_layoutNodes_get;\n      let layoutInfo = (_this_layoutNodes_get = this.layoutNodes.get(key)) === null || _this_layoutNodes_get === void 0 ? void 0 : _this_layoutNodes_get.layoutInfo;\n      // Walk up ancestors so parents are also persisted if children are.\n      while (layoutInfo && layoutInfo.parentKey) {\n        var _this_layoutNodes_get1, _this_layoutNodes_get2;\n        let collectionNode = this.virtualizer.collection.getItem(layoutInfo.key);\n        let indices = this.persistedIndices.get(layoutInfo.parentKey);\n        if (!indices) {\n          // stickyColumnIndices are always persisted along with any cells from persistedKeys.\n          indices = (collectionNode === null || collectionNode === void 0 ? void 0 : collectionNode.type) === 'cell' || (collectionNode === null || collectionNode === void 0 ? void 0 : collectionNode.type) === 'column' ? [...this.stickyColumnIndices] : [];\n          this.persistedIndices.set(layoutInfo.parentKey, indices);\n        }\n        let index = (_this_layoutNodes_get1 = this.layoutNodes.get(layoutInfo.key)) === null || _this_layoutNodes_get1 === void 0 ? void 0 : _this_layoutNodes_get1.index;\n        if (index != null && !indices.includes(index)) indices.push(index);\n        layoutInfo = (_this_layoutNodes_get2 = this.layoutNodes.get(layoutInfo.parentKey)) === null || _this_layoutNodes_get2 === void 0 ? void 0 : _this_layoutNodes_get2.layoutInfo;\n      }\n    }\n    for (let indices of this.persistedIndices.values()) indices.sort((a, b) => a - b);\n  }\n  getDropTargetFromPoint(x, y, isValidDropTarget) {\n    x += this.virtualizer.visibleRect.x;\n    y += this.virtualizer.visibleRect.y;\n    // Custom variation of this.virtualizer.keyAtPoint that ignores body\n    let key = null;\n    let point = new (0, $bmsJv$Point)(x, y);\n    let rectAtPoint = new (0, $bmsJv$Rect)(point.x, point.y, 1, 1);\n    let layoutInfos = this.virtualizer.layout.getVisibleLayoutInfos(rectAtPoint).filter(info => info.type === 'row');\n    // Layout may return multiple layout infos in the case of\n    // persisted keys, so find the first one that actually intersects.\n    for (let layoutInfo of layoutInfos) if (layoutInfo.rect.intersects(rectAtPoint)) key = layoutInfo.key;\n    if (key == null || this.virtualizer.collection.size === 0) return {\n      type: 'root'\n    };\n    let layoutInfo = this.getLayoutInfo(key);\n    if (!layoutInfo) return null;\n    let rect = layoutInfo.rect;\n    let target = {\n      type: 'item',\n      key: layoutInfo.key,\n      dropPosition: 'on'\n    };\n    // If dropping on the item isn't accepted, try the target before or after depending on the y position.\n    // Otherwise, if dropping on the item is accepted, still try the before/after positions if within 10px\n    // of the top or bottom of the item.\n    if (!isValidDropTarget(target)) {\n      if (y <= rect.y + rect.height / 2 && isValidDropTarget(_objectSpread(_objectSpread({}, target), {}, {\n        dropPosition: 'before'\n      }))) target.dropPosition = 'before';else if (isValidDropTarget(_objectSpread(_objectSpread({}, target), {}, {\n        dropPosition: 'after'\n      }))) target.dropPosition = 'after';\n    } else if (y <= rect.y + 10 && isValidDropTarget(_objectSpread(_objectSpread({}, target), {}, {\n      dropPosition: 'before'\n    }))) target.dropPosition = 'before';else if (y >= rect.maxY - 10 && isValidDropTarget(_objectSpread(_objectSpread({}, target), {}, {\n      dropPosition: 'after'\n    }))) target.dropPosition = 'after';\n    return target;\n  }\n  getDropTargetLayoutInfo(target) {\n    let layoutInfo = super.getDropTargetLayoutInfo(target);\n    layoutInfo.parentKey = this.virtualizer.collection.body.key;\n    return layoutInfo;\n  }\n  constructor(options) {\n    super(options), this.lastCollection = null, this.columnWidths = new Map(), this.lastPersistedKeys = null, this.persistedIndices = new Map();\n    this.stickyColumnIndices = [];\n  }\n}\nexport { $a152112e902709bf$export$62444c3c724b1b20 as TableLayout };","map":{"version":3,"names":["$a152112e902709bf$var$DEFAULT_ROW_HEIGHT","$a152112e902709bf$export$62444c3c724b1b20","$61ef60fc9b1041f4$export$cacbb3924155d68e","collection","virtualizer","columnsChanged","newCollection","oldCollection","columns","length","some","c","i","key","props","width","minWidth","maxWidth","update","invalidationContext","_invalidationContext_layoutOptions","layoutOptions","columnWidths","sizeChanged","lastCollection","columnLayout","$bmsJv$TableColumnLayout","buildColumnWidths","visibleRect","Map","buildCollection","stickyColumnIndices","column","isStickyColumn","rowHeaderColumnKeys","has","push","index","header","buildTableHeader","layoutNodes","set","layoutInfo","body","buildBody","rect","height","lastPersistedKeys","Math","max","contentSize","$bmsJv$Size","maxY","_collection_head","$bmsJv$Rect","_collection_head_key","$bmsJv$LayoutInfo","head","isSticky","zIndex","y","children","headerRow","headerRows","layoutNode","buildChild","parentKey","validRect","node","buildHeaderRow","x","row","cell","$bmsJv$getChildNodes","maxX","layout","entries","setChildHeights","child","copy","getRenderedColumnWidth","_node_colspan","colspan","_node_colIndex","colIndex","_this_columnWidths_get","get","getEstimatedHeight","estimatedHeight","isEstimated","previousLayoutNode","estimatedSize","getEstimatedRowHeight","_this_rowHeight","_ref","rowHeight","estimatedRowHeight","buildColumn","_this_headingHeight","_this_estimatedHeadingHeight","headingHeight","estimatedHeadingHeight","type","startY","skipped","requestedRect","isValid","size","intersection","buildNode","buildRow","buildCell","buildLoader","Error","getVisibleLayoutInfos","floor","ceil","layoutIfNeeded","res","buildPersistedIndices","rootNodes","addVisibleLayoutInfos","firstVisibleRow","binarySearch","topLeft","lastVisibleRow","bottomRight","persistedRowIndices","persistedIndices","persistIndex","idx","firstVisibleCell","lastVisibleCell","topRight","stickyIndex","persistedCellIndices","items","point","axis","low","high","mid","item","min","persistedKeys","clear","_this_layoutNodes_get","_this_layoutNodes_get1","_this_layoutNodes_get2","collectionNode","getItem","indices","includes","values","sort","a","b","getDropTargetFromPoint","isValidDropTarget","$bmsJv$Point","rectAtPoint","layoutInfos","filter","info","intersects","getLayoutInfo","target","dropPosition","_objectSpread","getDropTargetLayoutInfo","constructor","options"],"sources":["C:\\Users\\rewac\\OneDrive\\Documents\\GitHub\\scatch-store.me\\node_modules\\@react-stately\\layout\\dist\\packages\\@react-stately\\layout\\src\\TableLayout.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DropTarget, ItemDropTarget, Key} from '@react-types/shared';\nimport {getChildNodes} from '@react-stately/collections';\nimport {GridNode} from '@react-types/grid';\nimport {InvalidationContext, LayoutInfo, Point, Rect, Size} from '@react-stately/virtualizer';\nimport {LayoutNode, ListLayout, ListLayoutOptions} from './ListLayout';\nimport {TableCollection} from '@react-types/table';\nimport {TableColumnLayout} from '@react-stately/table';\n\nexport interface TableLayoutProps {\n  columnWidths?: Map<Key, number>\n}\n\nconst DEFAULT_ROW_HEIGHT = 48;\n\nexport class TableLayout<T, O extends TableLayoutProps = TableLayoutProps> extends ListLayout<T, O> {\n  protected lastCollection: TableCollection<T> | null = null;\n  private columnWidths: Map<Key, number> = new Map();\n  private stickyColumnIndices: number[];\n  private lastPersistedKeys: Set<Key> | null = null;\n  private persistedIndices: Map<Key, number[]> = new Map();\n\n  constructor(options: ListLayoutOptions) {\n    super(options);\n    this.stickyColumnIndices = [];\n  }\n\n  // Backward compatibility for subclassing.\n  protected get collection(): TableCollection<T> {\n    return this.virtualizer!.collection as TableCollection<T>;\n  }\n\n  private columnsChanged(newCollection: TableCollection<T>, oldCollection: TableCollection<T> | null) {\n    return !oldCollection ||\n      newCollection.columns !== oldCollection.columns &&\n      newCollection.columns.length !== oldCollection.columns.length ||\n      newCollection.columns.some((c, i) =>\n        c.key !== oldCollection.columns[i].key ||\n        c.props.width !== oldCollection.columns[i].props.width ||\n        c.props.minWidth !== oldCollection.columns[i].props.minWidth ||\n        c.props.maxWidth !== oldCollection.columns[i].props.maxWidth\n      );\n  }\n\n  update(invalidationContext: InvalidationContext<O>): void {\n    let newCollection = this.virtualizer!.collection as TableCollection<T>;\n\n    // If columnWidths were provided via layoutOptions, update those.\n    // Otherwise, calculate column widths ourselves.\n    if (invalidationContext.layoutOptions?.columnWidths) {\n      if (invalidationContext.layoutOptions.columnWidths !== this.columnWidths) {\n        this.columnWidths = invalidationContext.layoutOptions.columnWidths;\n        invalidationContext.sizeChanged = true;\n      }\n    } else if (invalidationContext.sizeChanged || this.columnsChanged(newCollection, this.lastCollection)) {\n      let columnLayout = new TableColumnLayout({});\n      this.columnWidths = columnLayout.buildColumnWidths(this.virtualizer!.visibleRect.width, newCollection, new Map());\n      invalidationContext.sizeChanged = true;\n    }\n\n    super.update(invalidationContext);\n  }\n\n  protected buildCollection(): LayoutNode[] {\n    this.stickyColumnIndices = [];\n\n    let collection = this.virtualizer!.collection as TableCollection<T>;\n    for (let column of collection.columns) {\n      // The selection cell and any other sticky columns always need to be visible.\n      // In addition, row headers need to be in the DOM for accessibility labeling.\n      if (this.isStickyColumn(column) || collection.rowHeaderColumnKeys.has(column.key)) {\n        this.stickyColumnIndices.push(column.index);\n      }\n    }\n\n    let header = this.buildTableHeader();\n    this.layoutNodes.set(header.layoutInfo.key, header);\n    let body = this.buildBody(header.layoutInfo.rect.height);\n    this.lastPersistedKeys = null;\n\n    body.layoutInfo.rect.width = Math.max(header.layoutInfo.rect.width, body.layoutInfo.rect.width);\n    this.contentSize = new Size(body.layoutInfo.rect.width, body.layoutInfo.rect.maxY);\n    return [\n      header,\n      body\n    ];\n  }\n\n  protected buildTableHeader(): LayoutNode {\n    let collection = this.virtualizer!.collection as TableCollection<T>;\n    let rect = new Rect(0, 0, 0, 0);\n    let layoutInfo = new LayoutInfo('header', collection.head?.key ?? 'header', rect);\n    layoutInfo.isSticky = true;\n    layoutInfo.zIndex = 1;\n\n    let y = 0;\n    let width = 0;\n    let children: LayoutNode[] = [];\n    for (let headerRow of collection.headerRows) {\n      let layoutNode = this.buildChild(headerRow, 0, y, layoutInfo.key);\n      layoutNode.layoutInfo.parentKey = layoutInfo.key;\n      y = layoutNode.layoutInfo.rect.maxY;\n      width = Math.max(width, layoutNode.layoutInfo.rect.width);\n      layoutNode.index = children.length;\n      children.push(layoutNode);\n    }\n\n    rect.width = width;\n    rect.height = y;\n\n    return {\n      layoutInfo,\n      children,\n      validRect: layoutInfo.rect,\n      node: collection.head\n    };\n  }\n\n  protected buildHeaderRow(headerRow: GridNode<T>, x: number, y: number): LayoutNode {\n    let rect = new Rect(0, y, 0, 0);\n    let row = new LayoutInfo('headerrow', headerRow.key, rect);\n\n    let height = 0;\n    let columns: LayoutNode[] = [];\n    for (let cell of getChildNodes(headerRow, this.virtualizer!.collection)) {\n      let layoutNode = this.buildChild(cell, x, y, row.key);\n      layoutNode.layoutInfo.parentKey = row.key;\n      x = layoutNode.layoutInfo.rect.maxX;\n      height = Math.max(height, layoutNode.layoutInfo.rect.height);\n      layoutNode.index = columns.length;\n      columns.push(layoutNode);\n    }\n    for (let [i, layout] of columns.entries()) {\n      layout.layoutInfo.zIndex = columns.length - i + 1;\n    }\n\n    this.setChildHeights(columns, height);\n\n    rect.height = height;\n    rect.width = x;\n\n    return {\n      layoutInfo: row,\n      children: columns,\n      validRect: rect,\n      node: headerRow\n    };\n  }\n\n  private setChildHeights(children: LayoutNode[], height: number) {\n    for (let child of children) {\n      if (child.layoutInfo.rect.height !== height) {\n        // Need to copy the layout info before we mutate it.\n        child.layoutInfo = child.layoutInfo.copy();\n        child.layoutInfo.rect.height = height;\n      }\n    }\n  }\n\n  // used to get the column widths when rendering to the DOM\n  private getRenderedColumnWidth(node: GridNode<T>) {\n    let collection = this.virtualizer!.collection as TableCollection<T>;\n    let colspan = node.colspan ?? 1;\n    let colIndex = node.colIndex ?? node.index;\n    let width = 0;\n    for (let i = colIndex; i < colIndex + colspan; i++) {\n      let column = collection.columns[i];\n      if (column?.key != null) {\n        width += this.columnWidths.get(column.key) ?? 0;\n      }\n    }\n\n    return width;\n  }\n\n  private getEstimatedHeight(node: GridNode<T>, width: number, height: number | null, estimatedHeight: number | null) {\n    let isEstimated = false;\n\n    // If no explicit height is available, use an estimated height.\n    if (height == null) {\n      // If a previous version of this layout info exists, reuse its height.\n      // Mark as estimated if the size of the overall collection view changed,\n      // or the content of the item changed.\n      let previousLayoutNode = this.layoutNodes.get(node.key);\n      if (previousLayoutNode) {\n        height = previousLayoutNode.layoutInfo.rect.height;\n        isEstimated = node !== previousLayoutNode.node || width !== previousLayoutNode.layoutInfo.rect.width || previousLayoutNode.layoutInfo.estimatedSize;\n      } else {\n        height = estimatedHeight ?? DEFAULT_ROW_HEIGHT;\n        isEstimated = true;\n      }\n    }\n\n    return {height, isEstimated};\n  }\n\n  protected getEstimatedRowHeight(): number {\n    return this.rowHeight ?? this.estimatedRowHeight ?? DEFAULT_ROW_HEIGHT;\n  }\n\n  protected buildColumn(node: GridNode<T>, x: number, y: number): LayoutNode {\n    let width = this.getRenderedColumnWidth(node);\n    let {height, isEstimated} = this.getEstimatedHeight(node, width, this.headingHeight ?? this.rowHeight, this.estimatedHeadingHeight ?? this.estimatedRowHeight);\n    let rect = new Rect(x, y, width, height);\n    let layoutInfo = new LayoutInfo(node.type, node.key, rect);\n    layoutInfo.isSticky = this.isStickyColumn(node);\n    layoutInfo.zIndex = layoutInfo.isSticky ? 2 : 1;\n    layoutInfo.estimatedSize = isEstimated;\n\n    return {\n      layoutInfo,\n      children: [],\n      validRect: layoutInfo.rect,\n      node\n    };\n  }\n\n  // For subclasses.\n  // eslint-disable-next-line\n  protected isStickyColumn(node: GridNode<T>) {\n    return false;\n  }\n\n  protected buildBody(y: number): LayoutNode {\n    let collection = this.virtualizer!.collection as TableCollection<T>;\n    let rect = new Rect(0, y, 0, 0);\n    let layoutInfo = new LayoutInfo('rowgroup', collection.body.key, rect);\n\n    let startY = y;\n    let skipped = 0;\n    let width = 0;\n    let children: LayoutNode[] = [];\n    let rowHeight = this.getEstimatedRowHeight();\n    for (let node of getChildNodes(collection.body, collection)) {\n      // Skip rows before the valid rectangle unless they are already cached.\n      if (y + rowHeight < this.requestedRect.y && !this.isValid(node, y)) {\n        y += rowHeight;\n        skipped++;\n        continue;\n      }\n\n      let layoutNode = this.buildChild(node, 0, y, layoutInfo.key);\n      layoutNode.layoutInfo.parentKey = layoutInfo.key;\n      layoutNode.index = children.length;\n      y = layoutNode.layoutInfo.rect.maxY;\n      width = Math.max(width, layoutNode.layoutInfo.rect.width);\n      children.push(layoutNode);\n\n      if (y > this.requestedRect.maxY) {\n        // Estimate the remaining height for rows that we don't need to layout right now.\n        y += (collection.size - (skipped + children.length)) * rowHeight;\n        break;\n      }\n    }\n\n    if (children.length === 0) {\n      y = this.virtualizer!.visibleRect.maxY;\n    }\n\n    rect.width = width;\n    rect.height = y - startY;\n\n    return {\n      layoutInfo,\n      children,\n      validRect: layoutInfo.rect.intersection(this.requestedRect),\n      node: collection.body\n    };\n  }\n\n  protected buildNode(node: GridNode<T>, x: number, y: number): LayoutNode {\n    switch (node.type) {\n      case 'headerrow':\n        return this.buildHeaderRow(node, x, y);\n      case 'item':\n        return this.buildRow(node, x, y);\n      case 'column':\n      case 'placeholder':\n        return this.buildColumn(node, x, y);\n      case 'cell':\n        return this.buildCell(node, x, y);\n      case 'loader':\n        return this.buildLoader(node, x, y);\n      default:\n        throw new Error('Unknown node type ' + node.type);\n    }\n  }\n\n  protected buildRow(node: GridNode<T>, x: number, y: number): LayoutNode {\n    let collection = this.virtualizer!.collection as TableCollection<T>;\n    let rect = new Rect(x, y, 0, 0);\n    let layoutInfo = new LayoutInfo('row', node.key, rect);\n\n    let children: LayoutNode[] = [];\n    let height = 0;\n    for (let child of getChildNodes(node, collection)) {\n      if (child.type === 'cell') {\n        if (x > this.requestedRect.maxX) {\n          // Adjust existing cached layoutInfo to ensure that it is out of view.\n          // This can happen due to column resizing.\n          let layoutNode = this.layoutNodes.get(child.key);\n          if (layoutNode) {\n            layoutNode.layoutInfo.rect.x = x;\n            x += layoutNode.layoutInfo.rect.width;\n          } else {\n            break;\n          }\n        } else {\n          let layoutNode = this.buildChild(child, x, y, layoutInfo.key);\n          x = layoutNode.layoutInfo.rect.maxX;\n          height = Math.max(height, layoutNode.layoutInfo.rect.height);\n          layoutNode.index = children.length;\n          children.push(layoutNode);\n        }\n      }\n    }\n\n    this.setChildHeights(children, height);\n\n    rect.width = this.layoutNodes.get(collection.head?.key ?? 'header')!.layoutInfo.rect.width;\n    rect.height = height;\n\n    return {\n      layoutInfo,\n      children,\n      validRect: rect.intersection(this.requestedRect),\n      node\n    };\n  }\n\n  protected buildCell(node: GridNode<T>, x: number, y: number): LayoutNode {\n    let width = this.getRenderedColumnWidth(node);\n    let {height, isEstimated} = this.getEstimatedHeight(node, width, this.rowHeight, this.estimatedRowHeight);\n    let rect = new Rect(x, y, width, height);\n    let layoutInfo = new LayoutInfo(node.type, node.key, rect);\n    layoutInfo.isSticky = this.isStickyColumn(node);\n    layoutInfo.zIndex = layoutInfo.isSticky ? 2 : 1;\n    layoutInfo.estimatedSize = isEstimated;\n\n    return {\n      layoutInfo,\n      children: [],\n      validRect: rect,\n      node\n    };\n  }\n\n  getVisibleLayoutInfos(rect: Rect) {\n    // Adjust rect to keep number of visible rows consistent.\n    // (only if height > 1 for getDropTargetFromPoint)\n    if (rect.height > 1) {\n      let rowHeight = this.getEstimatedRowHeight();\n      rect.y = Math.floor(rect.y / rowHeight) * rowHeight;\n      rect.height = Math.ceil(rect.height / rowHeight) * rowHeight;\n    }\n\n    // If layout hasn't yet been done for the requested rect, union the\n    // new rect with the existing valid rect, and recompute.\n    this.layoutIfNeeded(rect);\n\n    let res: LayoutInfo[] = [];\n\n    this.buildPersistedIndices();\n    for (let node of this.rootNodes) {\n      res.push(node.layoutInfo);\n      this.addVisibleLayoutInfos(res, node, rect);\n    }\n\n    return res;\n  }\n\n  private addVisibleLayoutInfos(res: LayoutInfo[], node: LayoutNode, rect: Rect) {\n    if (!node.children || node.children.length === 0) {\n      return;\n    }\n\n    switch (node.layoutInfo.type) {\n      case 'header': {\n        for (let child of node.children) {\n          res.push(child.layoutInfo);\n          this.addVisibleLayoutInfos(res, child, rect);\n        }\n        break;\n      }\n      case 'rowgroup': {\n        let firstVisibleRow = this.binarySearch(node.children, rect.topLeft, 'y');\n        let lastVisibleRow = this.binarySearch(node.children, rect.bottomRight, 'y');\n\n        // Add persisted rows before the visible rows.\n        let persistedRowIndices = this.persistedIndices.get(node.layoutInfo.key);\n        let persistIndex = 0;\n        while (\n          persistedRowIndices &&\n          persistIndex < persistedRowIndices.length &&\n          persistedRowIndices[persistIndex] < firstVisibleRow\n        ) {\n          let idx = persistedRowIndices[persistIndex];\n          if (idx < node.children.length) {\n            res.push(node.children[idx].layoutInfo);\n            this.addVisibleLayoutInfos(res, node.children[idx], rect);\n          }\n          persistIndex++;\n        }\n\n        for (let i = firstVisibleRow; i <= lastVisibleRow; i++) {\n          // Skip persisted rows that overlap with visible cells.\n          while (persistedRowIndices && persistIndex < persistedRowIndices.length && persistedRowIndices[persistIndex] < i) {\n            persistIndex++;\n          }\n\n          res.push(node.children[i].layoutInfo);\n          this.addVisibleLayoutInfos(res, node.children[i], rect);\n        }\n\n        // Add persisted rows after the visible rows.\n        while (persistedRowIndices && persistIndex < persistedRowIndices.length) {\n          let idx = persistedRowIndices[persistIndex++];\n          if (idx < node.children.length) {\n            res.push(node.children[idx].layoutInfo);\n            this.addVisibleLayoutInfos(res, node.children[idx], rect);\n          }\n        }\n        break;\n      }\n      case 'headerrow':\n      case 'row': {\n        let firstVisibleCell = this.binarySearch(node.children, rect.topLeft, 'x');\n        let lastVisibleCell = this.binarySearch(node.children, rect.topRight, 'x');\n        let stickyIndex = 0;\n\n        // Add persisted/sticky cells before the visible cells.\n        let persistedCellIndices = this.persistedIndices.get(node.layoutInfo.key) || this.stickyColumnIndices;\n        while (stickyIndex < persistedCellIndices.length && persistedCellIndices[stickyIndex] < firstVisibleCell) {\n          let idx = persistedCellIndices[stickyIndex];\n          if (idx < node.children.length) {\n            res.push(node.children[idx].layoutInfo);\n          }\n          stickyIndex++;\n        }\n\n        for (let i = firstVisibleCell; i <= lastVisibleCell; i++) {\n          // Skip sticky cells that overlap with visible cells.\n          while (stickyIndex < persistedCellIndices.length && persistedCellIndices[stickyIndex] < i) {\n            stickyIndex++;\n          }\n\n          res.push(node.children[i].layoutInfo);\n        }\n\n        // Add any remaining sticky cells after the visible cells.\n        while (stickyIndex < persistedCellIndices.length) {\n          let idx = persistedCellIndices[stickyIndex++];\n          if (idx < node.children.length) {\n            res.push(node.children[idx].layoutInfo);\n          }\n        }\n        break;\n      }\n      default:\n        throw new Error('Unknown node type ' + node.layoutInfo.type);\n    }\n  }\n\n  private binarySearch(items: LayoutNode[], point: Point, axis: 'x' | 'y') {\n    let low = 0;\n    let high = items.length - 1;\n    while (low <= high) {\n      let mid = (low + high) >> 1;\n      let item = items[mid];\n\n      if ((axis === 'x' && item.layoutInfo.rect.maxX <= point.x) || (axis === 'y' && item.layoutInfo.rect.maxY <= point.y)) {\n        low = mid + 1;\n      } else if ((axis === 'x' && item.layoutInfo.rect.x > point.x) || (axis === 'y' && item.layoutInfo.rect.y > point.y)) {\n        high = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n\n    return Math.max(0, Math.min(items.length - 1, low));\n  }\n\n  private buildPersistedIndices() {\n    if (this.virtualizer!.persistedKeys === this.lastPersistedKeys) {\n      return;\n    }\n\n    this.lastPersistedKeys = this.virtualizer!.persistedKeys;\n    this.persistedIndices.clear();\n\n    // Build a map of parentKey => indices of children to persist.\n    for (let key of this.virtualizer!.persistedKeys) {\n      let layoutInfo = this.layoutNodes.get(key)?.layoutInfo;\n\n      // Walk up ancestors so parents are also persisted if children are.\n      while (layoutInfo && layoutInfo.parentKey) {\n        let collectionNode = this.virtualizer!.collection.getItem(layoutInfo.key);\n        let indices = this.persistedIndices.get(layoutInfo.parentKey);\n        if (!indices) {\n          // stickyColumnIndices are always persisted along with any cells from persistedKeys.\n          indices = collectionNode?.type === 'cell' || collectionNode?.type === 'column' ? [...this.stickyColumnIndices] : [];\n          this.persistedIndices.set(layoutInfo.parentKey, indices);\n        }\n\n        let index = this.layoutNodes.get(layoutInfo.key)?.index;\n        if (index != null && !indices.includes(index)) {\n          indices.push(index);\n        }\n\n        layoutInfo = this.layoutNodes.get(layoutInfo.parentKey)?.layoutInfo;\n      }\n    }\n\n    for (let indices of this.persistedIndices.values()) {\n      indices.sort((a, b) => a - b);\n    }\n  }\n\n  getDropTargetFromPoint(x: number, y: number, isValidDropTarget: (target: DropTarget) => boolean): DropTarget | null {\n    x += this.virtualizer!.visibleRect.x;\n    y += this.virtualizer!.visibleRect.y;\n\n    // Custom variation of this.virtualizer.keyAtPoint that ignores body\n    let key: Key | null = null;\n    let point = new Point(x, y);\n    let rectAtPoint = new Rect(point.x, point.y, 1, 1);\n    let layoutInfos = this.virtualizer!.layout.getVisibleLayoutInfos(rectAtPoint).filter(info => info.type === 'row');\n\n    // Layout may return multiple layout infos in the case of\n    // persisted keys, so find the first one that actually intersects.\n    for (let layoutInfo of layoutInfos) {\n      if (layoutInfo.rect.intersects(rectAtPoint)) {\n        key = layoutInfo.key;\n      }\n    }\n\n    if (key == null || this.virtualizer!.collection.size === 0) {\n      return {type: 'root'};\n    }\n\n    let layoutInfo = this.getLayoutInfo(key);\n    if (!layoutInfo) {\n      return null;\n    }\n\n    let rect = layoutInfo.rect;\n    let target: DropTarget = {\n      type: 'item',\n      key: layoutInfo.key,\n      dropPosition: 'on'\n    };\n\n    // If dropping on the item isn't accepted, try the target before or after depending on the y position.\n    // Otherwise, if dropping on the item is accepted, still try the before/after positions if within 10px\n    // of the top or bottom of the item.\n    if (!isValidDropTarget(target)) {\n      if (y <= rect.y + rect.height / 2 && isValidDropTarget({...target, dropPosition: 'before'})) {\n        target.dropPosition = 'before';\n      } else if (isValidDropTarget({...target, dropPosition: 'after'})) {\n        target.dropPosition = 'after';\n      }\n    } else if (y <= rect.y + 10 && isValidDropTarget({...target, dropPosition: 'before'})) {\n      target.dropPosition = 'before';\n    } else if (y >= rect.maxY - 10 && isValidDropTarget({...target, dropPosition: 'after'})) {\n      target.dropPosition = 'after';\n    }\n\n    return target;\n  }\n\n  getDropTargetLayoutInfo(target: ItemDropTarget): LayoutInfo {\n    let layoutInfo = super.getDropTargetLayoutInfo(target);\n    layoutInfo.parentKey = (this.virtualizer!.collection as TableCollection<T>).body.key;\n    return layoutInfo;\n  }\n}\n"],"mappings":";;;;;;AAAA;;;;;;;;;;;;AAwBA,MAAMA,wCAAA,GAAqB;AAEpB,MAAMC,yCAAA,UAAsE,GAAAC,yCAAS;EAY1F;EACA,IAAcC,WAAA,EAAiC;IAC7C,OAAO,IAAI,CAACC,WAAW,CAAED,UAAU;EACrC;EAEQE,eAAeC,aAAiC,EAAEC,aAAwC,EAAE;IAClG,OAAO,CAACA,aAAA,IACND,aAAA,CAAcE,OAAO,KAAKD,aAAA,CAAcC,OAAO,IAC/CF,aAAA,CAAcE,OAAO,CAACC,MAAM,KAAKF,aAAA,CAAcC,OAAO,CAACC,MAAM,IAC7DH,aAAA,CAAcE,OAAO,CAACE,IAAI,CAAC,CAACC,CAAA,EAAGC,CAAA,KAC7BD,CAAA,CAAEE,GAAG,KAAKN,aAAA,CAAcC,OAAO,CAACI,CAAA,CAAE,CAACC,GAAG,IACtCF,CAAA,CAAEG,KAAK,CAACC,KAAK,KAAKR,aAAA,CAAcC,OAAO,CAACI,CAAA,CAAE,CAACE,KAAK,CAACC,KAAK,IACtDJ,CAAA,CAAEG,KAAK,CAACE,QAAQ,KAAKT,aAAA,CAAcC,OAAO,CAACI,CAAA,CAAE,CAACE,KAAK,CAACE,QAAQ,IAC5DL,CAAA,CAAEG,KAAK,CAACG,QAAQ,KAAKV,aAAA,CAAcC,OAAO,CAACI,CAAA,CAAE,CAACE,KAAK,CAACG,QAAQ;EAElE;EAEAC,OAAOC,mBAA2C,EAAQ;QAKpDC,kCAAA;IAJJ,IAAId,aAAA,GAAgB,IAAI,CAACF,WAAW,CAAED,UAAU;IAEhD;IACA;IACA,KAAIiB,kCAAA,GAAAD,mBAAA,CAAoBE,aAAa,cAAjCD,kCAAA,uBAAAA,kCAAA,CAAmCE,YAAY,EACjD;MAAA,IAAIH,mBAAA,CAAoBE,aAAa,CAACC,YAAY,KAAK,IAAI,CAACA,YAAY,EAAE;QACxE,IAAI,CAACA,YAAY,GAAGH,mBAAA,CAAoBE,aAAa,CAACC,YAAY;QAClEH,mBAAA,CAAoBI,WAAW,GAAG;MACpC;IAAA,OACK,IAAIJ,mBAAA,CAAoBI,WAAW,IAAI,IAAI,CAAClB,cAAc,CAACC,aAAA,EAAe,IAAI,CAACkB,cAAc,GAAG;MACrG,IAAIC,YAAA,GAAe,KAAI,GAAAC,wBAAgB,EAAE,CAAC;MAC1C,IAAI,CAACJ,YAAY,GAAGG,YAAA,CAAaE,iBAAiB,CAAC,IAAI,CAACvB,WAAW,CAAEwB,WAAW,CAACb,KAAK,EAAET,aAAA,EAAe,IAAIuB,GAAA;MAC3GV,mBAAA,CAAoBI,WAAW,GAAG;IACpC;IAEA,KAAK,CAACL,MAAA,CAAOC,mBAAA;EACf;EAEUW,gBAAA,EAAgC;IACxC,IAAI,CAACC,mBAAmB,GAAG,EAAE;IAE7B,IAAI5B,UAAA,GAAa,IAAI,CAACC,WAAW,CAAED,UAAU;IAC7C,KAAK,IAAI6B,MAAA,IAAU7B,UAAA,CAAWK,OAAO;IACnC;IACA;IACA,IAAI,IAAI,CAACyB,cAAc,CAACD,MAAA,KAAW7B,UAAA,CAAW+B,mBAAmB,CAACC,GAAG,CAACH,MAAA,CAAOnB,GAAG,GAC9E,IAAI,CAACkB,mBAAmB,CAACK,IAAI,CAACJ,MAAA,CAAOK,KAAK;IAI9C,IAAIC,MAAA,GAAS,IAAI,CAACC,gBAAgB;IAClC,IAAI,CAACC,WAAW,CAACC,GAAG,CAACH,MAAA,CAAOI,UAAU,CAAC7B,GAAG,EAAEyB,MAAA;IAC5C,IAAIK,IAAA,GAAO,IAAI,CAACC,SAAS,CAACN,MAAA,CAAOI,UAAU,CAACG,IAAI,CAACC,MAAM;IACvD,IAAI,CAACC,iBAAiB,GAAG;IAEzBJ,IAAA,CAAKD,UAAU,CAACG,IAAI,CAAC9B,KAAK,GAAGiC,IAAA,CAAKC,GAAG,CAACX,MAAA,CAAOI,UAAU,CAACG,IAAI,CAAC9B,KAAK,EAAE4B,IAAA,CAAKD,UAAU,CAACG,IAAI,CAAC9B,KAAK;IAC9F,IAAI,CAACmC,WAAW,GAAG,KAAI,GAAAC,WAAG,EAAER,IAAA,CAAKD,UAAU,CAACG,IAAI,CAAC9B,KAAK,EAAE4B,IAAA,CAAKD,UAAU,CAACG,IAAI,CAACO,IAAI;IACjF,OAAO,CACLd,MAAA,EACAK,IAAA,CACD;EACH;EAEUJ,iBAAA,EAA+B;QAGGc,gBAAA;IAF1C,IAAIlD,UAAA,GAAa,IAAI,CAACC,WAAW,CAAED,UAAU;IAC7C,IAAI0C,IAAA,GAAO,KAAI,GAAAS,WAAG,EAAE,GAAG,GAAG,GAAG;QACaC,oBAAA;IAA1C,IAAIb,UAAA,GAAa,KAAI,GAAAc,iBAAS,EAAE,UAAU,CAAAD,oBAAA,IAAAF,gBAAA,GAAAlD,UAAA,CAAWsD,IAAI,cAAfJ,gBAAA,uBAAAA,gBAAA,CAAiBxC,GAAG,cAApB0C,oBAAA,cAAAA,oBAAA,GAAwB,UAAUV,IAAA;IAC5EH,UAAA,CAAWgB,QAAQ,GAAG;IACtBhB,UAAA,CAAWiB,MAAM,GAAG;IAEpB,IAAIC,CAAA,GAAI;IACR,IAAI7C,KAAA,GAAQ;IACZ,IAAI8C,QAAA,GAAyB,EAAE;IAC/B,KAAK,IAAIC,SAAA,IAAa3D,UAAA,CAAW4D,UAAU,EAAE;MAC3C,IAAIC,UAAA,GAAa,IAAI,CAACC,UAAU,CAACH,SAAA,EAAW,GAAGF,CAAA,EAAGlB,UAAA,CAAW7B,GAAG;MAChEmD,UAAA,CAAWtB,UAAU,CAACwB,SAAS,GAAGxB,UAAA,CAAW7B,GAAG;MAChD+C,CAAA,GAAII,UAAA,CAAWtB,UAAU,CAACG,IAAI,CAACO,IAAI;MACnCrC,KAAA,GAAQiC,IAAA,CAAKC,GAAG,CAAClC,KAAA,EAAOiD,UAAA,CAAWtB,UAAU,CAACG,IAAI,CAAC9B,KAAK;MACxDiD,UAAA,CAAW3B,KAAK,GAAGwB,QAAA,CAASpD,MAAM;MAClCoD,QAAA,CAASzB,IAAI,CAAC4B,UAAA;IAChB;IAEAnB,IAAA,CAAK9B,KAAK,GAAGA,KAAA;IACb8B,IAAA,CAAKC,MAAM,GAAGc,CAAA;IAEd,OAAO;kBACLlB,UAAA;gBACAmB,QAAA;MACAM,SAAA,EAAWzB,UAAA,CAAWG,IAAI;MAC1BuB,IAAA,EAAMjE,UAAA,CAAWsD;IACnB;EACF;EAEUY,eAAeP,SAAsB,EAAEQ,CAAS,EAAEV,CAAS,EAAc;IACjF,IAAIf,IAAA,GAAO,KAAI,GAAAS,WAAG,EAAE,GAAGM,CAAA,EAAG,GAAG;IAC7B,IAAIW,GAAA,GAAM,KAAI,GAAAf,iBAAS,EAAE,aAAaM,SAAA,CAAUjD,GAAG,EAAEgC,IAAA;IAErD,IAAIC,MAAA,GAAS;IACb,IAAItC,OAAA,GAAwB,EAAE;IAC9B,KAAK,IAAIgE,IAAA,IAAQ,IAAAC,oBAAY,EAAEX,SAAA,EAAW,IAAI,CAAC1D,WAAW,CAAED,UAAU,GAAG;MACvE,IAAI6D,UAAA,GAAa,IAAI,CAACC,UAAU,CAACO,IAAA,EAAMF,CAAA,EAAGV,CAAA,EAAGW,GAAA,CAAI1D,GAAG;MACpDmD,UAAA,CAAWtB,UAAU,CAACwB,SAAS,GAAGK,GAAA,CAAI1D,GAAG;MACzCyD,CAAA,GAAIN,UAAA,CAAWtB,UAAU,CAACG,IAAI,CAAC6B,IAAI;MACnC5B,MAAA,GAASE,IAAA,CAAKC,GAAG,CAACH,MAAA,EAAQkB,UAAA,CAAWtB,UAAU,CAACG,IAAI,CAACC,MAAM;MAC3DkB,UAAA,CAAW3B,KAAK,GAAG7B,OAAA,CAAQC,MAAM;MACjCD,OAAA,CAAQ4B,IAAI,CAAC4B,UAAA;IACf;IACA,KAAK,IAAI,CAACpD,CAAA,EAAG+D,MAAA,CAAO,IAAInE,OAAA,CAAQoE,OAAO,IACrCD,MAAA,CAAOjC,UAAU,CAACiB,MAAM,GAAGnD,OAAA,CAAQC,MAAM,GAAGG,CAAA,GAAI;IAGlD,IAAI,CAACiE,eAAe,CAACrE,OAAA,EAASsC,MAAA;IAE9BD,IAAA,CAAKC,MAAM,GAAGA,MAAA;IACdD,IAAA,CAAK9B,KAAK,GAAGuD,CAAA;IAEb,OAAO;MACL5B,UAAA,EAAY6B,GAAA;MACZV,QAAA,EAAUrD,OAAA;MACV2D,SAAA,EAAWtB,IAAA;MACXuB,IAAA,EAAMN;IACR;EACF;EAEQe,gBAAgBhB,QAAsB,EAAEf,MAAc,EAAE;IAC9D,KAAK,IAAIgC,KAAA,IAASjB,QAAA,EAChB,IAAIiB,KAAA,CAAMpC,UAAU,CAACG,IAAI,CAACC,MAAM,KAAKA,MAAA,EAAQ;MAC3C;MACAgC,KAAA,CAAMpC,UAAU,GAAGoC,KAAA,CAAMpC,UAAU,CAACqC,IAAI;MACxCD,KAAA,CAAMpC,UAAU,CAACG,IAAI,CAACC,MAAM,GAAGA,MAAA;IACjC;EAEJ;EAEA;EACQkC,uBAAuBZ,IAAiB,EAAE;IAChD,IAAIjE,UAAA,GAAa,IAAI,CAACC,WAAW,CAAED,UAAU;QAC/B8E,aAAA;IAAd,IAAIC,OAAA,GAAU,CAAAD,aAAA,GAAAb,IAAA,CAAKc,OAAO,cAAZD,aAAA,cAAAA,aAAA,GAAgB;QACfE,cAAA;IAAf,IAAIC,QAAA,GAAW,CAAAD,cAAA,GAAAf,IAAA,CAAKgB,QAAQ,cAAbD,cAAA,cAAAA,cAAA,GAAiBf,IAAA,CAAK/B,KAAK;IAC1C,IAAItB,KAAA,GAAQ;IACZ,KAAK,IAAIH,CAAA,GAAIwE,QAAA,EAAUxE,CAAA,GAAIwE,QAAA,GAAWF,OAAA,EAAStE,CAAA,IAAK;MAClD,IAAIoB,MAAA,GAAS7B,UAAA,CAAWK,OAAO,CAACI,CAAA,CAAE;UAEvByE,sBAAA;MADX,IAAI,CAAArD,MAAA,aAAAA,MAAA,uBAAAA,MAAA,CAAQnB,GAAG,KAAI,MACjBE,KAAA,IAAS,CAAAsE,sBAAA,OAAI,CAAC/D,YAAY,CAACgE,GAAG,CAACtD,MAAA,CAAOnB,GAAG,eAAhCwE,sBAAA,cAAAA,sBAAA,GAAqC;IAElD;IAEA,OAAOtE,KAAA;EACT;EAEQwE,mBAAmBnB,IAAiB,EAAErD,KAAa,EAAE+B,MAAqB,EAAE0C,eAA8B,EAAE;IAClH,IAAIC,WAAA,GAAc;IAElB;IACA,IAAI3C,MAAA,IAAU,MAAM;MAClB;MACA;MACA;MACA,IAAI4C,kBAAA,GAAqB,IAAI,CAAClD,WAAW,CAAC8C,GAAG,CAAClB,IAAA,CAAKvD,GAAG;MACtD,IAAI6E,kBAAA,EAAoB;QACtB5C,MAAA,GAAS4C,kBAAA,CAAmBhD,UAAU,CAACG,IAAI,CAACC,MAAM;QAClD2C,WAAA,GAAcrB,IAAA,KAASsB,kBAAA,CAAmBtB,IAAI,IAAIrD,KAAA,KAAU2E,kBAAA,CAAmBhD,UAAU,CAACG,IAAI,CAAC9B,KAAK,IAAI2E,kBAAA,CAAmBhD,UAAU,CAACiD,aAAa;MACrJ,OAAO;QACL7C,MAAA,GAAS0C,eAAA,aAAAA,eAAA,cAAAA,eAAA,GAAmBxF,wCAAA;QAC5ByF,WAAA,GAAc;MAChB;IACF;IAEA,OAAO;cAAC3C,MAAA;mBAAQ2C;IAAW;EAC7B;EAEUG,sBAAA,EAAgC;QACjCC,eAAA,EAAAC,IAAA;IAAP,OAAO,CAAAA,IAAA,IAAAD,eAAA,OAAI,CAACE,SAAS,cAAdF,eAAA,cAAAA,eAAA,GAAkB,IAAI,CAACG,kBAAkB,cAAzCF,IAAA,cAAAA,IAAA,GAA6C9F,wCAAA;EACtD;EAEUiG,YAAY7B,IAAiB,EAAEE,CAAS,EAAEV,CAAS,EAAc;IACzE,IAAI7C,KAAA,GAAQ,IAAI,CAACiE,sBAAsB,CAACZ,IAAA;QACyB8B,mBAAA,EAAsCC,4BAAA;IAAvG,IAAI;MAAArD,MAAA,EAACA,MAAM;MAAA2C,WAAA,EAAEA;IAAW,CAAC,GAAG,IAAI,CAACF,kBAAkB,CAACnB,IAAA,EAAMrD,KAAA,EAAO,CAAAmF,mBAAA,OAAI,CAACE,aAAa,cAAlBF,mBAAA,cAAAA,mBAAA,GAAsB,IAAI,CAACH,SAAS,EAAE,CAAAI,4BAAA,OAAI,CAACE,sBAAsB,cAA3BF,4BAAA,cAAAA,4BAAA,GAA+B,IAAI,CAACH,kBAAkB;IAC7J,IAAInD,IAAA,GAAO,KAAI,GAAAS,WAAG,EAAEgB,CAAA,EAAGV,CAAA,EAAG7C,KAAA,EAAO+B,MAAA;IACjC,IAAIJ,UAAA,GAAa,KAAI,GAAAc,iBAAS,EAAEY,IAAA,CAAKkC,IAAI,EAAElC,IAAA,CAAKvD,GAAG,EAAEgC,IAAA;IACrDH,UAAA,CAAWgB,QAAQ,GAAG,IAAI,CAACzB,cAAc,CAACmC,IAAA;IAC1C1B,UAAA,CAAWiB,MAAM,GAAGjB,UAAA,CAAWgB,QAAQ,GAAG,IAAI;IAC9ChB,UAAA,CAAWiD,aAAa,GAAGF,WAAA;IAE3B,OAAO;kBACL/C,UAAA;MACAmB,QAAA,EAAU,EAAE;MACZM,SAAA,EAAWzB,UAAA,CAAWG,IAAI;YAC1BuB;IACF;EACF;EAEA;EACA;EACUnC,eAAemC,IAAiB,EAAE;IAC1C,OAAO;EACT;EAEUxB,UAAUgB,CAAS,EAAc;IACzC,IAAIzD,UAAA,GAAa,IAAI,CAACC,WAAW,CAAED,UAAU;IAC7C,IAAI0C,IAAA,GAAO,KAAI,GAAAS,WAAG,EAAE,GAAGM,CAAA,EAAG,GAAG;IAC7B,IAAIlB,UAAA,GAAa,KAAI,GAAAc,iBAAS,EAAE,YAAYrD,UAAA,CAAWwC,IAAI,CAAC9B,GAAG,EAAEgC,IAAA;IAEjE,IAAI0D,MAAA,GAAS3C,CAAA;IACb,IAAI4C,OAAA,GAAU;IACd,IAAIzF,KAAA,GAAQ;IACZ,IAAI8C,QAAA,GAAyB,EAAE;IAC/B,IAAIkC,SAAA,GAAY,IAAI,CAACH,qBAAqB;IAC1C,KAAK,IAAIxB,IAAA,IAAQ,IAAAK,oBAAY,EAAEtE,UAAA,CAAWwC,IAAI,EAAExC,UAAA,GAAa;MAC3D;MACA,IAAIyD,CAAA,GAAImC,SAAA,GAAY,IAAI,CAACU,aAAa,CAAC7C,CAAC,IAAI,CAAC,IAAI,CAAC8C,OAAO,CAACtC,IAAA,EAAMR,CAAA,GAAI;QAClEA,CAAA,IAAKmC,SAAA;QACLS,OAAA;QACA;MACF;MAEA,IAAIxC,UAAA,GAAa,IAAI,CAACC,UAAU,CAACG,IAAA,EAAM,GAAGR,CAAA,EAAGlB,UAAA,CAAW7B,GAAG;MAC3DmD,UAAA,CAAWtB,UAAU,CAACwB,SAAS,GAAGxB,UAAA,CAAW7B,GAAG;MAChDmD,UAAA,CAAW3B,KAAK,GAAGwB,QAAA,CAASpD,MAAM;MAClCmD,CAAA,GAAII,UAAA,CAAWtB,UAAU,CAACG,IAAI,CAACO,IAAI;MACnCrC,KAAA,GAAQiC,IAAA,CAAKC,GAAG,CAAClC,KAAA,EAAOiD,UAAA,CAAWtB,UAAU,CAACG,IAAI,CAAC9B,KAAK;MACxD8C,QAAA,CAASzB,IAAI,CAAC4B,UAAA;MAEd,IAAIJ,CAAA,GAAI,IAAI,CAAC6C,aAAa,CAACrD,IAAI,EAAE;QAC/B;QACAQ,CAAA,IAAK,CAACzD,UAAA,CAAWwG,IAAI,IAAIH,OAAA,GAAU3C,QAAA,CAASpD,MAAM,KAAKsF,SAAA;QACvD;MACF;IACF;IAEA,IAAIlC,QAAA,CAASpD,MAAM,KAAK,GACtBmD,CAAA,GAAI,IAAI,CAACxD,WAAW,CAAEwB,WAAW,CAACwB,IAAI;IAGxCP,IAAA,CAAK9B,KAAK,GAAGA,KAAA;IACb8B,IAAA,CAAKC,MAAM,GAAGc,CAAA,GAAI2C,MAAA;IAElB,OAAO;kBACL7D,UAAA;gBACAmB,QAAA;MACAM,SAAA,EAAWzB,UAAA,CAAWG,IAAI,CAAC+D,YAAY,CAAC,IAAI,CAACH,aAAa;MAC1DrC,IAAA,EAAMjE,UAAA,CAAWwC;IACnB;EACF;EAEUkE,UAAUzC,IAAiB,EAAEE,CAAS,EAAEV,CAAS,EAAc;IACvE,QAAQQ,IAAA,CAAKkC,IAAI;MACf,KAAK;QACH,OAAO,IAAI,CAACjC,cAAc,CAACD,IAAA,EAAME,CAAA,EAAGV,CAAA;MACtC,KAAK;QACH,OAAO,IAAI,CAACkD,QAAQ,CAAC1C,IAAA,EAAME,CAAA,EAAGV,CAAA;MAChC,KAAK;MACL,KAAK;QACH,OAAO,IAAI,CAACqC,WAAW,CAAC7B,IAAA,EAAME,CAAA,EAAGV,CAAA;MACnC,KAAK;QACH,OAAO,IAAI,CAACmD,SAAS,CAAC3C,IAAA,EAAME,CAAA,EAAGV,CAAA;MACjC,KAAK;QACH,OAAO,IAAI,CAACoD,WAAW,CAAC5C,IAAA,EAAME,CAAA,EAAGV,CAAA;MACnC;QACE,MAAM,IAAIqD,KAAA,CAAM,uBAAuB7C,IAAA,CAAKkC,IAAI;IACpD;EACF;EAEUQ,SAAS1C,IAAiB,EAAEE,CAAS,EAAEV,CAAS,EAAc;QA+BpCP,gBAAA;IA9BlC,IAAIlD,UAAA,GAAa,IAAI,CAACC,WAAW,CAAED,UAAU;IAC7C,IAAI0C,IAAA,GAAO,KAAI,GAAAS,WAAG,EAAEgB,CAAA,EAAGV,CAAA,EAAG,GAAG;IAC7B,IAAIlB,UAAA,GAAa,KAAI,GAAAc,iBAAS,EAAE,OAAOY,IAAA,CAAKvD,GAAG,EAAEgC,IAAA;IAEjD,IAAIgB,QAAA,GAAyB,EAAE;IAC/B,IAAIf,MAAA,GAAS;IACb,KAAK,IAAIgC,KAAA,IAAS,IAAAL,oBAAY,EAAEL,IAAA,EAAMjE,UAAA,GACpC,IAAI2E,KAAA,CAAMwB,IAAI,KAAK;MACjB,IAAIhC,CAAA,GAAI,IAAI,CAACmC,aAAa,CAAC/B,IAAI,EAAE;QAC/B;QACA;QACA,IAAIV,UAAA,GAAa,IAAI,CAACxB,WAAW,CAAC8C,GAAG,CAACR,KAAA,CAAMjE,GAAG;QAC/C,IAAImD,UAAA,EAAY;UACdA,UAAA,CAAWtB,UAAU,CAACG,IAAI,CAACyB,CAAC,GAAGA,CAAA;UAC/BA,CAAA,IAAKN,UAAA,CAAWtB,UAAU,CAACG,IAAI,CAAC9B,KAAK;QACvC,OACE;MAEJ,OAAO;QACL,IAAIiD,UAAA,GAAa,IAAI,CAACC,UAAU,CAACa,KAAA,EAAOR,CAAA,EAAGV,CAAA,EAAGlB,UAAA,CAAW7B,GAAG;QAC5DyD,CAAA,GAAIN,UAAA,CAAWtB,UAAU,CAACG,IAAI,CAAC6B,IAAI;QACnC5B,MAAA,GAASE,IAAA,CAAKC,GAAG,CAACH,MAAA,EAAQkB,UAAA,CAAWtB,UAAU,CAACG,IAAI,CAACC,MAAM;QAC3DkB,UAAA,CAAW3B,KAAK,GAAGwB,QAAA,CAASpD,MAAM;QAClCoD,QAAA,CAASzB,IAAI,CAAC4B,UAAA;MAChB;;IAIJ,IAAI,CAACa,eAAe,CAAChB,QAAA,EAAUf,MAAA;QAEGS,oBAAA;IAAlCV,IAAA,CAAK9B,KAAK,GAAG,IAAI,CAACyB,WAAW,CAAC8C,GAAG,CAAC,CAAA/B,oBAAA,IAAAF,gBAAA,GAAAlD,UAAA,CAAWsD,IAAI,cAAfJ,gBAAA,uBAAAA,gBAAA,CAAiBxC,GAAG,cAApB0C,oBAAA,cAAAA,oBAAA,GAAwB,UAAWb,UAAU,CAACG,IAAI,CAAC9B,KAAK;IAC1F8B,IAAA,CAAKC,MAAM,GAAGA,MAAA;IAEd,OAAO;kBACLJ,UAAA;gBACAmB,QAAA;MACAM,SAAA,EAAWtB,IAAA,CAAK+D,YAAY,CAAC,IAAI,CAACH,aAAa;YAC/CrC;IACF;EACF;EAEU2C,UAAU3C,IAAiB,EAAEE,CAAS,EAAEV,CAAS,EAAc;IACvE,IAAI7C,KAAA,GAAQ,IAAI,CAACiE,sBAAsB,CAACZ,IAAA;IACxC,IAAI;MAAAtB,MAAA,EAACA,MAAM;MAAA2C,WAAA,EAAEA;IAAW,CAAC,GAAG,IAAI,CAACF,kBAAkB,CAACnB,IAAA,EAAMrD,KAAA,EAAO,IAAI,CAACgF,SAAS,EAAE,IAAI,CAACC,kBAAkB;IACxG,IAAInD,IAAA,GAAO,KAAI,GAAAS,WAAG,EAAEgB,CAAA,EAAGV,CAAA,EAAG7C,KAAA,EAAO+B,MAAA;IACjC,IAAIJ,UAAA,GAAa,KAAI,GAAAc,iBAAS,EAAEY,IAAA,CAAKkC,IAAI,EAAElC,IAAA,CAAKvD,GAAG,EAAEgC,IAAA;IACrDH,UAAA,CAAWgB,QAAQ,GAAG,IAAI,CAACzB,cAAc,CAACmC,IAAA;IAC1C1B,UAAA,CAAWiB,MAAM,GAAGjB,UAAA,CAAWgB,QAAQ,GAAG,IAAI;IAC9ChB,UAAA,CAAWiD,aAAa,GAAGF,WAAA;IAE3B,OAAO;kBACL/C,UAAA;MACAmB,QAAA,EAAU,EAAE;MACZM,SAAA,EAAWtB,IAAA;YACXuB;IACF;EACF;EAEA8C,sBAAsBrE,IAAU,EAAE;IAChC;IACA;IACA,IAAIA,IAAA,CAAKC,MAAM,GAAG,GAAG;MACnB,IAAIiD,SAAA,GAAY,IAAI,CAACH,qBAAqB;MAC1C/C,IAAA,CAAKe,CAAC,GAAGZ,IAAA,CAAKmE,KAAK,CAACtE,IAAA,CAAKe,CAAC,GAAGmC,SAAA,IAAaA,SAAA;MAC1ClD,IAAA,CAAKC,MAAM,GAAGE,IAAA,CAAKoE,IAAI,CAACvE,IAAA,CAAKC,MAAM,GAAGiD,SAAA,IAAaA,SAAA;IACrD;IAEA;IACA;IACA,IAAI,CAACsB,cAAc,CAACxE,IAAA;IAEpB,IAAIyE,GAAA,GAAoB,EAAE;IAE1B,IAAI,CAACC,qBAAqB;IAC1B,KAAK,IAAInD,IAAA,IAAQ,IAAI,CAACoD,SAAS,EAAE;MAC/BF,GAAA,CAAIlF,IAAI,CAACgC,IAAA,CAAK1B,UAAU;MACxB,IAAI,CAAC+E,qBAAqB,CAACH,GAAA,EAAKlD,IAAA,EAAMvB,IAAA;IACxC;IAEA,OAAOyE,GAAA;EACT;EAEQG,sBAAsBH,GAAiB,EAAElD,IAAgB,EAAEvB,IAAU,EAAE;IAC7E,IAAI,CAACuB,IAAA,CAAKP,QAAQ,IAAIO,IAAA,CAAKP,QAAQ,CAACpD,MAAM,KAAK,GAC7C;IAGF,QAAQ2D,IAAA,CAAK1B,UAAU,CAAC4D,IAAI;MAC1B,KAAK;QACH,KAAK,IAAIxB,KAAA,IAASV,IAAA,CAAKP,QAAQ,EAAE;UAC/ByD,GAAA,CAAIlF,IAAI,CAAC0C,KAAA,CAAMpC,UAAU;UACzB,IAAI,CAAC+E,qBAAqB,CAACH,GAAA,EAAKxC,KAAA,EAAOjC,IAAA;QACzC;QACA;MAEF,KAAK;QAAY;UACf,IAAI6E,eAAA,GAAkB,IAAI,CAACC,YAAY,CAACvD,IAAA,CAAKP,QAAQ,EAAEhB,IAAA,CAAK+E,OAAO,EAAE;UACrE,IAAIC,cAAA,GAAiB,IAAI,CAACF,YAAY,CAACvD,IAAA,CAAKP,QAAQ,EAAEhB,IAAA,CAAKiF,WAAW,EAAE;UAExE;UACA,IAAIC,mBAAA,GAAsB,IAAI,CAACC,gBAAgB,CAAC1C,GAAG,CAAClB,IAAA,CAAK1B,UAAU,CAAC7B,GAAG;UACvE,IAAIoH,YAAA,GAAe;UACnB,OACEF,mBAAA,IACAE,YAAA,GAAeF,mBAAA,CAAoBtH,MAAM,IACzCsH,mBAAmB,CAACE,YAAA,CAAa,GAAGP,eAAA,EACpC;YACA,IAAIQ,GAAA,GAAMH,mBAAmB,CAACE,YAAA,CAAa;YAC3C,IAAIC,GAAA,GAAM9D,IAAA,CAAKP,QAAQ,CAACpD,MAAM,EAAE;cAC9B6G,GAAA,CAAIlF,IAAI,CAACgC,IAAA,CAAKP,QAAQ,CAACqE,GAAA,CAAI,CAACxF,UAAU;cACtC,IAAI,CAAC+E,qBAAqB,CAACH,GAAA,EAAKlD,IAAA,CAAKP,QAAQ,CAACqE,GAAA,CAAI,EAAErF,IAAA;YACtD;YACAoF,YAAA;UACF;UAEA,KAAK,IAAIrH,CAAA,GAAI8G,eAAA,EAAiB9G,CAAA,IAAKiH,cAAA,EAAgBjH,CAAA,IAAK;YACtD;YACA,OAAOmH,mBAAA,IAAuBE,YAAA,GAAeF,mBAAA,CAAoBtH,MAAM,IAAIsH,mBAAmB,CAACE,YAAA,CAAa,GAAGrH,CAAA,EAC7GqH,YAAA;YAGFX,GAAA,CAAIlF,IAAI,CAACgC,IAAA,CAAKP,QAAQ,CAACjD,CAAA,CAAE,CAAC8B,UAAU;YACpC,IAAI,CAAC+E,qBAAqB,CAACH,GAAA,EAAKlD,IAAA,CAAKP,QAAQ,CAACjD,CAAA,CAAE,EAAEiC,IAAA;UACpD;UAEA;UACA,OAAOkF,mBAAA,IAAuBE,YAAA,GAAeF,mBAAA,CAAoBtH,MAAM,EAAE;YACvE,IAAIyH,GAAA,GAAMH,mBAAmB,CAACE,YAAA,GAAe;YAC7C,IAAIC,GAAA,GAAM9D,IAAA,CAAKP,QAAQ,CAACpD,MAAM,EAAE;cAC9B6G,GAAA,CAAIlF,IAAI,CAACgC,IAAA,CAAKP,QAAQ,CAACqE,GAAA,CAAI,CAACxF,UAAU;cACtC,IAAI,CAAC+E,qBAAqB,CAACH,GAAA,EAAKlD,IAAA,CAAKP,QAAQ,CAACqE,GAAA,CAAI,EAAErF,IAAA;YACtD;UACF;UACA;QACF;MACA,KAAK;MACL,KAAK;QAAO;UACV,IAAIsF,gBAAA,GAAmB,IAAI,CAACR,YAAY,CAACvD,IAAA,CAAKP,QAAQ,EAAEhB,IAAA,CAAK+E,OAAO,EAAE;UACtE,IAAIQ,eAAA,GAAkB,IAAI,CAACT,YAAY,CAACvD,IAAA,CAAKP,QAAQ,EAAEhB,IAAA,CAAKwF,QAAQ,EAAE;UACtE,IAAIC,WAAA,GAAc;UAElB;UACA,IAAIC,oBAAA,GAAuB,IAAI,CAACP,gBAAgB,CAAC1C,GAAG,CAAClB,IAAA,CAAK1B,UAAU,CAAC7B,GAAG,KAAK,IAAI,CAACkB,mBAAmB;UACrG,OAAOuG,WAAA,GAAcC,oBAAA,CAAqB9H,MAAM,IAAI8H,oBAAoB,CAACD,WAAA,CAAY,GAAGH,gBAAA,EAAkB;YACxG,IAAID,GAAA,GAAMK,oBAAoB,CAACD,WAAA,CAAY;YAC3C,IAAIJ,GAAA,GAAM9D,IAAA,CAAKP,QAAQ,CAACpD,MAAM,EAC5B6G,GAAA,CAAIlF,IAAI,CAACgC,IAAA,CAAKP,QAAQ,CAACqE,GAAA,CAAI,CAACxF,UAAU;YAExC4F,WAAA;UACF;UAEA,KAAK,IAAI1H,CAAA,GAAIuH,gBAAA,EAAkBvH,CAAA,IAAKwH,eAAA,EAAiBxH,CAAA,IAAK;YACxD;YACA,OAAO0H,WAAA,GAAcC,oBAAA,CAAqB9H,MAAM,IAAI8H,oBAAoB,CAACD,WAAA,CAAY,GAAG1H,CAAA,EACtF0H,WAAA;YAGFhB,GAAA,CAAIlF,IAAI,CAACgC,IAAA,CAAKP,QAAQ,CAACjD,CAAA,CAAE,CAAC8B,UAAU;UACtC;UAEA;UACA,OAAO4F,WAAA,GAAcC,oBAAA,CAAqB9H,MAAM,EAAE;YAChD,IAAIyH,GAAA,GAAMK,oBAAoB,CAACD,WAAA,GAAc;YAC7C,IAAIJ,GAAA,GAAM9D,IAAA,CAAKP,QAAQ,CAACpD,MAAM,EAC5B6G,GAAA,CAAIlF,IAAI,CAACgC,IAAA,CAAKP,QAAQ,CAACqE,GAAA,CAAI,CAACxF,UAAU;UAE1C;UACA;QACF;MACA;QACE,MAAM,IAAIuE,KAAA,CAAM,uBAAuB7C,IAAA,CAAK1B,UAAU,CAAC4D,IAAI;IAC/D;EACF;EAEQqB,aAAaa,KAAmB,EAAEC,KAAY,EAAEC,IAAe,EAAE;IACvE,IAAIC,GAAA,GAAM;IACV,IAAIC,IAAA,GAAOJ,KAAA,CAAM/H,MAAM,GAAG;IAC1B,OAAOkI,GAAA,IAAOC,IAAA,EAAM;MAClB,IAAIC,GAAA,GAAMF,GAAC,GAAMC,IAAA,IAAS;MAC1B,IAAIE,IAAA,GAAON,KAAK,CAACK,GAAA,CAAI;MAErB,IAAIH,IAAC,KAAS,OAAOI,IAAA,CAAKpG,UAAU,CAACG,IAAI,CAAC6B,IAAI,IAAI+D,KAAA,CAAMnE,CAAC,IAAMoE,IAAA,KAAS,OAAOI,IAAA,CAAKpG,UAAU,CAACG,IAAI,CAACO,IAAI,IAAIqF,KAAA,CAAM7E,CAAC,EACjH+E,GAAA,GAAME,GAAA,GAAM,OACP,IAAIH,IAAC,KAAS,OAAOI,IAAA,CAAKpG,UAAU,CAACG,IAAI,CAACyB,CAAC,GAAGmE,KAAA,CAAMnE,CAAC,IAAMoE,IAAA,KAAS,OAAOI,IAAA,CAAKpG,UAAU,CAACG,IAAI,CAACe,CAAC,GAAG6E,KAAA,CAAM7E,CAAC,EAChHgF,IAAA,GAAOC,GAAA,GAAM,OAEb,OAAOA,GAAA;IAEX;IAEA,OAAO7F,IAAA,CAAKC,GAAG,CAAC,GAAGD,IAAA,CAAK+F,GAAG,CAACP,KAAA,CAAM/H,MAAM,GAAG,GAAGkI,GAAA;EAChD;EAEQpB,sBAAA,EAAwB;IAC9B,IAAI,IAAI,CAACnH,WAAW,CAAE4I,aAAa,KAAK,IAAI,CAACjG,iBAAiB,EAC5D;IAGF,IAAI,CAACA,iBAAiB,GAAG,IAAI,CAAC3C,WAAW,CAAE4I,aAAa;IACxD,IAAI,CAAChB,gBAAgB,CAACiB,KAAK;IAE3B;IACA,KAAK,IAAIpI,GAAA,IAAO,IAAI,CAACT,WAAW,CAAE4I,aAAa,EAAE;UAC9BE,qBAAA;MAAjB,IAAIxG,UAAA,IAAawG,qBAAA,OAAI,CAAC1G,WAAW,CAAC8C,GAAG,CAACzE,GAAA,eAArBqI,qBAAA,uBAAAA,qBAAA,CAA2BxG,UAAU;MAEtD;MACA,OAAOA,UAAA,IAAcA,UAAA,CAAWwB,SAAS,EAAE;YAS7BiF,sBAAA,EAKCC,sBAAA;QAbb,IAAIC,cAAA,GAAiB,IAAI,CAACjJ,WAAW,CAAED,UAAU,CAACmJ,OAAO,CAAC5G,UAAA,CAAW7B,GAAG;QACxE,IAAI0I,OAAA,GAAU,IAAI,CAACvB,gBAAgB,CAAC1C,GAAG,CAAC5C,UAAA,CAAWwB,SAAS;QAC5D,IAAI,CAACqF,OAAA,EAAS;UACZ;UACAA,OAAA,GAAU,CAAAF,cAAA,aAAAA,cAAA,uBAAAA,cAAA,CAAgB/C,IAAI,MAAK,UAAU,CAAA+C,cAAA,aAAAA,cAAA,uBAAAA,cAAA,CAAgB/C,IAAI,MAAK,WAAW,C,GAAI,IAAI,CAACvE,mBAAmB,CAAC,GAAG,EAAE;UACnH,IAAI,CAACiG,gBAAgB,CAACvF,GAAG,CAACC,UAAA,CAAWwB,SAAS,EAAEqF,OAAA;QAClD;QAEA,IAAIlH,KAAA,IAAQ8G,sBAAA,OAAI,CAAC3G,WAAW,CAAC8C,GAAG,CAAC5C,UAAA,CAAW7B,GAAG,eAAnCsI,sBAAA,uBAAAA,sBAAA,CAAsC9G,KAAK;QACvD,IAAIA,KAAA,IAAS,QAAQ,CAACkH,OAAA,CAAQC,QAAQ,CAACnH,KAAA,GACrCkH,OAAA,CAAQnH,IAAI,CAACC,KAAA;QAGfK,UAAA,IAAa0G,sBAAA,OAAI,CAAC5G,WAAW,CAAC8C,GAAG,CAAC5C,UAAA,CAAWwB,SAAS,eAAzCkF,sBAAA,uBAAAA,sBAAA,CAA4C1G,UAAU;MACrE;IACF;IAEA,KAAK,IAAI6G,OAAA,IAAW,IAAI,CAACvB,gBAAgB,CAACyB,MAAM,IAC9CF,OAAA,CAAQG,IAAI,CAAC,CAACC,CAAA,EAAGC,CAAA,KAAMD,CAAA,GAAIC,CAAA;EAE/B;EAEAC,uBAAuBvF,CAAS,EAAEV,CAAS,EAAEkG,iBAAkD,EAAqB;IAClHxF,CAAA,IAAK,IAAI,CAAClE,WAAW,CAAEwB,WAAW,CAAC0C,CAAC;IACpCV,CAAA,IAAK,IAAI,CAACxD,WAAW,CAAEwB,WAAW,CAACgC,CAAC;IAEpC;IACA,IAAI/C,GAAA,GAAkB;IACtB,IAAI4H,KAAA,GAAQ,KAAI,GAAAsB,YAAI,EAAEzF,CAAA,EAAGV,CAAA;IACzB,IAAIoG,WAAA,GAAc,KAAI,GAAA1G,WAAG,EAAEmF,KAAA,CAAMnE,CAAC,EAAEmE,KAAA,CAAM7E,CAAC,EAAE,GAAG;IAChD,IAAIqG,WAAA,GAAc,IAAI,CAAC7J,WAAW,CAAEuE,MAAM,CAACuC,qBAAqB,CAAC8C,WAAA,EAAaE,MAAM,CAACC,IAAA,IAAQA,IAAA,CAAK7D,IAAI,KAAK;IAE3G;IACA;IACA,KAAK,IAAI5D,UAAA,IAAcuH,WAAA,EACrB,IAAIvH,UAAA,CAAWG,IAAI,CAACuH,UAAU,CAACJ,WAAA,GAC7BnJ,GAAA,GAAM6B,UAAA,CAAW7B,GAAG;IAIxB,IAAIA,GAAA,IAAO,QAAQ,IAAI,CAACT,WAAW,CAAED,UAAU,CAACwG,IAAI,KAAK,GACvD,OAAO;MAACL,IAAA,EAAM;IAAM;IAGtB,IAAI5D,UAAA,GAAa,IAAI,CAAC2H,aAAa,CAACxJ,GAAA;IACpC,IAAI,CAAC6B,UAAA,EACH,OAAO;IAGT,IAAIG,IAAA,GAAOH,UAAA,CAAWG,IAAI;IAC1B,IAAIyH,MAAA,GAAqB;MACvBhE,IAAA,EAAM;MACNzF,GAAA,EAAK6B,UAAA,CAAW7B,GAAG;MACnB0J,YAAA,EAAc;IAChB;IAEA;IACA;IACA;IACA,IAAI,CAACT,iBAAA,CAAkBQ,MAAA,GAAS;MAC9B,IAAI1G,CAAA,IAAKf,IAAA,CAAKe,CAAC,GAAGf,IAAA,CAAKC,MAAM,GAAG,KAAKgH,iBAAA,CAAAU,aAAA,CAAAA,aAAA,KAAsBF,MAAM;QAAEC,YAAA,EAAc;MAAA,EAAQ,GACvFD,MAAA,CAAOC,YAAY,GAAG,cACjB,IAAIT,iBAAA,CAAAU,aAAA,CAAAA,aAAA,KAAsBF,MAAM;QAAEC,YAAA,EAAc;MAAA,EAAO,GAC5DD,MAAA,CAAOC,YAAY,GAAG;IAE1B,OAAO,IAAI3G,CAAA,IAAKf,IAAA,CAAKe,CAAC,GAAG,MAAMkG,iBAAA,CAAAU,aAAA,CAAAA,aAAA,KAAsBF,MAAM;MAAEC,YAAA,EAAc;IAAA,EAAQ,GACjFD,MAAA,CAAOC,YAAY,GAAG,cACjB,IAAI3G,CAAA,IAAKf,IAAA,CAAKO,IAAI,GAAG,MAAM0G,iBAAA,CAAAU,aAAA,CAAAA,aAAA,KAAsBF,MAAM;MAAEC,YAAA,EAAc;IAAA,EAAO,GACnFD,MAAA,CAAOC,YAAY,GAAG;IAGxB,OAAOD,MAAA;EACT;EAEAG,wBAAwBH,MAAsB,EAAc;IAC1D,IAAI5H,UAAA,GAAa,KAAK,CAAC+H,uBAAA,CAAwBH,MAAA;IAC/C5H,UAAA,CAAWwB,SAAS,GAAG,IAAK,CAAC9D,WAAW,CAAED,UAAU,CAAwBwC,IAAI,CAAC9B,GAAG;IACpF,OAAO6B,UAAA;EACT;EAxiBAgI,YAAYC,OAA0B,EAAE;IACtC,KAAK,CAACA,OAAA,QAPEnJ,cAAA,GAA4C,WAC9CF,YAAA,GAAiC,IAAIO,GAAA,SAErCkB,iBAAA,GAAqC,WACrCiF,gBAAA,GAAuC,IAAInG,GAAA;IAIjD,IAAI,CAACE,mBAAmB,GAAG,EAAE;EAC/B;AAsiBF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
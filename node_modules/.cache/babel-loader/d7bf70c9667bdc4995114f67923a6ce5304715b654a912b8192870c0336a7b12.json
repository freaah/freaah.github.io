{"ast":null,"code":"import { CalendarDate as $35ea8db9cb2ccb90$export$99faa760c7908e4f } from \"./CalendarDate.mjs\";\nimport { GregorianCalendar as $3b62074eb05584b2$export$80ee6245ec4f29ec } from \"./GregorianCalendar.mjs\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from the TC39 Temporal proposal.\n// Original licensing can be found in the NOTICE file in the root directory of this source tree.\n\nconst $62225008020f0a13$var$ERA_START_DATES = [[1868, 9, 8], [1912, 7, 30], [1926, 12, 25], [1989, 1, 8], [2019, 5, 1]];\nconst $62225008020f0a13$var$ERA_END_DATES = [[1912, 7, 29], [1926, 12, 24], [1989, 1, 7], [2019, 4, 30]];\nconst $62225008020f0a13$var$ERA_ADDENDS = [1867, 1911, 1925, 1988, 2018];\nconst $62225008020f0a13$var$ERA_NAMES = ['meiji', 'taisho', 'showa', 'heisei', 'reiwa'];\nfunction $62225008020f0a13$var$findEraFromGregorianDate(date) {\n  const idx = $62225008020f0a13$var$ERA_START_DATES.findIndex(_ref => {\n    let [year, month, day] = _ref;\n    if (date.year < year) return true;\n    if (date.year === year && date.month < month) return true;\n    if (date.year === year && date.month === month && date.day < day) return true;\n    return false;\n  });\n  if (idx === -1) return $62225008020f0a13$var$ERA_START_DATES.length - 1;\n  if (idx === 0) return 0;\n  return idx - 1;\n}\nfunction $62225008020f0a13$var$toGregorian(date) {\n  let eraAddend = $62225008020f0a13$var$ERA_ADDENDS[$62225008020f0a13$var$ERA_NAMES.indexOf(date.era)];\n  if (!eraAddend) throw new Error('Unknown era: ' + date.era);\n  return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(date.year + eraAddend, date.month, date.day);\n}\nclass $62225008020f0a13$export$b746ab2b60cdffbf extends (0, $3b62074eb05584b2$export$80ee6245ec4f29ec) {\n  fromJulianDay(jd) {\n    let date = super.fromJulianDay(jd);\n    let era = $62225008020f0a13$var$findEraFromGregorianDate(date);\n    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, $62225008020f0a13$var$ERA_NAMES[era], date.year - $62225008020f0a13$var$ERA_ADDENDS[era], date.month, date.day);\n  }\n  toJulianDay(date) {\n    return super.toJulianDay($62225008020f0a13$var$toGregorian(date));\n  }\n  balanceDate(date) {\n    let gregorianDate = $62225008020f0a13$var$toGregorian(date);\n    let era = $62225008020f0a13$var$findEraFromGregorianDate(gregorianDate);\n    if ($62225008020f0a13$var$ERA_NAMES[era] !== date.era) {\n      date.era = $62225008020f0a13$var$ERA_NAMES[era];\n      date.year = gregorianDate.year - $62225008020f0a13$var$ERA_ADDENDS[era];\n    }\n    // Constrain in case we went before the first supported era.\n    this.constrainDate(date);\n  }\n  constrainDate(date) {\n    let idx = $62225008020f0a13$var$ERA_NAMES.indexOf(date.era);\n    let end = $62225008020f0a13$var$ERA_END_DATES[idx];\n    if (end != null) {\n      let [endYear, endMonth, endDay] = end;\n      // Constrain the year to the maximum possible value in the era.\n      // Then constrain the month and day fields within that.\n      let maxYear = endYear - $62225008020f0a13$var$ERA_ADDENDS[idx];\n      date.year = Math.max(1, Math.min(maxYear, date.year));\n      if (date.year === maxYear) {\n        date.month = Math.min(endMonth, date.month);\n        if (date.month === endMonth) date.day = Math.min(endDay, date.day);\n      }\n    }\n    if (date.year === 1 && idx >= 0) {\n      let [, startMonth, startDay] = $62225008020f0a13$var$ERA_START_DATES[idx];\n      date.month = Math.max(startMonth, date.month);\n      if (date.month === startMonth) date.day = Math.max(startDay, date.day);\n    }\n  }\n  getEras() {\n    return $62225008020f0a13$var$ERA_NAMES;\n  }\n  getYearsInEra(date) {\n    // Get the number of years in the era, taking into account the date's month and day fields.\n    let era = $62225008020f0a13$var$ERA_NAMES.indexOf(date.era);\n    let cur = $62225008020f0a13$var$ERA_START_DATES[era];\n    let next = $62225008020f0a13$var$ERA_START_DATES[era + 1];\n    if (next == null)\n      // 9999 gregorian is the maximum year allowed.\n      return 9999 - cur[0] + 1;\n    let years = next[0] - cur[0];\n    if (date.month < next[1] || date.month === next[1] && date.day < next[2]) years++;\n    return years;\n  }\n  getDaysInMonth(date) {\n    return super.getDaysInMonth($62225008020f0a13$var$toGregorian(date));\n  }\n  getMinimumMonthInYear(date) {\n    let start = $62225008020f0a13$var$getMinimums(date);\n    return start ? start[1] : 1;\n  }\n  getMinimumDayInMonth(date) {\n    let start = $62225008020f0a13$var$getMinimums(date);\n    return start && date.month === start[1] ? start[2] : 1;\n  }\n  constructor() {\n    super(...arguments), this.identifier = 'japanese';\n  }\n}\nfunction $62225008020f0a13$var$getMinimums(date) {\n  if (date.year === 1) {\n    let idx = $62225008020f0a13$var$ERA_NAMES.indexOf(date.era);\n    return $62225008020f0a13$var$ERA_START_DATES[idx];\n  }\n}\nexport { $62225008020f0a13$export$b746ab2b60cdffbf as JapaneseCalendar };","map":{"version":3,"names":["$62225008020f0a13$var$ERA_START_DATES","$62225008020f0a13$var$ERA_END_DATES","$62225008020f0a13$var$ERA_ADDENDS","$62225008020f0a13$var$ERA_NAMES","$62225008020f0a13$var$findEraFromGregorianDate","date","idx","findIndex","_ref","year","month","day","length","$62225008020f0a13$var$toGregorian","eraAddend","indexOf","era","Error","$35ea8db9cb2ccb90$export$99faa760c7908e4f","$62225008020f0a13$export$b746ab2b60cdffbf","$3b62074eb05584b2$export$80ee6245ec4f29ec","fromJulianDay","jd","toJulianDay","balanceDate","gregorianDate","constrainDate","end","endYear","endMonth","endDay","maxYear","Math","max","min","startMonth","startDay","getEras","getYearsInEra","cur","next","years","getDaysInMonth","getMinimumMonthInYear","start","$62225008020f0a13$var$getMinimums","getMinimumDayInMonth","arguments","identifier"],"sources":["C:\\Users\\rewac\\OneDrive\\Documents\\GitHub\\scatch-store.me\\node_modules\\@internationalized\\date\\dist\\packages\\@internationalized\\date\\src\\calendars\\JapaneseCalendar.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// Portions of the code in this file are based on code from the TC39 Temporal proposal.\n// Original licensing can be found in the NOTICE file in the root directory of this source tree.\n\nimport {AnyCalendarDate} from '../types';\nimport {CalendarDate} from '../CalendarDate';\nimport {GregorianCalendar} from './GregorianCalendar';\nimport {Mutable} from '../utils';\n\nconst ERA_START_DATES = [[1868, 9, 8], [1912, 7, 30], [1926, 12, 25], [1989, 1, 8], [2019, 5, 1]];\nconst ERA_END_DATES = [[1912, 7, 29], [1926, 12, 24], [1989, 1, 7], [2019, 4, 30]];\nconst ERA_ADDENDS = [1867, 1911, 1925, 1988, 2018];\nconst ERA_NAMES = ['meiji', 'taisho', 'showa', 'heisei', 'reiwa'];\n\nfunction findEraFromGregorianDate(date: AnyCalendarDate) {\n  const idx = ERA_START_DATES.findIndex(([year, month, day]) => {\n    if (date.year < year) {\n      return true;\n    }\n\n    if (date.year === year && date.month < month) {\n      return true;\n    }\n\n    if (date.year === year && date.month === month && date.day < day) {\n      return true;\n    }\n\n    return false;\n  });\n\n  if (idx === -1) {\n    return ERA_START_DATES.length - 1;\n  }\n\n  if (idx === 0) {\n    return 0;\n  }\n\n  return idx - 1;\n}\n\nfunction toGregorian(date: AnyCalendarDate) {\n  let eraAddend = ERA_ADDENDS[ERA_NAMES.indexOf(date.era)];\n  if (!eraAddend) {\n    throw new Error('Unknown era: ' + date.era);\n  }\n\n  return new CalendarDate(\n    date.year + eraAddend,\n    date.month,\n    date.day\n  );\n}\n\n/**\n * The Japanese calendar is based on the Gregorian calendar, but with eras for the reign of each Japanese emperor.\n * Whenever a new emperor ascends to the throne, a new era begins and the year starts again from 1.\n * Note that eras before 1868 (Gregorian) are not currently supported by this implementation.\n */\nexport class JapaneseCalendar extends GregorianCalendar {\n  identifier = 'japanese';\n\n  fromJulianDay(jd: number): CalendarDate {\n    let date = super.fromJulianDay(jd);\n    let era = findEraFromGregorianDate(date);\n\n    return new CalendarDate(\n      this,\n      ERA_NAMES[era],\n      date.year - ERA_ADDENDS[era],\n      date.month,\n      date.day\n    );\n  }\n\n  toJulianDay(date: AnyCalendarDate) {\n    return super.toJulianDay(toGregorian(date));\n  }\n\n  balanceDate(date: Mutable<AnyCalendarDate>) {\n    let gregorianDate = toGregorian(date);\n    let era = findEraFromGregorianDate(gregorianDate);\n\n    if (ERA_NAMES[era] !== date.era) {\n      date.era = ERA_NAMES[era];\n      date.year = gregorianDate.year - ERA_ADDENDS[era];\n    }\n\n    // Constrain in case we went before the first supported era.\n    this.constrainDate(date);\n  }\n\n  constrainDate(date: Mutable<AnyCalendarDate>) {\n    let idx = ERA_NAMES.indexOf(date.era);\n    let end = ERA_END_DATES[idx];\n    if (end != null) {\n      let [endYear, endMonth, endDay] = end;\n\n      // Constrain the year to the maximum possible value in the era.\n      // Then constrain the month and day fields within that.\n      let maxYear = endYear - ERA_ADDENDS[idx];\n      date.year = Math.max(1, Math.min(maxYear, date.year));\n      if (date.year === maxYear) {\n        date.month = Math.min(endMonth, date.month);\n\n        if (date.month === endMonth) {\n          date.day = Math.min(endDay, date.day);\n        }\n      }\n    }\n\n    if (date.year === 1 && idx >= 0) {\n      let [, startMonth, startDay] = ERA_START_DATES[idx];\n      date.month = Math.max(startMonth, date.month);\n\n      if (date.month === startMonth) {\n        date.day = Math.max(startDay, date.day);\n      }\n    }\n  }\n\n  getEras() {\n    return ERA_NAMES;\n  }\n\n  getYearsInEra(date: AnyCalendarDate): number {\n    // Get the number of years in the era, taking into account the date's month and day fields.\n    let era = ERA_NAMES.indexOf(date.era);\n    let cur = ERA_START_DATES[era];\n    let next = ERA_START_DATES[era + 1];\n    if (next == null) {\n      // 9999 gregorian is the maximum year allowed.\n      return 9999 - cur[0] + 1;\n    }\n\n    let years = next[0] - cur[0];\n\n    if (date.month < next[1] || (date.month === next[1] && date.day < next[2])) {\n      years++;\n    }\n\n    return years;\n  }\n\n  getDaysInMonth(date: AnyCalendarDate): number {\n    return super.getDaysInMonth(toGregorian(date));\n  }\n\n  getMinimumMonthInYear(date: AnyCalendarDate): number {\n    let start = getMinimums(date);\n    return start ? start[1] : 1;\n  }\n\n  getMinimumDayInMonth(date: AnyCalendarDate): number {\n    let start = getMinimums(date);\n    return start && date.month === start[1] ? start[2] : 1;\n  }\n}\n\nfunction getMinimums(date: AnyCalendarDate) {\n  if (date.year === 1) {\n    let idx = ERA_NAMES.indexOf(date.era);\n    return ERA_START_DATES[idx];\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
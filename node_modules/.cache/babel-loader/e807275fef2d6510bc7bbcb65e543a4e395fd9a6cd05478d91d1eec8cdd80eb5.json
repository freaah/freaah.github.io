{"ast":null,"code":"import _objectSpread from \"C:/Users/rewac/OneDrive/Documents/GitHub/scatch-store.me/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { snapValueToStep as $kNCPO$snapValueToStep, clamp as $kNCPO$clamp, useControlledState as $kNCPO$useControlledState } from \"@react-stately/utils\";\nimport { useFormValidationState as $kNCPO$useFormValidationState } from \"@react-stately/form\";\nimport { NumberFormatter as $kNCPO$NumberFormatter, NumberParser as $kNCPO$NumberParser } from \"@internationalized/number\";\nimport { useState as $kNCPO$useState, useMemo as $kNCPO$useMemo, useCallback as $kNCPO$useCallback } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $de67e98908f0c6ee$export$7f629e9dc1ecf37c(props) {\n  let {\n    minValue: minValue,\n    maxValue: maxValue,\n    step: step,\n    formatOptions: formatOptions,\n    value: value,\n    defaultValue = NaN,\n    onChange: onChange,\n    locale: locale,\n    isDisabled: isDisabled,\n    isReadOnly: isReadOnly\n  } = props;\n  if (value === null) value = NaN;\n  if (value !== undefined && !isNaN(value)) {\n    if (step !== undefined && !isNaN(step)) value = (0, $kNCPO$snapValueToStep)(value, minValue, maxValue, step);else value = (0, $kNCPO$clamp)(value, minValue, maxValue);\n  }\n  if (!isNaN(defaultValue)) {\n    if (step !== undefined && !isNaN(step)) defaultValue = (0, $kNCPO$snapValueToStep)(defaultValue, minValue, maxValue, step);else defaultValue = (0, $kNCPO$clamp)(defaultValue, minValue, maxValue);\n  }\n  let [numberValue, setNumberValue] = (0, $kNCPO$useControlledState)(value, isNaN(defaultValue) ? NaN : defaultValue, onChange);\n  let [inputValue, setInputValue] = (0, $kNCPO$useState)(() => isNaN(numberValue) ? '' : new (0, $kNCPO$NumberFormatter)(locale, formatOptions).format(numberValue));\n  let numberParser = (0, $kNCPO$useMemo)(() => new (0, $kNCPO$NumberParser)(locale, formatOptions), [locale, formatOptions]);\n  let numberingSystem = (0, $kNCPO$useMemo)(() => numberParser.getNumberingSystem(inputValue), [numberParser, inputValue]);\n  let formatter = (0, $kNCPO$useMemo)(() => new (0, $kNCPO$NumberFormatter)(locale, _objectSpread(_objectSpread({}, formatOptions), {}, {\n    numberingSystem: numberingSystem\n  })), [locale, formatOptions, numberingSystem]);\n  let intlOptions = (0, $kNCPO$useMemo)(() => formatter.resolvedOptions(), [formatter]);\n  let format = (0, $kNCPO$useCallback)(value => isNaN(value) || value === null ? '' : formatter.format(value), [formatter]);\n  let validation = (0, $kNCPO$useFormValidationState)(_objectSpread(_objectSpread({}, props), {}, {\n    value: numberValue\n  }));\n  let clampStep = step !== undefined && !isNaN(step) ? step : 1;\n  if (intlOptions.style === 'percent' && (step === undefined || isNaN(step))) clampStep = 0.01;\n  // Update the input value when the number value or format options change. This is done\n  // in a useEffect so that the controlled behavior is correct and we only update the\n  // textfield after prop changes.\n  let [prevValue, setPrevValue] = (0, $kNCPO$useState)(numberValue);\n  let [prevLocale, setPrevLocale] = (0, $kNCPO$useState)(locale);\n  let [prevFormatOptions, setPrevFormatOptions] = (0, $kNCPO$useState)(formatOptions);\n  if (!Object.is(numberValue, prevValue) || locale !== prevLocale || formatOptions !== prevFormatOptions) {\n    setInputValue(format(numberValue));\n    setPrevValue(numberValue);\n    setPrevLocale(locale);\n    setPrevFormatOptions(formatOptions);\n  }\n  let parsedValue = (0, $kNCPO$useMemo)(() => numberParser.parse(inputValue), [numberParser, inputValue]);\n  let commit = () => {\n    // Set to empty state if input value is empty\n    if (!inputValue.length) {\n      setNumberValue(NaN);\n      setInputValue(value === undefined ? '' : format(numberValue));\n      return;\n    }\n    // if it failed to parse, then reset input to formatted version of current number\n    if (isNaN(parsedValue)) {\n      setInputValue(format(numberValue));\n      return;\n    }\n    // Clamp to min and max, round to the nearest step, and round to specified number of digits\n    let clampedValue;\n    if (step === undefined || isNaN(step)) clampedValue = (0, $kNCPO$clamp)(parsedValue, minValue, maxValue);else clampedValue = (0, $kNCPO$snapValueToStep)(parsedValue, minValue, maxValue, step);\n    clampedValue = numberParser.parse(format(clampedValue));\n    setNumberValue(clampedValue);\n    // in a controlled state, the numberValue won't change, so we won't go back to our old input without help\n    setInputValue(format(value === undefined ? clampedValue : numberValue));\n  };\n  let safeNextStep = function (operation) {\n    let minMax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let prev = parsedValue;\n    if (isNaN(prev)) {\n      // if the input is empty, start from the min/max value when incrementing/decrementing,\n      // or zero if there is no min/max value defined.\n      let newValue = isNaN(minMax) ? 0 : minMax;\n      return (0, $kNCPO$snapValueToStep)(newValue, minValue, maxValue, clampStep);\n    } else {\n      // otherwise, first snap the current value to the nearest step. if it moves in the direction\n      // we're going, use that value, otherwise add the step and snap that value.\n      let newValue = (0, $kNCPO$snapValueToStep)(prev, minValue, maxValue, clampStep);\n      if (operation === '+' && newValue > prev || operation === '-' && newValue < prev) return newValue;\n      return (0, $kNCPO$snapValueToStep)($de67e98908f0c6ee$var$handleDecimalOperation(operation, prev, clampStep), minValue, maxValue, clampStep);\n    }\n  };\n  let increment = () => {\n    let newValue = safeNextStep('+', minValue);\n    // if we've arrived at the same value that was previously in the state, the\n    // input value should be updated to match\n    // ex type 4, press increment, highlight the number in the input, type 4 again, press increment\n    // you'd be at 5, then incrementing to 5 again, so no re-render would happen and 4 would be left in the input\n    if (newValue === numberValue) setInputValue(format(newValue));\n    setNumberValue(newValue);\n    validation.commitValidation();\n  };\n  let decrement = () => {\n    let newValue = safeNextStep('-', maxValue);\n    if (newValue === numberValue) setInputValue(format(newValue));\n    setNumberValue(newValue);\n    validation.commitValidation();\n  };\n  let incrementToMax = () => {\n    if (maxValue != null) {\n      setNumberValue((0, $kNCPO$snapValueToStep)(maxValue, minValue, maxValue, clampStep));\n      validation.commitValidation();\n    }\n  };\n  let decrementToMin = () => {\n    if (minValue != null) {\n      setNumberValue(minValue);\n      validation.commitValidation();\n    }\n  };\n  let canIncrement = (0, $kNCPO$useMemo)(() => !isDisabled && !isReadOnly && (isNaN(parsedValue) || maxValue === undefined || isNaN(maxValue) || (0, $kNCPO$snapValueToStep)(parsedValue, minValue, maxValue, clampStep) > parsedValue || $de67e98908f0c6ee$var$handleDecimalOperation('+', parsedValue, clampStep) <= maxValue), [isDisabled, isReadOnly, minValue, maxValue, clampStep, parsedValue]);\n  let canDecrement = (0, $kNCPO$useMemo)(() => !isDisabled && !isReadOnly && (isNaN(parsedValue) || minValue === undefined || isNaN(minValue) || (0, $kNCPO$snapValueToStep)(parsedValue, minValue, maxValue, clampStep) < parsedValue || $de67e98908f0c6ee$var$handleDecimalOperation('-', parsedValue, clampStep) >= minValue), [isDisabled, isReadOnly, minValue, maxValue, clampStep, parsedValue]);\n  let validate = value => numberParser.isValidPartialNumber(value, minValue, maxValue);\n  return _objectSpread(_objectSpread({}, validation), {}, {\n    validate: validate,\n    increment: increment,\n    incrementToMax: incrementToMax,\n    decrement: decrement,\n    decrementToMin: decrementToMin,\n    canIncrement: canIncrement,\n    canDecrement: canDecrement,\n    minValue: minValue,\n    maxValue: maxValue,\n    numberValue: parsedValue,\n    setNumberValue: setNumberValue,\n    setInputValue: setInputValue,\n    inputValue: inputValue,\n    commit: commit\n  });\n}\nfunction $de67e98908f0c6ee$var$handleDecimalOperation(operator, value1, value2) {\n  let result = operator === '+' ? value1 + value2 : value1 - value2;\n  // Check if we have decimals\n  if (value1 % 1 !== 0 || value2 % 1 !== 0) {\n    const value1Decimal = value1.toString().split('.');\n    const value2Decimal = value2.toString().split('.');\n    const value1DecimalLength = value1Decimal[1] && value1Decimal[1].length || 0;\n    const value2DecimalLength = value2Decimal[1] && value2Decimal[1].length || 0;\n    const multiplier = Math.pow(10, Math.max(value1DecimalLength, value2DecimalLength));\n    // Transform the decimals to integers based on the precision\n    value1 = Math.round(value1 * multiplier);\n    value2 = Math.round(value2 * multiplier);\n    // Perform the operation on integers values to make sure we don't get a fancy decimal value\n    result = operator === '+' ? value1 + value2 : value1 - value2;\n    // Transform the integer result back to decimal\n    result /= multiplier;\n  }\n  return result;\n}\nexport { $de67e98908f0c6ee$export$7f629e9dc1ecf37c as useNumberFieldState };","map":{"version":3,"names":["$de67e98908f0c6ee$export$7f629e9dc1ecf37c","props","minValue","maxValue","step","formatOptions","value","defaultValue","NaN","onChange","locale","isDisabled","isReadOnly","undefined","isNaN","$kNCPO$snapValueToStep","$kNCPO$clamp","numberValue","setNumberValue","$kNCPO$useControlledState","inputValue","setInputValue","$kNCPO$useState","$kNCPO$NumberFormatter","format","numberParser","$kNCPO$useMemo","$kNCPO$NumberParser","numberingSystem","getNumberingSystem","formatter","_objectSpread","intlOptions","resolvedOptions","$kNCPO$useCallback","validation","$kNCPO$useFormValidationState","clampStep","style","prevValue","setPrevValue","prevLocale","setPrevLocale","prevFormatOptions","setPrevFormatOptions","Object","is","parsedValue","parse","commit","length","clampedValue","safeNextStep","operation","minMax","arguments","prev","newValue","$de67e98908f0c6ee$var$handleDecimalOperation","increment","commitValidation","decrement","incrementToMax","decrementToMin","canIncrement","canDecrement","validate","isValidPartialNumber","operator","value1","value2","result","value1Decimal","toString","split","value2Decimal","value1DecimalLength","value2DecimalLength","multiplier","Math","pow","max","round"],"sources":["C:\\Users\\rewac\\OneDrive\\Documents\\GitHub\\scatch-store.me\\node_modules\\@react-stately\\numberfield\\dist\\packages\\@react-stately\\numberfield\\src\\useNumberFieldState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {clamp, snapValueToStep, useControlledState} from '@react-stately/utils';\nimport {FormValidationState, useFormValidationState} from '@react-stately/form';\nimport {NumberFieldProps} from '@react-types/numberfield';\nimport {NumberFormatter, NumberParser} from '@internationalized/number';\nimport {useCallback, useMemo, useState} from 'react';\n\nexport interface NumberFieldState extends FormValidationState {\n  /**\n   * The current text value of the input. Updated as the user types,\n   * and formatted according to `formatOptions` on blur.\n   */\n  inputValue: string,\n  /**\n   * The currently parsed number value, or NaN if a valid number could not be parsed.\n   * Updated based on the `inputValue` as the user types.\n   */\n  numberValue: number,\n  /** The minimum value of the number field. */\n  minValue?: number,\n  /** The maximum value of the number field. */\n  maxValue?: number,\n  /** Whether the current value can be incremented according to the maximum value and step. */\n  canIncrement: boolean,\n  /** Whether the current value can be decremented according to the minimum value and step. */\n  canDecrement: boolean,\n  /**\n   * Validates a user input string according to the current locale and format options.\n   * Values can be partially entered, and may be valid even if they cannot currently be parsed to a number.\n   * Can be used to implement validation as a user types.\n   */\n  validate(value: string): boolean,\n  /** Sets the current text value of the input. */\n  setInputValue(val: string): void,\n  /** Sets the number value. */\n  setNumberValue(val: number): void,\n  /**\n   * Commits the current input value. The value is parsed to a number, clamped according\n   * to the minimum and maximum values of the field, and snapped to the nearest step value.\n   * This will fire the `onChange` prop with the new value, and if uncontrolled, update the `numberValue`.\n   * Typically this is called when the field is blurred.\n   */\n  commit(): void,\n  /** Increments the current input value to the next step boundary, and fires `onChange`. */\n  increment(): void,\n  /** Decrements the current input value to the next step boundary, and fires `onChange`. */\n  decrement(): void,\n  /** Sets the current value to the `maxValue` if any, and fires `onChange`. */\n  incrementToMax(): void,\n  /** Sets the current value to the `minValue` if any, and fires `onChange`. */\n  decrementToMin(): void\n}\n\nexport interface NumberFieldStateOptions extends NumberFieldProps {\n  /**\n   * The locale that should be used for parsing.\n   * @default 'en-US'\n   */\n  locale: string\n}\n\n/**\n * Provides state management for a number field component. Number fields allow users to enter a number,\n * and increment or decrement the value using stepper buttons.\n */\nexport function useNumberFieldState(\n  props: NumberFieldStateOptions\n): NumberFieldState {\n  let {\n    minValue,\n    maxValue,\n    step,\n    formatOptions,\n    value,\n    defaultValue = NaN,\n    onChange,\n    locale,\n    isDisabled,\n    isReadOnly\n  } = props;\n\n  if (value === null) {\n    value = NaN;\n  }\n\n  if (value !== undefined && !isNaN(value)) {\n    if (step !== undefined && !isNaN(step)) {\n      value = snapValueToStep(value, minValue, maxValue, step);\n    } else {\n      value = clamp(value, minValue, maxValue);\n    }\n  }\n\n  if (!isNaN(defaultValue)) {\n    if (step !== undefined && !isNaN(step)) {\n      defaultValue = snapValueToStep(defaultValue, minValue, maxValue, step);\n    } else {\n      defaultValue = clamp(defaultValue, minValue, maxValue);\n    }\n  }\n\n  let [numberValue, setNumberValue] = useControlledState<number>(value, isNaN(defaultValue) ? NaN : defaultValue, onChange);\n  let [inputValue, setInputValue] = useState(() => isNaN(numberValue) ? '' : new NumberFormatter(locale, formatOptions).format(numberValue));\n\n  let numberParser = useMemo(() => new NumberParser(locale, formatOptions), [locale, formatOptions]);\n  let numberingSystem = useMemo(() => numberParser.getNumberingSystem(inputValue), [numberParser, inputValue]);\n  let formatter = useMemo(() => new NumberFormatter(locale, {...formatOptions, numberingSystem}), [locale, formatOptions, numberingSystem]);\n  let intlOptions = useMemo(() => formatter.resolvedOptions(), [formatter]);\n  let format = useCallback((value: number) => (isNaN(value) || value === null) ? '' : formatter.format(value), [formatter]);\n\n  let validation = useFormValidationState({\n    ...props,\n    value: numberValue\n  });\n\n  let clampStep = (step !== undefined && !isNaN(step)) ? step : 1;\n  if (intlOptions.style === 'percent' && (step === undefined || isNaN(step))) {\n    clampStep = 0.01;\n  }\n\n  // Update the input value when the number value or format options change. This is done\n  // in a useEffect so that the controlled behavior is correct and we only update the\n  // textfield after prop changes.\n  let [prevValue, setPrevValue] = useState(numberValue);\n  let [prevLocale, setPrevLocale] = useState(locale);\n  let [prevFormatOptions, setPrevFormatOptions] = useState(formatOptions);\n  if (!Object.is(numberValue, prevValue) || locale !== prevLocale || formatOptions !== prevFormatOptions) {\n    setInputValue(format(numberValue));\n    setPrevValue(numberValue);\n    setPrevLocale(locale);\n    setPrevFormatOptions(formatOptions);\n  }\n\n  let parsedValue = useMemo(() => numberParser.parse(inputValue), [numberParser, inputValue]);\n  let commit = () => {\n    // Set to empty state if input value is empty\n    if (!inputValue.length) {\n      setNumberValue(NaN);\n      setInputValue(value === undefined ? '' : format(numberValue));\n      return;\n    }\n\n    // if it failed to parse, then reset input to formatted version of current number\n    if (isNaN(parsedValue)) {\n      setInputValue(format(numberValue));\n      return;\n    }\n\n    // Clamp to min and max, round to the nearest step, and round to specified number of digits\n    let clampedValue: number;\n    if (step === undefined || isNaN(step)) {\n      clampedValue = clamp(parsedValue, minValue, maxValue);\n    } else {\n      clampedValue = snapValueToStep(parsedValue, minValue, maxValue, step);\n    }\n\n    clampedValue = numberParser.parse(format(clampedValue));\n    setNumberValue(clampedValue);\n\n    // in a controlled state, the numberValue won't change, so we won't go back to our old input without help\n    setInputValue(format(value === undefined ? clampedValue : numberValue));\n  };\n\n  let safeNextStep = (operation: '+' | '-', minMax: number = 0) => {\n    let prev = parsedValue;\n\n    if (isNaN(prev)) {\n      // if the input is empty, start from the min/max value when incrementing/decrementing,\n      // or zero if there is no min/max value defined.\n      let newValue = isNaN(minMax) ? 0 : minMax;\n      return snapValueToStep(newValue, minValue, maxValue, clampStep);\n    } else {\n      // otherwise, first snap the current value to the nearest step. if it moves in the direction\n      // we're going, use that value, otherwise add the step and snap that value.\n      let newValue = snapValueToStep(prev, minValue, maxValue, clampStep);\n      if ((operation === '+' && newValue > prev) || (operation === '-' && newValue < prev)) {\n        return newValue;\n      }\n\n      return snapValueToStep(\n        handleDecimalOperation(operation, prev, clampStep),\n        minValue,\n        maxValue,\n        clampStep\n      );\n    }\n  };\n\n  let increment = () => {\n    let newValue = safeNextStep('+', minValue);\n\n    // if we've arrived at the same value that was previously in the state, the\n    // input value should be updated to match\n    // ex type 4, press increment, highlight the number in the input, type 4 again, press increment\n    // you'd be at 5, then incrementing to 5 again, so no re-render would happen and 4 would be left in the input\n    if (newValue === numberValue) {\n      setInputValue(format(newValue));\n    }\n\n    setNumberValue(newValue);\n    validation.commitValidation();\n  };\n\n  let decrement = () => {\n    let newValue = safeNextStep('-', maxValue);\n\n    if (newValue === numberValue) {\n      setInputValue(format(newValue));\n    }\n\n    setNumberValue(newValue);\n    validation.commitValidation();\n  };\n\n  let incrementToMax = () => {\n    if (maxValue != null) {\n      setNumberValue(snapValueToStep(maxValue, minValue, maxValue, clampStep));\n      validation.commitValidation();\n    }\n  };\n\n  let decrementToMin = () => {\n    if (minValue != null) {\n      setNumberValue(minValue);\n      validation.commitValidation();\n    }\n  };\n\n  let canIncrement = useMemo(() => (\n    !isDisabled &&\n    !isReadOnly &&\n    (\n      isNaN(parsedValue) ||\n      (maxValue === undefined || isNaN(maxValue)) ||\n      snapValueToStep(parsedValue, minValue, maxValue, clampStep) > parsedValue ||\n      handleDecimalOperation('+', parsedValue, clampStep) <= maxValue\n    )\n  ), [isDisabled, isReadOnly, minValue, maxValue, clampStep, parsedValue]);\n\n  let canDecrement = useMemo(() => (\n    !isDisabled &&\n    !isReadOnly &&\n    (\n      isNaN(parsedValue) ||\n      (minValue === undefined || isNaN(minValue)) ||\n      snapValueToStep(parsedValue, minValue, maxValue, clampStep) < parsedValue ||\n      handleDecimalOperation('-', parsedValue, clampStep) >= minValue\n    )\n  ), [isDisabled, isReadOnly, minValue, maxValue, clampStep, parsedValue]);\n\n  let validate = (value: string) => numberParser.isValidPartialNumber(value, minValue, maxValue);\n\n  return {\n    ...validation,\n    validate,\n    increment,\n    incrementToMax,\n    decrement,\n    decrementToMin,\n    canIncrement,\n    canDecrement,\n    minValue,\n    maxValue,\n    numberValue: parsedValue,\n    setNumberValue,\n    setInputValue,\n    inputValue,\n    commit\n  };\n}\n\nfunction handleDecimalOperation(operator: '-' | '+', value1: number, value2: number): number {\n  let result = operator === '+' ? value1 + value2 : value1 - value2;\n\n  // Check if we have decimals\n  if (value1 % 1 !== 0 || value2 % 1 !== 0) {\n    const value1Decimal = value1.toString().split('.');\n    const value2Decimal = value2.toString().split('.');\n    const value1DecimalLength = (value1Decimal[1] && value1Decimal[1].length) || 0;\n    const value2DecimalLength = (value2Decimal[1] && value2Decimal[1].length) || 0;\n    const multiplier = Math.pow(10, Math.max(value1DecimalLength, value2DecimalLength));\n\n    // Transform the decimals to integers based on the precision\n    value1 = Math.round(value1 * multiplier);\n    value2 = Math.round(value2 * multiplier);\n\n    // Perform the operation on integers values to make sure we don't get a fancy decimal value\n    result = operator === '+' ? value1 + value2 : value1 - value2;\n\n    // Transform the integer result back to decimal\n    result /= multiplier;\n  }\n\n  return result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}